{"meta":{"title":"DBKernel","subtitle":"","description":"专注于数据库技术分享","author":"DBKernel","url":"http://dbkernel.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-07-10T09:34:18.000Z","updated":"2021-07-10T10:49:25.987Z","comments":false,"path":"categories/index.html","permalink":"http://dbkernel.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-05-27T05:47:40.000Z","updated":"2021-07-10T13:50:19.870Z","comments":false,"path":"tags/index.html","permalink":"http://dbkernel.github.io/tags/index.html","excerpt":"","text":"-"},{"title":"关于","date":"2021-07-10T05:47:55.000Z","updated":"2021-07-10T13:59:06.317Z","comments":false,"path":"about/index.html","permalink":"http://dbkernel.github.io/about/index.html","excerpt":"","text":"简介卢文双 xxx yyy"},{"title":"友情链接","date":"2021-07-11T13:25:13.262Z","updated":"2021-07-11T13:25:13.213Z","comments":true,"path":"links/index.html","permalink":"http://dbkernel.github.io/links/index.html","excerpt":"","text":"微信公众号：MySQL数据库技术"},{"title":"项目","date":"2021-07-11T13:27:01.021Z","updated":"2021-07-11T13:27:00.986Z","comments":true,"path":"repository/index.html","permalink":"http://dbkernel.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL select count(*) 、count(1)、count(列) 详解（1）：概念及区别","slug":"MySQL select count(*) 、count(1)、count(列) 详解（1）：概念及区别","date":"2020-05-06T07:55:15.000Z","updated":"2021-07-12T04:07:08.300Z","comments":true,"path":"2020/05/06/MySQL select count(*) 、count(1)、count(列) 详解（1）：概念及区别/","link":"","permalink":"http://dbkernel.github.io/2020/05/06/MySQL%20select%20count(*)%20%E3%80%81count(1)%E3%80%81count(%E5%88%97)%20%E8%AF%A6%E8%A7%A3%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、前言从接触MySQL开始断断续续的看过一些文章，对count()操作众说纷纭，其中分歧点主要在于count(1)和count(*)哪个效率高，有说count(1)比count(*)快的（这种说法更普遍），有说二者一样快的。个人理解这两种行为可能适用于的是不同的版本，我只关心较新的MySQL版本是什么行为，详见下文。 二、含义首先，先说明一下常见count()操作及含义： count(*)：计算包括NULL值在内的行数，SQL92定义的标准统计行数的语法。 count(1)：计算包括NULL值在内的行数，其中的1是恒真表达式。 count(列名)：计算指定列的行数，但不包含NULL值。 三、具体区别MySQL手册中相关描述如下： For transactional storage engines such as InnoDB, storing an exact row count is problematic. Multiple transactions may be occurring at the same time, each of which may affect the count. InnoDB does not keep an internal count of rows in a table because concurrent transactions might “see” different numbers of rows at the same time. Consequently, SELECT COUNT(*) statements only count rows visible to the current transaction. Prior to MySQL 5.7.18, InnoDB processes SELECT COUNT(*) statements by scanning the clustered index. As of MySQL 5.7.18, InnoDB processes SELECT COUNT(*) statements by traversing the smallest available secondary index unless an index or optimizer hint directs the optimizer to use a different index. If a secondary index is not present, the clustered index is scanned. Processing SELECT COUNT(*) statements takes some time if index records are not entirely in the buffer pool. For a faster count, create a counter table and let your application update it according to the inserts and deletes it does. However, this method may not scale well in situations where thousands of concurrent transactions are initiating updates to the same counter table. If an approximate row count is sufficient, use SHOW TABLE STATUS. InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference. For MyISAM tables, COUNT(*) is optimized to return very quickly if the SELECT retrieves from one table, no other columns are retrieved, and there is no WHERE clause. For example: 1&gt;mysql&gt; SELECT COUNT(*) FROM student; This optimization only applies to MyISAM tables, because an exact row count is stored for this storage engine and can be accessed very quickly.COUNT(1) is only subject to the same optimization if the first column is defined as NOT NULL. 官方这段描述要点如下： InnoDB是事务引擎，支持MVCC，并发事务可能同时“看到”不同的行数，所以，InnoDB不保留表中的行数，SELECT COUNT(*)语句只计算当前事务可见的行数。 在MySQL 5.7.18之前，InnoDB通过扫描聚集索引处理SELECT COUNT(*)语句。从MySQL 5.7.18开始，InnoDB通过遍历最小的可用二级索引来处理SELECT COUNT(*)语句，除非索引或优化器明确指示使用不同的索引。如果不存在二级索引，则扫描聚集索引。这样的设计单从 IO 的角度就节省了很多开销。 InnoDB以同样的方式处理SELECT COUNT(*)和SELECT COUNT(1)操作，没有性能差异。 因此，建议使用符合SQL标准的count(*)。 对于MyISAM表，由于MyISAM引擎存储了精确的行数，因此，如果SELECT COUNT(*)语句不包含WHERE子句，则会很快返回。这个很好理解，如果带了where条件，就需要扫表了。 如果索引记录不完全在缓冲池中，则处理SELECT(*)语句需要一些时间。为了更快的计数，您可以创建一个计数器表，并让您的应用程序按插入和删除操作更新它。然而，这种方法在同一计数器表中启动成千上万个并发事务的情况下，可能无法很好地扩展。如果一个近似的行数足够，可以使用SHOW TABLE STATUS查询行数。 到这里我们明白了 count(*) 和 count(1) 本质上面其实是一样的，那么 count(column) 又是怎么回事呢？ count(column) 也是会遍历整张表，但是不同的是它会拿到 column 的值以后判断是否为空，然后再进行累加，那么如果针对主键需要解析内容，如果是二级索引需要再次根据主键获取内容，则要多一次 IO 操作，所以 count(column) 的性能肯定不如前两者，如果按照效率比较的话：*count()=count(1)&gt;count(primary key)&gt;count(非主键column)**。 四、建议基于以上描述，如果要查询innodb存储引擎的表的总行数，有如下建议： 若仅仅是想获取大概的行数，建议使用show table status或查询information_schema.tables：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667mysql&gt; use db6;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; show tables;+---------------+| Tables_in_db6 |+---------------+| t1 |+---------------+1 row in set (0.01 sec)mysql&gt; select count(*) from t1;+----------+| count(*) |+----------+| 2 |+----------+1 row in set (0.00 sec)mysql&gt; show table status\\G*************************** 1. row *************************** Name: t1 Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 2 Avg_row_length: 8192 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: NULL Create_time: 2020-04-21 12:00:44 Update_time: NULL Check_time: NULL Collation: utf8mb4_general_ci Checksum: NULL Create_options: Comment:1 row in set (0.00 sec)mysql&gt; select * from information_schema.tables where table_name = &#x27;t1&#x27;\\G*************************** 1. row *************************** TABLE_CATALOG: def TABLE_SCHEMA: db6 TABLE_NAME: t1 TABLE_TYPE: BASE TABLE ENGINE: InnoDB VERSION: 10 ROW_FORMAT: Dynamic TABLE_ROWS: 2 AVG_ROW_LENGTH: 8192 DATA_LENGTH: 16384MAX_DATA_LENGTH: 0 INDEX_LENGTH: 0 DATA_FREE: 0 AUTO_INCREMENT: NULL CREATE_TIME: 2020-04-21 12:00:44 UPDATE_TIME: NULL CHECK_TIME: NULLTABLE_COLLATION: utf8mb4_general_ci CHECKSUM: NULL CREATE_OPTIONS: TABLE_COMMENT:1 row in set (0.00 sec) 反之，如果必须要获取准确的总行数，建议： 创建一个计数器表，并让您的应用程序按插入和删除操作更新它。 若业务插入和删除相对较少，也可以考虑缓存到 redis。 篇幅有限，深入验证、源码分析将在下一篇文章中介绍。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://dbkernel.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://dbkernel.github.io/tags/MySQL/"},{"name":"Select","slug":"Select","permalink":"http://dbkernel.github.io/tags/Select/"},{"name":"Count","slug":"Count","permalink":"http://dbkernel.github.io/tags/Count/"}]},{"title":"MySQL-自增列详解（1）：自增列概念及使用","slug":"MySQL-自增列详解（1）：自增列概念及使用","date":"2019-12-09T03:37:10.000Z","updated":"2021-07-10T10:31:47.602Z","comments":true,"path":"2019/12/09/MySQL-自增列详解（1）：自增列概念及使用/","link":"","permalink":"http://dbkernel.github.io/2019/12/09/MySQL-%E8%87%AA%E5%A2%9E%E5%88%97%E8%AF%A6%E8%A7%A3%EF%BC%881%EF%BC%89%EF%BC%9A%E8%87%AA%E5%A2%9E%E5%88%97%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1. 概念自增列，即 AUTO_INCREMENT，可用于为新的记录生成唯一标识。 要求： AUTO_INCREMENT 是数据列的一种属性，只适用于整数类型数据列。 AUTO_INCREMENT 数据列必须具备 NOT NULL 属性。 2. 使用方法2.1. 创建含自增列的表1234567-- 不指定 AUTO_INCREMENT 的值，则从1开始mysql&gt; create table t1(a int auto_increment primary key,b int);Query OK, 0 rows affected (0.01 sec)-- 手动指定 AUTO_INCREMENT 的值mysql&gt; create table t2(a int auto_increment primary key,b int) AUTO_INCREMENT=100;Query OK, 0 rows affected (0.02 sec) 2.2. 插入数据12345678910111213141516-- 不指定自增列mysql&gt; insert into t1(b) values(1),(2);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1;+---+------+| a | b |+---+------+| 1 | 1 || 2 | 2 |+---+------+3 rows in set (0.00 sec)-- 指定自增列mysql&gt; insert into t1(a,b) values(3,3);Query OK, 1 row affected (0.00 sec) 2.3. 如何查看表的 AUTO_INCREMENT 涨到了多少？1234567891011mysql&gt; show create table t1;+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t1 | CREATE TABLE `t1` ( `a` int(11) NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, PRIMARY KEY (`a`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 |+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 2.4. 插入数据时能否有空洞？可以的，但要注意 AUTO_INCREMENT 的值一定比自增列当前最大的记录值大。 1234567891011121314151617181920212223242526-- 创造空洞mysql&gt; insert into t1(a,b) values(5,5);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1;+---+------+| a | b |+---+------+| 1 | 1 || 2 | 2 || 3 | 3 || 5 | 5 |+---+------+5 rows in set (0.00 sec)mysql&gt; show create table t1;+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t1 | CREATE TABLE `t1` ( `a` int(11) NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, PRIMARY KEY (`a`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 |+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 2.5. 能否插入重复记录既然自增列是唯一记录，那么肯定不能插入重复记录。 123-- 尝试插入重复记录mysql&gt; insert into t1(a,b) values(5,5);ERROR 1062 (23000): Duplicate entry &#x27;5&#x27; for key &#x27;PRIMARY&#x27; 2.6. 怎么修改 AUTO_INCREMENT 的值？注意：AUTO_INCREMENT 不能小于当前自增列记录的最大值。 12345678910111213141516171819202122232425262728293031323334-- 尝试将 AUTO_INCREMENT 设为10mysql&gt; alter table t1 AUTO_INCREMENT=10;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show create table t1;+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t1 | CREATE TABLE `t1` ( `a` int(11) NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, PRIMARY KEY (`a`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 |+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)-- 尝试将 AUTO_INCREMENT 设为4mysql&gt; alter table t1 AUTO_INCREMENT=4;Query OK, 0 rows affected (0.00 sec)Records: 0 Duplicates: 0 Warnings: 0-- 由于自增列最大记录值是5，那么 AUTO_INCREMENT 不能小于5，因此该值为6mysql&gt; show create table t1;+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t1 | CREATE TABLE `t1` ( `a` int(11) NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, PRIMARY KEY (`a`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 |+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 3. 问题3.1. 自增列是否有上限？由上文可见，自增列会一直增加，那是否有上限呢？ 上文中表 t1 的自增列是 int 类型，由下表（MySQL 5.7）可见取值范围是 -2147483648 到 2147483647（ -231 ~ 231 - 1 ）。 Type Storage (Bytes) Minimum Value Signed Minimum Value Unsigned Maximum Value Signed Maximum Value Unsigned TINYINT 1 -128 0 127 255 SMALLINT 2 -32768 0 32767 65535 MEDIUMINT 3 -8388608 0 8388607 16777215 INT 4 -2147483648 0 2147483647 4294967295 BIGINT 8 -263 0 263-1 264-1 验证如下： 12345678910111213141516171819202122232425262728mysql&gt; show create table t1;+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t1 | CREATE TABLE `t1` ( `a` int(11) NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, PRIMARY KEY (`a`)) ENGINE=InnoDB AUTO_INCREMENT=2147483644 DEFAULT CHARSET=utf8 |+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.01 sec)mysql&gt; insert into t1(b) values(0),(0),(0);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into t1(b) values(0);ERROR 1062 (23000): Duplicate entry &#x27;2147483647&#x27; for key &#x27;PRIMARY&#x27;mysql&gt; show create table t1;+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t1 | CREATE TABLE `t1` ( `a` int(11) NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, PRIMARY KEY (`a`)) ENGINE=InnoDB AUTO_INCREMENT=2147483647 DEFAULT CHARSET=utf8 |+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 这里需要补充说明下 int(11) 中的数字的含义： MySQL中整数数据类型后面的(N)指定显示宽度。显示宽度不影响查询出来的结果。显示宽度限制了小数点的位置(只要实际数字不超过显示宽度，这种情况下，数字显示为原样)。显示宽度也是一个有用的工具，可以让开发人员知道应该将值填充到哪个长度。 3.2. 如何避免自增列超过最大值？可以采用无符号的 BIGINT 类型（也可根据业务产生自增列的速度采用合适的类型），能极大提升自增列的范围。 1234567891011121314151617181920212223242526272829303132mysql&gt; create table t2(a bigint unsigned primary key auto_increment,b int);Query OK, 0 rows affected (0.00 sec)mysql&gt; alter table t2 auto_increment=18446744073709551613;Query OK, 0 rows affected (0.00 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show create table t2;+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t2 | CREATE TABLE `t2` ( `a` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, PRIMARY KEY (`a`)) ENGINE=InnoDB AUTO_INCREMENT=18446744073709551613 DEFAULT CHARSET=utf8 |+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.01 sec)mysql&gt; insert into t2(b) values(0);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into t2(b) values(0);ERROR 1467 (HY000): Failed to read auto-increment value from storage enginemysql&gt;mysql&gt; select * from t2;+----------------------+------+| a | b |+----------------------+------+| 18446744073709551613 | 0 |+----------------------+------+1 row in set (0.00 sec) UNSIGNED BIGINT 类型的范围究竟有多大呢？ 假如每秒自增100万次，想要消耗完需要 18446744073709551613/1000000/3600/24/365=584942年。 有的朋友会问如果自增列不是采用BIGINT类型，那么达到最大值后该表就无法写入，此时该怎么办呢？ 一般达到最大值后再次插入数据会报错ERROR 1467 (HY000): Failed to read auto-increment value from storage engine，可以通过alter table 将自增列的类型设为数值范围更大的类型（比如BIGINT）。 4. 总结 AUTO_INCREMENT 列必定唯一，且仅用于整型类型。 AUTO_INCREMENT 列会持续增长，不会因 delete 自增列最大的记录而变小。 当 AUTO_INCREMENT 列达到当前类型的最大值后将无法插入数据，会报错ERROR 1467 (HY000): Failed to read auto-increment value from storage engine，此时将自增列改为 BIGINT 类型可解决问题。 为了避免自增列达到最大值，可将其设为BIGINT类型。 使用 alter table 修改 AUTO_INCREMENT 列时，其值会取自增列当前最大记录值+1与将要设置的值的最大值。 在MySQL 5.7 中，将列设置成 AUTO_INCREMENT 之后，必须将其设置成主键/或者是主键的一部分，否则会报错ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://dbkernel.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://dbkernel.github.io/tags/MySQL/"},{"name":"auto_increment","slug":"auto-increment","permalink":"http://dbkernel.github.io/tags/auto-increment/"}]}],"categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://dbkernel.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://dbkernel.github.io/tags/MySQL/"},{"name":"Select","slug":"Select","permalink":"http://dbkernel.github.io/tags/Select/"},{"name":"Count","slug":"Count","permalink":"http://dbkernel.github.io/tags/Count/"},{"name":"auto_increment","slug":"auto-increment","permalink":"http://dbkernel.github.io/tags/auto-increment/"}]}