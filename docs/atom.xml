<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DBKernel</title>
  
  
  <link href="http://dbkernel.github.io/atom.xml" rel="self"/>
  
  <link href="http://dbkernel.github.io/"/>
  <updated>2021-09-24T04:07:20.435Z</updated>
  <id>http://dbkernel.github.io/</id>
  
  <author>
    <name>DBKernel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术分享 | 如何为你的代码选择一个合适的开源协议？</title>
    <link href="http://dbkernel.github.io/2021/08/19/how-to-choose-open-source-licence/"/>
    <id>http://dbkernel.github.io/2021/08/19/how-to-choose-open-source-licence/</id>
    <published>2021-08-18T16:37:15.000Z</published>
    <updated>2021-09-24T04:07:20.435Z</updated>
    
    <content type="html"><![CDATA[<p>近期公司全面拥抱开源，在选择开源协议方面遇到了一些问题，查阅了很多资料，特此总结~~</p><span id="more"></span><blockquote><p><strong>本文首发于 2021-08-19 00:37:15</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于很多刚踏入开源软件这个行业的小伙伴来说，在编码过程中难免会用到其他人的成果，如果你足够细心，很容易注意到即使是一小段代码，优秀的作者都在文件开头附上一段关于版权的声明，比如 <code>Licensed under the MIT license</code>。同时，一些博客也会标明”此文章采用 <code>CC BY 4.0 CN</code> 协议“。</p><p>如果我们拷贝了别人的代码或文章却没注意版权问题，在国外法律意识特别强的环境下（国内版权意识也在逐步加强），那么我们的作品会因触犯别人的权益而违法。即使是最开放的开源协议，最低要求也是保留原作者对代码的声明，所以<code>开源不等于免费，也不等于没有约束</code>。</p><p><strong>何为 LICENCE？</strong></p><blockquote><p>LICENCE 是软件的授权许可，详细说明了获得代码后拥有的权利，哪些操作是允许的，哪些操作是禁止的。软件的版权许可证可有很多方式，本文仅限于讨论开源软件协议 Open Source License。</p></blockquote><p>对于大多数人来说，没必要花大把时间去写许可协议，选择一种比较流行的开源协议就足够了，省时省力，更便于自己作品的传播，于人于己都有利。</p><p><strong>PS：</strong></p><blockquote><p>说句题外话，很多国外开发者在尊重他人劳动成果方面做得很好，如果A的作品是因为B的作品的启发而来，A甚至都没有使用B任何一句代码，但A会在他的作品里面指明是受到了B的启发：<code>Inspired by XXX link: http://www.xxxx.com</code>。</p></blockquote><h2 id="快速选择开源协议"><a href="#快速选择开源协议" class="headerlink" title="快速选择开源协议"></a>快速选择开源协议</h2><p>如果你不想了解太多，只是想要一个简直直接的答案，下面给出的建议或许适合你。本小节关于协议地址来自于 GitHub <a href="http://choosealicense.com/">choosealicence</a> 。</p><p><strong>简单宽松的协议：</strong></p><blockquote><p>如果你只想要一个简单点的协议不想太麻烦的话。</p><p><a href="http://choosealicense.com/licenses/mit">MIT协议</a>相对宽松，此协议允许别人以任何方式使用你的代码同时署名原作者，但原作者不承担代码使用后的风险，当然也没有技术支持的义务。</p></blockquote><p><strong>考虑有专利的情况：</strong></p><blockquote><p>如果你的作品中涉及到专利相关。</p><p><a href="http://choosealicense.com/licenses/apache/">Apache协议</a>也是个相对宽松的协议，与MIT类似，但它指明了作者对用户专利上的一些授权（我的理解是软件作品中含有专利，但它授权你可以免费使用）。</p></blockquote><p><strong>促进代码分享：</strong></p><blockquote><p>如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。</p><p>GPL（<a href="http://choosealicense.com/licenses/gpl-v2">V2</a>或<a href="http://choosealicense.com/licenses/gpl-v3">V3</a>）协议要求代码分发者或者以此代码为基础开发出来的衍生作品需要以同样的协议来发布，也必须开源，因此，该协议具有”传染性“。</p></blockquote><p>乌克兰程序员<a href="http://pbagwl.com/post/5078147450/description-of-popular-software-licenses">Paul Bagwell</a>，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种开源协议之间的最大区别。<br><img src="paul-bagwell-licence.jpeg" alt="Paul Bagwell的LICENCE分析图"></p><p>国内大神阮一峰的汉化版本：<br><img src="ruan-yi-feng-licence.jpeg" alt="阮一峰的LICENCE分析图"></p><h2 id="主流开源许可协议（Open-Source-License）"><a href="#主流开源许可协议（Open-Source-License）" class="headerlink" title="主流开源许可协议（Open Source License）"></a>主流开源许可协议（Open Source License）</h2><p>世界上的开源许可协议（Open Source License）大概有<a href="https://www.gnu.org/licenses/license-list.html">上百种</a>，常用的开源软件协议大致有：</p><ul><li><a href="https://www.gnu.org/licenses/gpl-3.0.html">GPL</a></li><li><a href="https://www.gnu.org/licenses/lgpl-3.0.html">LGPL</a></li><li><a href="https://opensource.org/licenses/BSD-3-Clause">BSD</a></li><li><a href="https://opensource.org/licenses/mit-license.php">MIT</a></li><li><a href="https://opensource.org/licenses/MPL-2.0">Mozilla</a></li><li><a href="http://www.apache.org/licenses/LICENSE-2.0">Apache</a></li></ul><p>由宽松到严紧排序，常用的开源协议有：</p><ol><li>MIT</li><li>BSD</li><li>Apache</li><li>LGPL</li><li>GPL</li></ol><p>主要区别：</p><ul><li>MIT、BSD 开源协议都源自大学，体现了简单、开放和包容的特点。</li><li>MIT、BSD、Apache 三者都支持闭源的后续开发。</li><li>GPL、LGPL 传染性开源，编译的代码里用了这里的代码，都必须开源。</li></ul><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>来源于大学，MIT 开源协议是史上最为简洁、慷慨的开源协议之一。作者只想保留版权，而无任何其他了限制。也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。</p><p><strong>特点：</strong></p><ul><li>用户可以拿你的代码做任何想做的事情。</li><li>用户在项目副本中要包含版权声明和许可声明。</li><li>你无需承担任何责任。</li></ul><p><strong>代表作品：</strong></p><ul><li><a href="https://github.com/jquery/jquery">jQuery</a></li><li><a href="https://github.com/rails/rails">Rails</a> 等。</li></ul><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><ul><li><a href="https://opensource.org/licenses/BSD-2-Clause">BSD-2-Clause</a></li><li><a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a></li></ul><p>BSD可证也来源于大学，与MIT差不多，也非常简单、慷慨。</p><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用、修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。前提是当你发布使用了BSD协议的代码，或者以BSD协议代码为基础开发自己的产品时，需要满足三个条件：</p><ol><li>如果再发布的产品中包含源代码，则在源代码中必须带有原代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ol><p>BSD 开源协议鼓励代码共享，但需要尊重代码作者的著作权。BSD 开源协议允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布、销售，是对商业集成很友好的协议。因此，很多公司在选用开源产品的时候都首选BSD协议。</p><h3 id="Apache-Licence"><a href="#Apache-Licence" class="headerlink" title="Apache Licence"></a>Apache Licence</h3><ul><li><a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a></li><li><a href="https://www.apache.org/licenses/LICENSE-1.1">Apache License, Version 1.1</a></li><li><a href="https://www.apache.org/licenses/LICENSE-1.0">Apache License, Version 1.0</a></li></ul><p>来自 Apache，类似 MIT 开源协议，但它重视专利权。</p><p>Apache Licence 是著名的非盈利开源组织 Apache 采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许修改代码、再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p><ol><li>需要为使用代码的用户提供一份 Apache Licence 。</li><li>如果你修改了代码，需要在被修改的文件中说明。</li><li>在延伸的代码中（修改和由源代码衍生的代码中）需要带有原来代码中的协议、商标、专利声明和其他原作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个<code>Notice</code>文件，则在Notice文件中需要带有 Apache Licence 。你可以在<code>Notice</code>中增加自己的许可，但不可对 Apache Licence 构成更改。</li></ol><p>Apache Licence 也是对商业应用友好的许可，使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p><p><strong>代表作品：</strong></p><ul><li><a href="https://github.com/apache/echarts">echarts</a></li><li><a href="https://github.com/apache/superset">superset</a></li><li><a href="https://github.com/apache/dubbo">dubbo</a></li><li><a href="https://github.com/apache/spark">spark</a></li></ul><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>LGPL（GNU LESSER GENERAL PUBLIC LICENSE）来自于自由软件联盟GNU，可以翻译为更宽松的GPL协议，也属于传染性开源协议。</p><p>LGPL是GPL的一个主要为类库使用设计的开源协议。和<code>GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议</code>不同，LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议，因此，LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL（GNU GENERAL PUBLIC LICENSE）来源于自由软件联盟GNU，GPL/LGPL侧重于代码及衍生代码的开源与免费使用。</p><p>GPL协议的主要内容是只要在一个软件中使用（”使用”指类库引用，修改后的代码或者衍生代码）GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。<strong>这就是所谓的”传染性”</strong>。</p><p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p><p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是<code>代码的开源/免费使用/引用/修改</code>和<code>衍生代码的开源/免费使用</code>，但<code>不允许</code>修改后和衍生的代码做为<code>闭源</code>的商业软件发布和销售。</p><p>其它细节和BSD/Apache等协议类似。</p><p><strong>代表作品：</strong></p><ul><li><a href="https://github.com/torvalds/linux">Linux</a></li></ul><h2 id="更多开源协议对比"><a href="#更多开源协议对比" class="headerlink" title="更多开源协议对比"></a>更多开源协议对比</h2><p>下方表格中出现的用词的解释：</p><ul><li><strong>协议和版权信息</strong>(License and copyright notice)：在代码中保留作者提供的协议和版权信息。</li><li><strong>声明变更</strong>(State Changes)：在代码中声明对原来代码的重大修改及变更。</li><li><strong>公开源码</strong>(Disclose Source)：代码必需公开。</li><li><strong>库引用</strong>(Library usage)：该库可以用于商业软件中。</li><li><strong>责任承担</strong>(Hold Liable)：代码的作者承担代码使用后的风险及产生的后果。如果禁止，那么作者将不会承担责任，可以理解为免责条款。</li><li><strong>商标使用</strong>(Use Trademark)：可以使用作者的姓名，作品的Logo，或商标。</li><li><strong>附加协议</strong>(Sublicensing)：允许在软件分发传播过程中附加上原来没有的协议条款等。</li></ul><table><thead><tr><th>协议</th><th>描述</th><th>要求</th><th>允许</th><th>禁止</th></tr></thead><tbody><tr><td><a href="http://choosealicense.com/licenses/apache/">Apache</a></td><td>一个比较宽松且简明地指出了专利授权的协议。</td><td>1. <font color=#0000FF>协议和版权信息</font><br/>2. <font color=#0000FF>声明变更</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font><br/>6. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font>（作者免责）<br/>2. <font color=#FF3030>商标使用</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/gpl-v2/">GPL</a></td><td>应用最广泛的开源协议，拥有较强的版权自由（copyleft）要求。<br/>衍生代码的分发需开源并且也要遵守此协议。<br/>此协议有许多变种，不同变种的要求略有不同。</td><td>1. <font color=#0000FF>公开源码</font><br/>2. <font color=#0000FF>协议和版权信息</font><br/>3. <font color=#0000FF>声明变更</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font></td><td>1. <font color=#FF3030>责任承担</font><br/>2. <font color=#FF3030>附加协议</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/mit/">MIT</a></td><td>此协议宽松简单。在适当标明来源及免责的情况下，<br/>它允许你对代码进行任何形式的使用。</td><td>1. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>私用</font><br/>5. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/artistic/">Artistic</a></td><td>Perl社区最钟爱此协议。<br/>要求更改后的软件不能影响原软件的使用。</td><td>1. <font color=#0000FF>协议和版权信息</font><br/>2. <font color=#0000FF>声明变更</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>私用</font><br/>5. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font><br/>2. <font color=#FF3030>商标使用</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/bsd/">BSD</a></td><td>较为宽松的协议，有两个变种<a href="http://choosealicense.com/licenses/bsd"><strong>BSD 2-Clause</strong></a> 和<a href="http://choosealicense.com/licenses/bsd-3-clause"><strong>BSD 3-Clause</strong></a>，<br/>两者都与MIT协议只存在细微差异。</td><td>1. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>私用</font><br/>5. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/eclipse/">Eclipse</a></td><td>对商用非常友好的协议，可以用于软件的商业授权。<br/>包含对专利的优雅授权，也可以对相关代码应用商业协议。</td><td>1. <font color=#0000FF>公开源码</font><br/>2. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font><br/>6. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/lgpl-v2.1/">LGPL</a></td><td>主要用于一些代码库。<br/>衍生代码可以以此协议发布（也可以用其他协议），<br/>但与此协议相关的代码必需遵循此协议。</td><td>1. <font color=#0000FF>公开源码</font><br/>2. <font color=#0000FF>库引用</font><br/>3. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font><br/>6. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/mozilla/">Mozilla</a></td><td>Mozilla Public License(MPL 2.0)是由Mozilla基金创建维护的，<br/>旨在较为宽松的BSD协议和更加互惠的GPL协议中找一个折衷点。</td><td>1. <font color=#0000FF>公开源码</font><br/>2. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font><br/>6. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font><br/>2. <font color=#FF3030>商标使用</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/no-license/">No license</a></td><td>作者保留所有权利，不允许他人分发，复制或者创造衍生物。<br/>当你将代码发表在一些网站上时需要遵守该网站的协议，<br/>此协议可能包含了一些对你劳动成果的授权许可。<br/>比如将代码发布到GitHub，那么就必须同意别人查看和fork。</td><td>1. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>私用</font></td><td>1. <font color=#FF3030>分发</font><br/>2. <font color=#FF3030>修改</font><br/>3. <font color=#FF3030>附加协议</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/unlicense/">Public domain dedication</a></td><td>在许多国家，默认版权归作者自动拥有，<br/>所以<a href="http://unlicense.org/">Unlicense</a>协议提供了一种通用的模板。<br/>此协议表明作者放弃版权，将劳动成果无私贡献出来，<br/>会丧失作品全部权利，包括在MIT/X11中定义的无担保权利。</td><td>1. <font color=#0000FF>N/A</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>私用</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/github/choosealicense.com">https://github.com/github/choosealicense.com</a></li><li><a href="https://opensource.org/licenses">https://opensource.org/licenses</a></li><li><a href="https://www.cnblogs.com/Wayou/p/how_to_choose_a_license.html">https://www.cnblogs.com/Wayou/p/how_to_choose_a_license.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/87855729">https://zhuanlan.zhihu.com/p/87855729</a></li></ul><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期公司全面拥抱开源，在选择开源协议方面遇到了一些问题，查阅了很多资料，特此总结~~&lt;/p&gt;</summary>
    
    
    
    <category term="通用" scheme="http://dbkernel.github.io/categories/%E9%80%9A%E7%94%A8/"/>
    
    
    <category term="开源协议" scheme="http://dbkernel.github.io/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="开源许可证" scheme="http://dbkernel.github.io/tags/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/"/>
    
    <category term="LICENCE" scheme="http://dbkernel.github.io/tags/LICENCE/"/>
    
    <category term="github" scheme="http://dbkernel.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>问题定位 | Peronca Xtrabackup 8.0近日踩坑总结 - xtrabackup 2.4和8.0区别</title>
    <link href="http://dbkernel.github.io/2020/08/27/percona-xtrabackup-2.4-vs-8.0/"/>
    <id>http://dbkernel.github.io/2020/08/27/percona-xtrabackup-2.4-vs-8.0/</id>
    <published>2020-08-27T05:46:15.000Z</published>
    <updated>2021-09-24T04:11:55.890Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2020-08-27 13:46:15</strong></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近期在给 <code>radondb/xenon</code> 适配 percona xtrabackup 8.0时，遇到了一些问题，经过多日调研、尝试终于解决，特此分享。</p><p><strong>版本信息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Percona-Server 8.0.19-10</span><br><span class="line">Percona-Xtrabackup 8.0.13</span><br></pre></td></tr></table></figure><p>版本各字段含义参考 <a href="https://www.percona.com/blog/2020/08/18/aligning-percona-xtrabackup-versions-with-percona-server-for-mysql/">https://www.percona.com/blog/2020/08/18/aligning-percona-xtrabackup-versions-with-percona-server-for-mysql/</a></p><h3 id="适配过程中遇到的坑"><a href="#适配过程中遇到的坑" class="headerlink" title="适配过程中遇到的坑"></a>适配过程中遇到的坑</h3><p>一、MySQL 8.0 + Semi-Sync + 持续写入数据期间执行重建后，change master to &amp;&amp; start slave 报错：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last_Error: Could <span class="keyword">not</span> execute Write_rows <span class="keyword">event</span> on <span class="keyword">table</span> db1<span class="variable">.t1</span>; Duplicate entry &#x27;<span class="number">28646</span>&#x27; <span class="keyword">for</span> key &#x27;t1<span class="variable">.PRIMARY</span>&#x27;, Error_code: <span class="number">1062</span>; handler error HA_ERR_FOUND_DUPP_KEY; the <span class="keyword">event</span>&#x27;s master log mysql-bin<span class="variable">.000052</span>, end_log_pos <span class="number">437</span></span><br></pre></td></tr></table></figure><p>二、MySQL 8.0 + Group Replication + 持续写入数据期间执行重建后，change master to &amp;&amp; start group_replication 报错：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">21</span>T14:<span class="number">51</span>:<span class="number">09</span><span class="variable">.977606</span>+<span class="number">08</span>:<span class="number">00</span> <span class="number">61</span> [System] [MY-<span class="number">010597</span>] [Repl] &#x27;CHANGE MASTER TO FOR CHANNEL &#x27;group_replication_applier&#x27; executed&#x27;. Previous state master_host=&#x27;&lt;NULL&gt;&#x27;, master_port= <span class="number">0</span>, master_log_file=&#x27;&#x27;, master_log_pos= <span class="number">4</span>, master_bind=&#x27;&#x27;. New state master_host=&#x27;&lt;NULL&gt;&#x27;, master_port= <span class="number">0</span>, master_log_file=&#x27;&#x27;, master_log_pos= <span class="number">4</span>, master_bind=&#x27;&#x27;.</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">21</span>T14:<span class="number">51</span>:<span class="number">09</span><span class="variable">.987494</span>+<span class="number">08</span>:<span class="number">00</span> <span class="number">61</span> [ERROR] [MY-<span class="number">013124</span>] [Repl] Slave SQL <span class="keyword">for</span> channel &#x27;group_replication_applier&#x27;: Slave failed to initialize relay log info structure from the repository, Error_code: MY-<span class="number">013124</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">21</span>T14:<span class="number">51</span>:<span class="number">09</span><span class="variable">.987542</span>+<span class="number">08</span>:<span class="number">00</span> <span class="number">61</span> [ERROR] [MY-<span class="number">011534</span>] [Repl] Plugin group_replication reported: &#x27;Error <span class="keyword">while</span> starting the group replication applier thread&#x27;</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">21</span>T14:<span class="number">51</span>:<span class="number">09</span><span class="variable">.987651</span>+<span class="number">08</span>:<span class="number">00</span> <span class="number">7</span> [ERROR] [MY-<span class="number">011669</span>] [Repl] Plugin group_replication reported: &#x27;Unable to initialize the Group Replication applier <span class="keyword">module</span>.&#x27;</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">21</span>T14:<span class="number">51</span>:<span class="number">09</span><span class="variable">.987831</span>+<span class="number">08</span>:<span class="number">00</span> <span class="number">7</span> [ERROR] [MY-<span class="number">011735</span>] [Repl] Plugin group_replication reported: &#x27;[GCS] The member is leaving a group without being on one.&#x27;</span><br></pre></td></tr></table></figure><p>要解释这个问题，首先要弄清楚xtrabackup 2.4和8.0的区别。</p><h3 id="xtrabackup-2-4和8-0区别"><a href="#xtrabackup-2-4和8-0区别" class="headerlink" title="xtrabackup 2.4和8.0区别"></a>xtrabackup 2.4和8.0区别</h3><p><strong>google查到xtrabackup 8.0与2.4版本行为有所不同：</strong></p><blockquote><ol><li>Xtrabackup 2.4 备份后生成的 <code>xtrabackup_binlog_info</code> 文件记录的 GTID 信息是准确的，但是备份恢复后 <code>show master status</code> 显示的 GTID 是不准确的。</li><li>Xtrabackup 8.0 在备份只有 InnoDB 表的实例时，<code>xtrabackup_binlog_info</code> 文件记录的 GTID 信息不一定是准确的，但是备份恢复后 <code>show master status</code> 显示的 GTID 是准确的。</li><li>Xtrabackup 8.0 在备份有非 InnoDB 表格的实例时，<code>xtrabackup_binlog_info</code> 文件记录的 GTID 信息是准确的，备份恢复后 <code>show master status</code> 显示的 GTID 也是准确的。</li></ol></blockquote><p><strong>之前研究过 xtrabackup 2.4 ，其过程大致如下：</strong></p><blockquote><ol><li>start backup</li><li>copy ibdata1 / copy .ibd file</li><li>excuted FTWRL</li><li>backup non-InnoDB tables and files</li><li>writing xtrabackup_binlog_info</li><li>executed FLUSH NO_WRITE_TO_BINLOG ENGINE LOGS</li><li>executed UNLOCK TABLES</li><li>copying ib_buffer_pool</li><li>completed OK!</li></ol></blockquote><p><strong>问题1：xtrabackup 8.0 的执行过程是什么样？</strong></p><p>首先，查看重建期间的<code>general log</code>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.136376</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySET SESSION wait_timeout=<span class="number">2147483</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.136439</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySET SESSION autocommit=<span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.136523</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySET NAMES utf8</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.136595</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySHOW VARIABLES</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.138840</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySELECT COUNT(*) FROM information_schema<span class="variable">.tables</span> WHERE engine = &#x27;MyISAM&#x27; OR engine = &#x27;RocksDB&#x27;</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.140203</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySHOW ENGINES</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.140407</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySHOW ENGINE INNODB STATUS</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.141570</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySELECT PLUGIN_NAME, PLUGIN_LIBRARY FROM information_schema<span class="variable">.plugins</span> WHERE PLUGIN_STATUS = &#x27;ACTIVE&#x27; AND PLUGIN_TYPE = &#x27;KEYRING&#x27;</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.142140</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySELECT  CONCAT(table_schema, &#x27;/&#x27;, table_name), engine FROM information_schema<span class="variable">.tables</span> WHERE engine NOT IN (&#x27;MyISAM&#x27;, &#x27;InnoDB&#x27;, &#x27;CSV&#x27;, &#x27;MRG_MYISAM&#x27;, &#x27;ROCKSDB&#x27;) AND table_schema NOT IN (  &#x27;performance_schema&#x27;, &#x27;information_schema&#x27;,   &#x27;mysql&#x27;)</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.209819</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">171</span> QuerySET SESSION wait_timeout=<span class="number">2147483</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.209879</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">171</span> QuerySET SESSION autocommit=<span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.209950</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">171</span> QuerySET NAMES utf8</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.210015</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">171</span> QuerySHOW VARIABLES</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">18</span><span class="variable">.214030</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySELECT T2<span class="variable">.PATH</span>,        T2<span class="variable">.NAME</span>,        T1<span class="variable">.SPACE_TYPE</span> FROM   INFORMATION_SCHEMA<span class="variable">.INNODB_TABLESPACES</span> T1        JOIN INFORMATION_SCHEMA<span class="variable">.INNODB_TABLESPACES_BRIEF</span> T2 USING (SPACE) WHERE  T1<span class="variable">.SPACE_TYPE</span> = &#x27;Single&#x27; &amp;&amp; T1<span class="variable">.ROW_FORMAT</span> != &#x27;Undo&#x27;UNION SELECT T2<span class="variable">.PATH</span>,        SUBSTRING_INDEX(SUBSTRING_INDEX(T2<span class="variable">.PATH</span>, &#x27;/&#x27;, -<span class="number">1</span>), &#x27;.&#x27;, <span class="number">1</span>) NAME,        T1<span class="variable">.SPACE_TYPE</span> FROM   INFORMATION_SCHEMA <span class="variable">.INNODB_TABLESPACES</span> T1        JOIN INFORMATION_SCHEMA <span class="variable">.INNODB_TABLESPACES_BRIEF</span> T2 USING (SPACE) WHERE  T1<span class="variable">.SPACE_TYPE</span> = &#x27;General&#x27; &amp;&amp; T1<span class="variable">.ROW_FORMAT</span> != &#x27;Undo&#x27;</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">19</span><span class="variable">.533904</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QueryFLUSH NO_WRITE_TO_BINLOG BINARY LOGS</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">19</span><span class="variable">.543095</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySELECT server_uuid, <span class="keyword">local</span>, replication, storage_engines FROM performance_schema<span class="variable">.log_status</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">19</span><span class="variable">.543418</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySHOW VARIABLES</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">19</span><span class="variable">.545383</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySHOW VARIABLES</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">19</span><span class="variable">.550641</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QueryFLUSH NO_WRITE_TO_BINLOG ENGINE LOGS</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">20</span><span class="variable">.556885</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySELECT UUID()</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">26</span>T16:<span class="number">20</span>:<span class="number">20</span><span class="variable">.557118</span>+<span class="number">08</span>:<span class="number">00</span>  <span class="number">170</span> QuerySELECT VERSION()</span><br></pre></td></tr></table></figure><p>可见，<strong>xtrabackup 8.0默认情况下大致过程如下：</strong></p><blockquote><ol><li>start backup</li><li>copy .ibd file</li><li>backup non-InnoDB tables and files</li><li>executed FLUSH NO_WRITE_TO_BINLOG BINARY LOGS</li><li>selecting LSN and binary log position from p_s.log_status</li><li>copy last binlog file</li><li>writing /mysql/backup/backup/binlog.index</li><li>writing xtrabackup_binlog_info</li><li>executing FLUSH NO_WRITE_TO_BINLOG ENGINE LOGS</li><li>copy ib_buffer_pool</li><li>completed OK!</li></ol><p><strong>注意：</strong> 当存在非InnoDB表时，xtrabackup 8.0会执行FTWRL。</p></blockquote><p>从上述步骤可知，xtrabackup 8.0与2.4的步骤<strong>主要区别</strong>为：</p><p>当只存在InnoDB引擎的表时，不再执行FTWRL，而是通过 上述第5步（<code>SELECT server_uuid, local, replication, storage_engines FROM performance_schema.log_status</code> ）来获取LSN、binlog position、GTID 。</p><p>手册中对于表 <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-log-status-table.html">log_status</a> 的描述如下：</p><blockquote><p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-log-status-table.html"><code>log_status</code></a> table provides information that enables an online backup tool to copy the required log files without locking those resources for the duration of the copy process.</p><p>When the <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-log-status-table.html"><code>log_status</code></a> table is queried, the server blocks logging and related administrative changes for just long enough to populate the table, then releases the resources. The <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-log-status-table.html"><code>log_status</code></a> table informs the online backup which point it should copy up to in the source’s binary log and <code>gtid_executed</code> record, and the relay log for each replication channel. It also provides relevant information for individual storage engines, such as the last log sequence number (LSN) and the LSN of the last checkpoint taken for the <code>InnoDB</code> storage engine.</p></blockquote><p>从上述手册描述可知，<code>performance_schema.log_status</code>是MySQL 8.0提供给在线备份工具获取复制信息的表格，查询该表时，mysql server将阻止日志的记录和相关的更改来获取足够的时间以填充该表，然后释放资源。</p><p>log_status 表通知在线备份工具当前主库的 binlog 的位点和 gtid_executed 的值以及每个复制通道的 relay log。另外，它还提供了各个存储引擎的相关信息，比如，提供了 InnoDB 引擎使用的最后一个日志序列号（LSN）和最后一个检查点的 LSN。</p><p><code>performance_schema.log_status</code>表定义为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Semi-Sync</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.log_status\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">    SERVER_UUID: <span class="number">6</span>b437e80<span class="operator">-</span>e5d5<span class="number">-11</span>ea<span class="number">-88e3</span><span class="number">-52549922</span>fdbb</span><br><span class="line">          <span class="keyword">LOCAL</span>: &#123;&quot;gtid_executed&quot;: &quot;6b437e80-e5d5-11ea-88e3-52549922fdbb:1-201094&quot;, &quot;binary_log_file&quot;: &quot;mysql-bin.000079&quot;, &quot;binary_log_position&quot;: <span class="number">195</span>&#125;</span><br><span class="line">    REPLICATION: &#123;&quot;channels&quot;: []&#125;</span><br><span class="line">STORAGE_ENGINES: &#123;&quot;InnoDB&quot;: &#123;&quot;LSN&quot;: <span class="number">23711425885</span>, &quot;LSN_checkpoint&quot;: <span class="number">23711425885</span>&#125;&#125;</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Group Replication</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.log_status\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">    SERVER_UUID: <span class="number">7</span>bd32480<span class="operator">-</span>e5d5<span class="number">-11</span>ea<span class="number">-8</span>f8a<span class="number">-525499</span>cfbb7d</span><br><span class="line">          <span class="keyword">LOCAL</span>: &#123;&quot;gtid_executed&quot;: &quot;aaaaaaaa-aaaa-aaaa-aaaa-53ab6ea1210a:1-11&quot;, &quot;binary_log_file&quot;: &quot;mysql-bin.000003&quot;, &quot;binary_log_position&quot;: <span class="number">1274</span>&#125;</span><br><span class="line">    REPLICATION: &#123;&quot;channels&quot;: [&#123;&quot;channel_name&quot;: &quot;group_replication_applier&quot;, &quot;relay_log_file&quot;: &quot;mysql-relay-bin-group_replication_applier.000004&quot;, &quot;relay_log_position&quot;: <span class="number">311</span>, &quot;relay_master_log_file&quot;: &quot;&quot;, &quot;exec_master_log_position&quot;: <span class="number">0</span>&#125;, &#123;&quot;channel_name&quot;: &quot;group_replication_recovery&quot;, &quot;relay_log_file&quot;: &quot;mysql-relay-bin-group_replication_recovery.000003&quot;, &quot;relay_log_position&quot;: <span class="number">151</span>, &quot;relay_master_log_file&quot;: &quot;&quot;, &quot;exec_master_log_position&quot;: <span class="number">0</span>&#125;]&#125;</span><br><span class="line">STORAGE_ENGINES: &#123;&quot;InnoDB&quot;: &#123;&quot;LSN&quot;: <span class="number">20257208</span>, &quot;LSN_checkpoint&quot;: <span class="number">20257208</span>&#125;&#125;</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>问题2：<code>performance_schema.log_status</code>提供的信息是否准确呢？</strong></p><p>当写入压力大时，该表中的binlog position与GTID信息不一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.log_status\G  <span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">    SERVER_UUID: <span class="number">6</span>b437e80<span class="operator">-</span>e5d5<span class="number">-11</span>ea<span class="number">-88e3</span><span class="number">-52549922</span>fdbb</span><br><span class="line">          <span class="keyword">LOCAL</span>: &#123;&quot;gtid_executed&quot;: &quot;6b437e80-e5d5-11ea-88e3-52549922fdbb:1-448709&quot;, &quot;binary_log_file&quot;: &quot;mysql-bin.000087&quot;, &quot;binary_log_position&quot;: <span class="number">341265185</span>&#125;</span><br><span class="line">    REPLICATION: &#123;&quot;channels&quot;: []&#125;</span><br><span class="line">STORAGE_ENGINES: &#123;&quot;InnoDB&quot;: &#123;&quot;LSN&quot;: <span class="number">33797305275</span>, &quot;LSN_checkpoint&quot;: <span class="number">33433316246</span>&#125;&#125;</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.11</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+--------------+------------------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> File             <span class="operator">|</span> Position  <span class="operator">|</span> Binlog_Do_DB <span class="operator">|</span> Binlog_Ignore_DB <span class="operator">|</span> Executed_Gtid_Set                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+--------------+------------------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000087</span> <span class="operator">|</span> <span class="number">343317905</span> <span class="operator">|</span>              <span class="operator">|</span>                  <span class="operator">|</span> <span class="number">6</span>b437e80<span class="operator">-</span>e5d5<span class="number">-11</span>ea<span class="number">-88e3</span><span class="number">-52549922</span>fdbb:<span class="number">1</span><span class="number">-448709</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+--------------+------------------+-----------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><strong>问题3：既然log_status中的binlog position不准确，为什么备份恢复后GTID并没有缺失，数据也没问题？</strong></p><p>原因是xtrabackup 8.0在第4步<code>FLUSH NO_WRITE_TO_BINLOG BINARY LOGS</code>之后，在第6步<code>copy last binlog file</code>，这样备份恢复出的新实例在启动后不仅会读取 <code>gtid_executed</code> 表，还会读取拷贝的那个binlog文件来更新GTID。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlbinlog -vv /data/mysql/mysql-bin<span class="variable">.000096</span></span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/</span>;</span><br><span class="line"><span class="comment">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/</span>;</span><br><span class="line">DELIMITER <span class="comment">/*!*/</span>;</span><br><span class="line"># at <span class="number">4</span></span><br><span class="line">#<span class="number">200827</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">47</span> server id <span class="number">575010000</span>  end_log_pos <span class="number">124</span> CRC32 <span class="number">0</span>xb026e372 Start: binlog v <span class="number">4</span>, server v <span class="number">8</span><span class="variable">.0</span><span class="variable">.19</span>-<span class="number">10</span> created <span class="number">200827</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">47</span></span><br><span class="line"># Warning: <span class="keyword">this</span> binlog is either in <span class="keyword">use</span> <span class="keyword">or</span> was <span class="keyword">not</span> closed properly.</span><br><span class="line">BINLOG &#x27;</span><br><span class="line"><span class="number">9</span>ydHXw/Q9EUieAAAAHwAAAABAAQAOC4wLjE5LTEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAEwANAAgAAAAABAAEAAAAYAAEGggAAAAICAgCAAAACgoKKioAEjQA</span><br><span class="line">CgFy4yaw</span><br><span class="line">&#x27;<span class="comment">/*!*/</span>;</span><br><span class="line"># at <span class="number">124</span></span><br><span class="line">#<span class="number">200827</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">47</span> server id <span class="number">575010000</span>  end_log_pos <span class="number">195</span> CRC32 <span class="number">0</span>xad060415 Previous-GTIDs</span><br><span class="line"># <span class="number">6</span>b437e80-e5d5-<span class="number">11</span>ea-<span class="number">88</span>e3-<span class="number">52549922</span>fdbb:<span class="number">1</span>-<span class="number">465503</span></span><br><span class="line">SET @@SESSION<span class="variable">.GTID_NEXT</span>= &#x27;AUTOMATIC&#x27; <span class="comment">/* added by mysqlbinlog */</span> <span class="comment">/*!*/</span>;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line"><span class="comment">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/</span>;</span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/</span>;</span><br></pre></td></tr></table></figure><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><h4 id="坑一：MySQL-8-0-Semi-Sync-重建问题"><a href="#坑一：MySQL-8-0-Semi-Sync-重建问题" class="headerlink" title="坑一：MySQL 8.0 + Semi-Sync 重建问题"></a>坑一：MySQL 8.0 + Semi-Sync 重建问题</h4><p>xenon原有的重建逻辑是适配于MySQL 5.6、5.7的（重建过程中xenon进程存活），一直无问题：</p><blockquote><ol><li>禁用raft，将xenon状态设为LEARNER ；</li><li>如mysql进程存在，则stop mysql；</li><li>清空MySQL数据目录；</li><li>执行<code>xtrabackup --backup</code>以<code>xbstream</code>方式获取对端数据；</li><li>执行<code>xtrabackup --prepare</code>应用redo log；</li><li>启动mysql；</li><li>执行<code>stop slave; reset slave all</code>；</li><li>执行<code>reset master</code>，以<code>xtrabackup_binlog_info</code>文件中的GTID为准设置<code>gtid_purged</code>；</li><li>启用raft，将xenon状态设为FOLLOWER或IDLE；</li><li>等待xenon自动<code>change master to</code>到主节点。</li><li>执行<code>start slave</code>。</li></ol></blockquote><p><strong>问题1：为什么在 MySQL 8.0 + Semi-Sync 组合下会出现 Duplicate entry ？</strong></p><p>跟踪重建过程中的general log，发现在第6和第7步中间，也就是设置<code>gtid_purged</code>之前凭空多出了 <code>change master to</code> 和 <code>start slave</code> 操作：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">22</span><span class="variable">.817859</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL rpl_semi_sync_master_enabled=OFF</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">22</span><span class="variable">.818025</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL read_only = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">22</span><span class="variable">.818143</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL super_read_only = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">22</span><span class="variable">.818323</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     START SLAVE</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">22</span><span class="variable">.824449</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     STOP SLAVE</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">22</span><span class="variable">.824610</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     CHANGE MASTER TO MASTER_HOST = &#x27;<span class="number">192</span><span class="variable">.168</span><span class="variable">.0</span><span class="variable">.3</span>&#x27;, MASTER_USER = &#x27;qc_repl&#x27;, MASTER_PASSWORD = &lt;secret&gt;, MASTER_PORT = <span class="number">3306</span>, MASTER_AUTO_POSITION = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">22</span><span class="variable">.833710</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     START SLAVE</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">22</span><span class="variable">.935973</span>+<span class="number">08</span>:<span class="number">00</span>           <span class="number">10</span> Query     BEGIN</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">22</span><span class="variable">.936084</span>+<span class="number">08</span>:<span class="number">00</span>           <span class="number">10</span> Query     COMMIT <span class="comment">/* implicit, from Xid_log_event */</span></span><br><span class="line">......</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">24</span><span class="variable">.701711</span>+<span class="number">08</span>:<span class="number">00</span>           <span class="number">10</span> Query     BEGIN</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">24</span><span class="variable">.701901</span>+<span class="number">08</span>:<span class="number">00</span>           <span class="number">10</span> Query     COMMIT <span class="comment">/* implicit, from Xid_log_event */</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">24</span><span class="variable">.816571</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL rpl_semi_sync_master_enabled=OFF</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">24</span><span class="variable">.816886</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL read_only = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">24</span><span class="variable">.817177</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL super_read_only = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">24</span><span class="variable">.817281</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     START SLAVE</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.039581</span>+<span class="number">08</span>:<span class="number">00</span>           <span class="number">10</span> Query     BEGIN</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.039749</span>+<span class="number">08</span>:<span class="number">00</span>           <span class="number">10</span> Query     COMMIT <span class="comment">/* implicit, from Xid_log_event */</span></span><br><span class="line">......</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.152919</span>+<span class="number">08</span>:<span class="number">00</span>           <span class="number">10</span> Query     BEGIN</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.153082</span>+<span class="number">08</span>:<span class="number">00</span>           <span class="number">10</span> Query     COMMIT <span class="comment">/* implicit, from Xid_log_event */</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.389776</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     STOP SLAVE</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.392581</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     RESET SLAVE ALL</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.407434</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     RESET MASTER</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.417292</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL gtid_purged=&#x27;<span class="number">6</span>b437e80-e5d5-<span class="number">11</span>ea-<span class="number">88</span>e3-<span class="number">52549922</span>fdbb:<span class="number">1</span>-<span class="number">102610</span></span><br><span class="line">&#x27;</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.419835</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     START SLAVE</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.427071</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL read_only = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.427178</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL super_read_only = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.427271</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL sync_binlog=<span class="number">1000</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.427339</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL innodb_flush_log_at_trx_commit=<span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.427423</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SHOW SLAVE STATUS</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">25</span><span class="variable">.427600</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SHOW MASTER STATUS</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">26</span><span class="variable">.817622</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL rpl_semi_sync_master_enabled=OFF</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">26</span><span class="variable">.817794</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL read_only = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">26</span><span class="variable">.817897</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SET GLOBAL super_read_only = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">26</span><span class="variable">.817988</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     START SLAVE</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">26</span><span class="variable">.818381</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SHOW SLAVE STATUS</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">26</span><span class="variable">.818570</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     SHOW MASTER STATUS</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">26</span><span class="variable">.818715</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     STOP SLAVE</span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">26</span><span class="variable">.818823</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     CHANGE MASTER TO MASTER_HOST = &#x27;<span class="number">192</span><span class="variable">.168</span><span class="variable">.0</span><span class="variable">.3</span>&#x27;, MASTER_USER = &#x27;qc_repl&#x27;, MASTER_PASSWORD = &lt;secret&gt;, MASTER_PORT = <span class="number">3306</span>, MASTER_AUTO_POSITION = <span class="number">1</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">08</span>-<span class="number">24</span>T21:<span class="number">55</span>:<span class="number">26</span><span class="variable">.832164</span>+<span class="number">08</span>:<span class="number">00</span>            <span class="number">8</span> Query     START SLAVE</span><br></pre></td></tr></table></figure><p>这就是说在设置gtid_purged之前已经启用复制获取了一部分数据，那么 xtrabackup_binlog_info 中的内容就不再准确，之后设置的GTID与实际数据就不一致，实际的数据比设置的GTID要多，引起主键冲突。</p><p><strong>问题2：为什么之前MySQL 5.6、5.7从没遇到过这个问题呢？</strong></p><p>测试了很多次，发现在 MySQL 5.6 &amp; 5.7 在<code>set gtid_purged</code> 前执行 <code>change master to &amp; start slave</code> 后会报复制错误 <code>Slave failed to initialize relay log info structure from the repository</code> ，而在<code>reset slave all; reset master、set gtid_purged</code>后再执行 <code>change master to &amp; start slave</code> 就可以正常复制，数据无误。</p><p><strong>问题3：xenon中哪块逻辑引起的额外的 change master to 和 start slave ？</strong></p><p>问题根源在重建期间 xenon 会设为 LEARNER 角色，而该角色在探测到MySQL Alive后，会 change master 到主节点。正常来说，要等raft状态设为 FOLLOWER 后由 FOLLOWER 的监听线程 change master 到主节点。（代码见 <a href="https://github.com/radondb/xenon/pull/104">pr104</a> 、<a href="https://github.com/radondb/xenon/pull/102">pr102</a>  ）</p><h4 id="坑二：MySQL-8-0-Group-Replication-重建后无法启动MGR"><a href="#坑二：MySQL-8-0-Group-Replication-重建后无法启动MGR" class="headerlink" title="坑二：MySQL 8.0 + Group-Replication 重建后无法启动MGR"></a>坑二：MySQL 8.0 + Group-Replication 重建后无法启动MGR</h4><p>根据报错信息<code>Slave failed to initialize relay log info structure from the repository</code>看，应该是xtrabackup重建后的数据目录保留了slave复制信息导致的，尝试在启动组复制前执行<code>reset slave或reset slave all</code>即可解决。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><ol><li>Xtrabackup 2.4 备份后生成的 <code>xtrabackup_binlog_info</code> 文件记录的 GTID 信息是准确的，但是备份恢复后 <code>show master status</code> 显示的 GTID 是不准确的。</li><li>Xtrabackup 8.0 在备份只有 InnoDB 表的实例时，<code>xtrabackup_binlog_info</code> 文件记录的 GTID 信息不一定是准确的，但是备份恢复后 <code>show master status</code> 显示的 GTID 是准确的。</li><li>Xtrabackup 8.0 在备份有非 InnoDB 表格的实例时，<code>xtrabackup_binlog_info</code> 文件记录的 GTID 信息是准确的，备份恢复后 <code>show master status</code> 显示的 GTID 也是准确的。</li><li>使用 Xtrabackup 8.0 重建集群节点后，无需执行 <code>reset master &amp; set gtid_purged</code> 操作。</li><li>使用 Xtrabackup 8.0 重建 Group-Replication 集群节点后，启动组复制前需要先执行<code>reset slave或reset slave all</code>清除slave信息，否则 <code>start group_replication</code> 会失败。</li></ol></blockquote><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2020-08-27 13:46:15&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/tags/MySQL/"/>
    
    <category term="问题定位" scheme="http://dbkernel.github.io/tags/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    
    <category term="Percona" scheme="http://dbkernel.github.io/tags/Percona/"/>
    
    <category term="Xtrabackup" scheme="http://dbkernel.github.io/tags/Xtrabackup/"/>
    
    <category term="RadonDB" scheme="http://dbkernel.github.io/tags/RadonDB/"/>
    
    <category term="Xenon" scheme="http://dbkernel.github.io/tags/Xenon/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（８）纯手工打造的SQL解析器</title>
    <link href="http://dbkernel.github.io/2020/07/26/clickhouse-and-friends-08-parser/"/>
    <id>http://dbkernel.github.io/2020/07/26/clickhouse-and-friends-08-parser/</id>
    <published>2020-07-26T13:55:10.000Z</published>
    <updated>2021-10-10T12:05:18.670Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>本文首发于 2020-07-26 21:55:10</strong></p><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/07/25/clickhouse-and-friends-parser/">https://bohutang.me/2020/07/25/clickhouse-and-friends-parser/</a><br>以下为正文。</p></blockquote><p>现实生活中的物品一旦被标记为“纯手工打造”，给人的第一感觉就是“上乘之品”，一个字“贵”，比如北京老布鞋。</p><p>但是在计算机世界里，如果有人告诉你 ClickHouse 的 SQL 解析器是纯手工打造的，是不是很惊讶！</p><p>这个问题引起了不少网友的关注，所以本篇聊聊 ClickHouse 的纯手工解析器，看看它们的底层工作机制及优缺点。</p><p>枯燥先从一个 SQL 开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> t1</span><br></pre></td></tr></table></figure><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>首先对 SQL 里的字符逐个做判断，然后根据其关联性做 token 分割：</p><p><img src="parser.png" alt="parser.png"></p><p>比如连续的 WordChar，那它就是 BareWord，解析函数在 <a href="https://github.com/ClickHouse/ClickHouse/blob/558f9c76306ffc4e6add8fd34c2071b64e914103/src/Parsers/Lexer.cpp#L61">Lexer::nextTokenImpl()</a>，解析调用栈：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DB::Lexer::<span class="built_in">nextTokenImpl</span>() Lexer.cpp:<span class="number">63</span></span><br><span class="line">DB::Lexer::<span class="built_in">nextToken</span>() Lexer.cpp:<span class="number">52</span></span><br><span class="line">DB::Tokens::<span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">long</span>) TokenIterator.h:<span class="number">36</span></span><br><span class="line">DB::TokenIterator::<span class="built_in">get</span>() TokenIterator.h:<span class="number">62</span></span><br><span class="line">DB::TokenIterator::<span class="keyword">operator</span>-&gt;() TokenIterator.h:<span class="number">64</span></span><br><span class="line">DB::<span class="built_in">tryParseQuery</span>(DB::IParser&amp;, <span class="keyword">char</span> <span class="keyword">const</span>*&amp;, <span class="keyword">char</span> <span class="keyword">const</span>*, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt;&amp;, <span class="keyword">bool</span>, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, <span class="keyword">bool</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>) parseQuery.cpp:<span class="number">224</span></span><br><span class="line">DB::<span class="built_in">parseQueryAndMovePosition</span>(DB::IParser&amp;, <span class="keyword">char</span> <span class="keyword">const</span>*&amp;, <span class="keyword">char</span> <span class="keyword">const</span>*, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, <span class="keyword">bool</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>) parseQuery.cpp:<span class="number">314</span></span><br><span class="line">DB::<span class="built_in">parseQuery</span>(DB::IParser&amp;, <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">char</span> <span class="keyword">const</span>*, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>) parseQuery.cpp:<span class="number">332</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, DB::Context &amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer *) executeQuery.cpp:<span class="number">272</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">731</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">313</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">150</span></span><br></pre></td></tr></table></figure><h2 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h2><p>token 是最基础的元组，他们之间没有任何关联，只是一堆生冷的词组与符号，所以我们还需对其进行<strong>语法解析</strong>，让这些 token 之间建立一定的关系，达到一个可描述的活力。</p><p>ClickHouse 在解每一个 token 的时候，会根据当前的 token 进行状态空间进行预判（parse 返回 true 则进入子状态空间继续），然后决定状态跳转，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="comment">-- TokenType::BareWord</span></span><br></pre></td></tr></table></figure><p>逻辑首先会进入Parsers/ParserQuery.cpp 的 <a href="https://github.com/ClickHouse/ClickHouse/blob/558f9c76306ffc4e6add8fd34c2071b64e914103/src/Parsers/ParserQuery.cpp#L26">ParserQuery::parseImpl</a> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> res = query_with_output_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || insert_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || use_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || set_role_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || set_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || system_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || create_user_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || create_role_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || create_quota_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || create_row_policy_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || create_settings_profile_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || drop_access_entity_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">    || grant_p.<span class="built_in">parse</span>(pos, node, expected);</span><br></pre></td></tr></table></figure><p>这里会对所有 query 类型进行 parse 方法的调用，直到有分支返回 true。</p><p>我们来看<strong>第一层</strong> query_with_output_p.parse <a href="https://github.com/ClickHouse/ClickHouse/blob/558f9c76306ffc4e6add8fd34c2071b64e914103/src/Parsers/ParserQueryWithOutput.cpp#L31">Parsers/ParserQueryWithOutput.cpp</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> parsed =</span><br><span class="line">       explain_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || select_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || show_create_access_entity_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || show_tables_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || table_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || describe_table_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || show_processlist_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || create_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || alter_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || rename_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || drop_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || check_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || kill_query_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || optimize_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || watch_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || show_access_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || show_access_entities_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || show_grants_p.<span class="built_in">parse</span>(pos, query, expected)</span><br><span class="line">    || show_privileges_p.<span class="built_in">parse</span>(pos, query, expected</span><br></pre></td></tr></table></figure><p>跳进<strong>第二层</strong> explain_p.parse <a href="https://github.com/ClickHouse/ClickHouse/blob/558f9c76306ffc4e6add8fd34c2071b64e914103/src/Parsers/ParserExplainQuery.cpp#L10">ParserExplainQuery::parseImpl</a>状态空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParserExplainQuery::parseImpl</span><span class="params">(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASTExplainQuery::ExplainKind kind;</span><br><span class="line">    <span class="keyword">bool</span> old_syntax = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_ast</span><span class="params">(<span class="string">&quot;AST&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_analyze</span><span class="params">(<span class="string">&quot;ANALYZE&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_explain</span><span class="params">(<span class="string">&quot;EXPLAIN&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_syntax</span><span class="params">(<span class="string">&quot;SYNTAX&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_pipeline</span><span class="params">(<span class="string">&quot;PIPELINE&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_plan</span><span class="params">(<span class="string">&quot;PLAN&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s_explain.<span class="built_in">ignore</span>(pos, expected))</span><br><span class="line">    &#123;</span><br><span class="line">       ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    ParserSelectWithUnionQuery select_p;</span><br><span class="line">    ASTPtr query;</span><br><span class="line">    <span class="keyword">if</span> (!select_p.<span class="built_in">parse</span>(pos, query, expected))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure><p>s_explain.ignore 方法会进行一个 keyword 解析，解析出 ast node:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="comment">-- keyword</span></span><br></pre></td></tr></table></figure><p>跃进<strong>第三层</strong> select_p.parse <a href="https://github.com/ClickHouse/ClickHouse/blob/558f9c76306ffc4e6add8fd34c2071b64e914103/src/Parsers/ParserSelectWithUnionQuery.cpp#L26">ParserSelectWithUnionQuery::parseImpl</a>状态空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParserSelectWithUnionQuery::parseImpl</span><span class="params">(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASTPtr list_node;</span><br><span class="line"></span><br><span class="line">    <span class="function">ParserList <span class="title">parser</span><span class="params">(std::make_unique&lt;ParserUnionQueryElement&gt;(), std::make_unique&lt;ParserKeyword&gt;(<span class="string">&quot;UNION ALL&quot;</span>), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!parser.<span class="built_in">parse</span>(pos, list_node, expected))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>parser.parse 里又调用<strong>第四层</strong> <a href="https://github.com/ClickHouse/ClickHouse/blob/558f9c76306ffc4e6add8fd34c2071b64e914103/src/Parsers/ParserSelectQuery.cpp#L24">ParserSelectQuery::parseImpl</a> 状态空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParserSelectQuery::parseImpl</span><span class="params">(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> select_query = std::make_shared&lt;ASTSelectQuery&gt;();</span><br><span class="line">    node = select_query;</span><br><span class="line"></span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_select</span><span class="params">(<span class="string">&quot;SELECT&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_distinct</span><span class="params">(<span class="string">&quot;DISTINCT&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_from</span><span class="params">(<span class="string">&quot;FROM&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_prewhere</span><span class="params">(<span class="string">&quot;PREWHERE&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_where</span><span class="params">(<span class="string">&quot;WHERE&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_group_by</span><span class="params">(<span class="string">&quot;GROUP BY&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_with</span><span class="params">(<span class="string">&quot;WITH&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_totals</span><span class="params">(<span class="string">&quot;TOTALS&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_having</span><span class="params">(<span class="string">&quot;HAVING&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_order_by</span><span class="params">(<span class="string">&quot;ORDER BY&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_limit</span><span class="params">(<span class="string">&quot;LIMIT&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_settings</span><span class="params">(<span class="string">&quot;SETTINGS&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_by</span><span class="params">(<span class="string">&quot;BY&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_rollup</span><span class="params">(<span class="string">&quot;ROLLUP&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_cube</span><span class="params">(<span class="string">&quot;CUBE&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_top</span><span class="params">(<span class="string">&quot;TOP&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_with_ties</span><span class="params">(<span class="string">&quot;WITH TIES&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_offset</span><span class="params">(<span class="string">&quot;OFFSET&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ParserNotEmptyExpressionList <span class="title">exp_list</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserNotEmptyExpressionList <span class="title">exp_list_for_with_clause</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserNotEmptyExpressionList <span class="title">exp_list_for_select_clause</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!exp_list_for_select_clause.<span class="built_in">parse</span>(pos, select_expression_list, expected))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><strong>第五层</strong> exp_list_for_select_clause.parse <a href="https://github.com/ClickHouse/ClickHouse/blob/558f9c76306ffc4e6add8fd34c2071b64e914103/src/Parsers/ExpressionListParsers.cpp#L520">ParserExpressionList::parseImpl</a>状态空间继续：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParserExpressionList::parseImpl</span><span class="params">(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParserList</span>(</span><br><span class="line">        std::make_unique&lt;ParserExpressionWithOptionalAlias&gt;(allow_alias_without_as_keyword),</span><br><span class="line">        std::make_unique&lt;ParserToken&gt;(TokenType::Comma))</span><br><span class="line">        .<span class="built_in">parse</span>(pos, node, expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>… … 写不下去个鸟！</p><p>可以发现，ast parser 的时候，预先构造好状态空间，比如 select 的状态空间:</p><ol><li>expression list</li><li>from tables</li><li>where</li><li>group by</li><li>with …</li><li>order by</li><li>limit</li></ol><p>在一个状态空间內，还可以根据 parse 返回的 bool 判断是否继续进入子状态空间，一直递归解析出整个 ast。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>手工 parser 的好处是代码清晰简洁，每个细节可防可控，以及友好的错误处理，改动起来不会一发动全身。</p><p>缺点是手工成本太高，需要大量的测试来保证其正确性，还需要一些fuzz来保证可靠性。</p><p>好在ClickHouse 已经实现的比较全面，即使有新的需求，在现有基础上修修补补即可。</p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;strong&gt;本文首发于 2020-07-26 21:55:10&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://bo</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Parser" scheme="http://dbkernel.github.io/tags/Parser/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（6）MergeTree存储结构</title>
    <link href="http://dbkernel.github.io/2020/06/30/clickhouse-and-friends-06-merge-tree-disk-layout/"/>
    <id>http://dbkernel.github.io/2020/06/30/clickhouse-and-friends-06-merge-tree-disk-layout/</id>
    <published>2020-06-30T13:41:12.000Z</published>
    <updated>2021-10-10T11:02:02.185Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>本文首发于 2020-06-30 21:41:12</strong></p><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/06/26/clickhouse-and-friends-merge-tree-disk-layout/">https://bohutang.me/2020/06/26/clickhouse-and-friends-merge-tree-disk-layout/</a><br>以下为正文。</p></blockquote><p>上篇的 <a href="https://bohutang.me/2020/06/20/clickhouse-and-friends-merge-tree-algo/">存储引擎技术进化与MergeTree</a> 介绍了存储算法的演进。</p><p>存储引擎是一个数据库的底盘，一定要稳和动力澎湃。</p><p>接下来我们将一起来探索下 ClickHouse MergeTree 列式存储引擎，解构下这台“跑车”最重要的部件。</p><p>所有的存储引擎，无论精良与粗制滥造，最终都是要把数据回写到磁盘，来满足存储和索引目的。</p><p>磁盘文件的构造可以说是算法的物理体现，我们甚至可以通过这些存储结构反推出其算法实现。</p><p>所以，要想深入了解一个存储引擎，最好的入手点是它的磁盘存储结构，然后再反观它的读、写机制就会有一种水到渠成的感觉。</p><p>如果这个分析顺序搞反了，会有一种生硬的感觉，网上大部分教程都是这种“生硬”式教学，本文将直击灵魂从最底层谈起，彻底搞明白４个问题：</p><ol><li>MergeTree 有哪些文件？</li><li>MergeTree 数据如何分布？</li><li>MergeTree 索引如何组织？</li><li>MergeTree 如何利用索引加速？</li></ol><p>话不多说，上表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> default.mt</span><br><span class="line">(</span><br><span class="line">    `a` Int32,</span><br><span class="line">    `b` Int32,</span><br><span class="line">    `c` Int32,</span><br><span class="line">    INDEX `idx_c` (c) TYPE minmax GRANULARITY <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> b</span><br><span class="line">SETTINGS index_granularity<span class="operator">=</span><span class="number">3</span></span><br></pre></td></tr></table></figure><p>造点数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> default.mt(a,b,c) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> default.mt(a,b,c) <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> default.mt(a,b,c) <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">10</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">9</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>),(<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>),(<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>),(<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="磁盘文件"><a href="#磁盘文件" class="headerlink" title="磁盘文件"></a>磁盘文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls ckdatas/data/default/mt/</span><br><span class="line">1_4_4_0  3_6_6_0  5_5_5_0  detached  format_version.txt</span><br></pre></td></tr></table></figure><p>可以看到，生成了 3 个数据目录，每个目录在 ClickHouse 里称作一个分区(part)，目录名的前缀正是我们写入时字段 a 的值: 1,3,5，因为表分区是这样定位的：<code>PARTITION BY a</code>。</p><p>现在我们看看 a=3 分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls ckdatas/data/default/mt/3_6_6_0/</span><br><span class="line">a.bin  a.mrk2  b.bin  b.mrk2  c.bin  checksums.txt  c.mrk2  columns.txt  count.txt  minmax_a.idx  partition.dat  primary.idx  skp_idx_idx_c.idx  skp_idx_idx_c.mrk2</span><br></pre></td></tr></table></figure><ul><li><code>*.bin</code> 是列数据文件，按主键排序(ORDER BY)，这里是按照字段 b 进行排序</li><li><code>*.mrk2</code> mark 文件，目的是快速定位 bin 文件数据位置</li><li><code>minmax_a.idx</code> 分区键 min-max 索引文件，目的是加速分区键 a 查找</li><li><code>primay.idx</code> 主键索引文件，目的是加速主键 b 查找</li><li><code>skp_idx_idx_c.*</code> 字段 c 索引文件，目的是加速 c 的查找</li></ul><p>在磁盘上，MergeTree 只有一种物理排序，就是 ORDER BY 的主键序，其他文件(比如 .mrk/.idx)是一种逻辑加速，围绕仅有的一份物理排序，要解决的问题是：</p><p><strong>在以字段 b 物理排序上，如何实现字段 a、字段 c 的快速查找？</strong></p><p>MergeTree 引擎概括起来很简单：<br>整个数据集通过分区字段被划分为多个物理分区，每个分区內又通过逻辑文件围绕仅有的一种物理排序进行加速查找。</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><p>对于单个物理分区內的存储结构，首先要明确一点，MergeTree 的数据只有一份：<code>*.bin</code>。</p><p>a.bin 是字段 a 的数据，b.bin 是字段 b 的数据，c.bin 是字段 c 的数据，也就是大家熟悉的列存储。</p><p>各个 bin 文件以 b.bin排序对齐（b 是排序键），如图：<br><img src="merge-tree-bin-without-granule.png" alt="merge-tree-bin-without-granule.png"></p><p>这样会有一个比较严重的问题：<br>如果 <code>*.bin</code> 文件较大，即使读取一行数据，也要加载整个 bin 文件，浪费了大量的 IO，没法忍。</p><h3 id="granule"><a href="#granule" class="headerlink" title="granule"></a>granule</h3><p>高、黑科技来了，ClickHouse MergeTree 把 bin 文件根据颗粒度(GRANULARITY)划分为多个颗粒(granule)，每个 granule 单独压缩存储。</p><p><code>SETTINGS index_granularity=3</code> 表示每 ３ 行数据为一个 granule，分区目前只有 ７ 条数据，所以被划分成 3 个 granule(三个色块)：<br><img src="merge-tree-bin-granule.png" alt="merge-tree-bin-granule.png"></p><p>为方便读取某个 granule，使用 <code>*.mrk</code> 文件记录每个 granule 的 offset，每个 granule 的 header 里会记录一些元信息，用于读取解析:<br><img src="merge-tree-bin-marker.png" alt="merge-tree-bin-marker.png"></p><p>这样，我们就可以根据 ｍark 文件，直接定位到想要的 granule，然后对这个单独的 granule 进行读取、校验。</p><p>目前，我们还有缺少一种映射：每个 mark 与字段值之间的对应，哪些值区间落在 mark0，哪些落在 mark1 …？</p><p>有了这个映射，就可以实现最小化读取 granule 来加速查询：</p><ol><li>根据查询条件确定需要哪些 mark</li><li>根据 mark 读取相应的 granule</li></ol><h3 id="存储排序"><a href="#存储排序" class="headerlink" title="存储排序"></a>存储排序</h3><p>在了解 MergeTree 索引机制之前，需要明白以下两点：</p><ol><li>只有一份全量数据，存储在 <code>*.bin</code> 文件</li><li><code>*.bin</code> 按照 ORDER BY 字段降序存储<br><img src="merge-tree-bin-orderby-sort.png" alt="merge-tree-bin-orderby-sort.png"></li></ol><h3 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h3><p>因为数据只有一份且只有一种物理排序，MergeTree在索引设计上选择了简单、高效的稀疏索引模式。</p><p>什么是稀疏索引呢？就是从已经排序的全量数据里，间隔性的选取一些点，并记录这些点属于哪个 mark。</p><h4 id="1-primary-index"><a href="#1-primary-index" class="headerlink" title="1. primary index"></a>1. primary index</h4><p>主键索引，可通过<code>[PRIMARY KEY expr]</code>指定，默认是 ORDER BY 字段值。</p><p>注意 ClickHouse primary index 跟 MySQL primary key 不是一个概念。</p><p>在稀疏点的选择上，取每个 granule 最小值：</p><p><img src="merge-tree-primary-key.png" alt="merge-tree-primary-key.png"></p><h4 id="2-skipping-index"><a href="#2-skipping-index" class="headerlink" title="2. skipping index"></a>2. skipping index</h4><p>普通索引。</p><p><code>INDEX idx_c(c) TYPE minmax GRANULARITY 1</code> 针对字段 c 创建一个 minmax 模式索引。</p><p><code>GRANULARITY</code> 是稀疏点选择上的 granule 颗粒度，<code>GRANULARITY 1</code> 表示每 1 个 granule 选取一个：<br><img src="merge-tree-skipping-index-g1.png" alt="merge-tree-skipping-index-g1.png"></p><p>如果定义为<code>GRANULARITY 2</code> ，则 2 个 granule 选取一个：<br><img src="merge-tree-skipping-index-g2.png" alt="merge-tree-skipping-index-g2.png"></p><h4 id="3-partition-minmax-index"><a href="#3-partition-minmax-index" class="headerlink" title="3. partition minmax index"></a>3. partition minmax index</h4><p>针对分区键，MergeTree 还会创建一个 min/max 索引，来加速分区选择。</p><p><img src="merge-tree-minmax-idx.png" alt="merge-tree-minmax-idx.png"></p><h4 id="4-全景图"><a href="#4-全景图" class="headerlink" title="4. 全景图"></a>4. 全景图</h4><p><img src="merge-tree-layout.png" alt="merge-tree-layout.png"></p><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><p>现在熟悉了 MergeTree 的存储结构，我们通过几个查询来体验下。</p><h3 id="1-分区键查询"><a href="#1-分区键查询" class="headerlink" title="1. 分区键查询"></a>1. 分区键查询</h3><p>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> default.mt <span class="keyword">where</span> a<span class="operator">=</span><span class="number">3</span></span><br></pre></td></tr></table></figure><p>查询会直接根据 <code>a=3</code> 定位到单个分区:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Debug&gt; InterpreterSelectQuery: MergeTreeWhereOptimizer: condition <span class="string">&quot;a = 3&quot;</span> moved to PREWHERE</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): Key condition: unknown</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): MinMax index condition: (column <span class="number">0</span> in [<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): Selected <span class="number">1</span> parts by a, <span class="number">1</span> parts by key, <span class="number">3</span> marks by primary key, <span class="number">3</span> marks to read from <span class="number">1</span> ranges</span><br><span class="line">┌─a─┬──b─┬──c─┐</span><br><span class="line">│ <span class="number">3</span> │  <span class="number">4</span> │ <span class="number">10</span> │</span><br><span class="line">│ <span class="number">3</span> │  <span class="number">5</span> │  <span class="number">9</span> │</span><br><span class="line">│ <span class="number">3</span> │  <span class="number">6</span> │  <span class="number">8</span> │</span><br><span class="line">│ <span class="number">3</span> │  <span class="number">7</span> │  <span class="number">7</span> │</span><br><span class="line">│ <span class="number">3</span> │  <span class="number">8</span> │  <span class="number">6</span> │</span><br><span class="line">│ <span class="number">3</span> │  <span class="number">9</span> │  <span class="number">5</span> │</span><br><span class="line">│ <span class="number">3</span> │ <span class="number">10</span> │  <span class="number">4</span> │</span><br><span class="line">└───┴────┴────┘</span><br></pre></td></tr></table></figure><h3 id="2-主键索引查询"><a href="#2-主键索引查询" class="headerlink" title="2. 主键索引查询"></a>2. 主键索引查询</h3><p>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> default.mt <span class="keyword">where</span> b<span class="operator">=</span><span class="number">5</span></span><br></pre></td></tr></table></figure><p>查询会先从 3 个分区读取 prmary.idx，然后定位到只有一个分区符合条件，找到要读取的 mark:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): Key condition: (column <span class="number">0</span> in [<span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): MinMax index condition: unknown</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): Selected <span class="number">3</span> parts by a, <span class="number">1</span> parts by key, <span class="number">1</span> marks by primary key, <span class="number">1</span> marks to read from <span class="number">1</span> ranges</span><br><span class="line">┌─a─┬─b─┬─c─┐</span><br><span class="line">│ <span class="number">3</span> │ <span class="number">5</span> │ <span class="number">9</span> │</span><br><span class="line">└───┴───┴───┘</span><br></pre></td></tr></table></figure><h3 id="3-索引查询"><a href="#3-索引查询" class="headerlink" title="3. 索引查询"></a>3. 索引查询</h3><p>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> default.mt <span class="keyword">where</span> c<span class="operator">=</span><span class="number">5</span></span><br></pre></td></tr></table></figure><p>查询会先从 3 个分区读取 prmary.idx 和 skp_idx_idx_c.idx 进行 granule 过滤（没用的 drop 掉），然后定位到只有 3_x_x_x 分区的一个 granule 符合条件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Debug&gt; InterpreterSelectQuery: MergeTreeWhereOptimizer: condition <span class="string">&quot;b = 5&quot;</span> moved to PREWHERE</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): Key condition: unknown</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): MinMax index condition: unknown</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): Index `idx_c` has dropped <span class="number">1</span> / <span class="number">1</span> granules.</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): Index `idx_c` has dropped <span class="number">1</span> / <span class="number">1</span> granules.</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): Index `idx_c` has dropped <span class="number">2</span> / <span class="number">3</span> granules.</span><br><span class="line">&lt;Debug&gt; <span class="keyword">default</span>.<span class="built_in">mt</span> (SelectExecutor): Selected <span class="number">3</span> parts by a, <span class="number">1</span> parts by key, <span class="number">5</span> marks by primary key, <span class="number">1</span> marks to read from <span class="number">1</span> ranges</span><br><span class="line">┌─a─┬─b─┬─c─┐</span><br><span class="line">│ <span class="number">3</span> │ <span class="number">9</span> │ <span class="number">5</span> │</span><br><span class="line">└───┴───┴───┘</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从磁盘存储结构入手，分析 ClickHouse MergeTree 的存储、索引设计。</p><p>只有了解了这些底层机制，我们才好对自己的 SQL 和表结构进行优化，使其执行更加高效。</p><p>ClickHouse MergeTree 设计简单、高效，它首要解决的问题是：在一种物理排序上，如何实现快速查找。</p><p>针对这个问题，ClickHouse使用稀疏索引来解决。</p><p>在官方 roadmap 上，列举了一个有意思的索引方向：Z-Order Indexing，目的是把多个维度编码到一维存储，当我们给出多维度条件的时候，可以快速定位到这个条件点集的空间位置，目前 ClickHouse 针对这个索引设计暂无进展。</p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;strong&gt;本文首发于 2020-06-30 21:41:12&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://bo</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="MergeTree" scheme="http://dbkernel.github.io/tags/MergeTree/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（5）存储引擎技术进化与MergeTree</title>
    <link href="http://dbkernel.github.io/2020/06/22/clickhouse-and-friends-05-merge-tree-algo/"/>
    <id>http://dbkernel.github.io/2020/06/22/clickhouse-and-friends-05-merge-tree-algo/</id>
    <published>2020-06-22T13:55:10.000Z</published>
    <updated>2021-09-24T04:02:24.553Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>本文首发于 2020-06-22 21:55:10</strong></p><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/06/20/clickhouse-and-friends-merge-tree-algo/">https://bohutang.me/2020/06/20/clickhouse-and-friends-merge-tree-algo/</a><br>以下为正文。</p></blockquote><p>21 世纪的第二个 10 年，虎哥已经在存储引擎一线奋战近 10 年，由于强大的兴趣驱动，这么多年来几乎不放过 arXiv 上与存储相关的每一篇 paper。</p><p>尤其是看到带有 draft 的 paper 时，有一种乞丐听到“叮当”响时的愉悦。</p><p>看paper这玩意就像鉴宝，多数是“赝品”，需要你有“鉴真”的本领，否则今天是张三的算法超越xx，明儿又是王二的硬件提升了yy，让你永远跟不上节奏zz，湮灭在这些没有营养的技术垃圾中，浪费大好青春。</p><p>言归正传，接下来的3篇，跟 ClickHouse 的 MergeTree 引擎有关：</p><p><strong>上篇介绍存储引擎的技术演进史</strong>，从”远古”的 B-tree 出发推演到目前主流的技术架构。</p><p><strong><a href="https://bohutang.me/2020/06/26/clickhouse-and-friends-merge-tree-disk-layout/">中篇会从存储结构介绍 MergeTree 原理</a></strong> ，对 ClickHouse MergeTree 有一个深入的认识，如何合理设计来进行科学加速。</p><p><strong>下篇会从MergeTree代码出发</strong>，看看 ClickHouse MergeTree 如何实现读、写。</p><p>本文为上篇，先来个热身，相信本篇大部分内容对大家来说都比较陌生，很少人写过。</p><h2 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h2><p>存储引擎(事务型)在一个数据库(DBMS)中的地位如何呢？</p><p>MySQL 的商业成功可以说大部分来自于 InnoDB 引擎，Oracle 收购 InnoDB 比 MySQL 早好几年呢！</p><p>20年前，能亲手撸一套 <a href="https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics">ARIES (Algorithms for Recovery and Isolation Exploiting Semantics)</a> 规范引擎，实力还是相当震撼的，相信 Oracle 收购的不仅是 InnoDB 这个引擎，更重要的是人， InnoDB 作者在哪里，在干什么？！</p><p>Fork 出来的 MariaDB 这么多年一直找不到自己的灵魂，在 Server 层磨磨蹭蹭可谓是江河日下，只能四处收购碰碰运气，当年 TokuDB 战斗过的 commit 依在，但这些已经是历史了。</p><p>另，WiredTiger 被 MongoDB 收购并使用，对整个生态所起的作用也是无可估量的，这些发动机引擎对于一辆汽车是非常重要的。</p><p>有人问道，都已经 2020 年了，开发一个存储引擎还这么难吗？不难，但是造出来的未必有 RocksDB 好用？！</p><p>如大家所见，很多的分布式存储引擎都是基于 RocksDB 研发，可谓短期内还算明智的选择。</p><p>从工程角度来看，一个 ACID 引擎要打磨的东西非常之多，到处充斥着人力、钱力、耐心的消耗，一种可能是写到一半就停滞了(如 <a href="https://github.com/BohuTANG/nessDB">nessDB</a>)，还有一种可能是写着写着发现跟xx很像，沃茨法克。</p><p>当然，这里并不是鼓励大家都去基于 RocksDB 去构建自己的产品，而是要根据自己的情况去做选择。</p><h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h2><p>首先要尊称一声大爷，这个大爷年方 50，目前支撑着数据库产业的半壁江山。</p><p>50 年来不变而且人们还没有改变它的意向，这个大爷厉害的很！</p><p>鉴定一个算法的优劣，有一个学派叫 <strong>IO复杂度分析</strong>，简单推演真假便知。</p><p>下面就用此法分析下 B-tree(traditional b-tree) 的 IO 复杂度，对读、写 IO 一目了然，真正明白读为什么快，写为什么慢，如何优化。</p><p>为了可以愉快的阅读，本文不会做任何公式推导，复杂度分析怎么可能没有公式呢！</p><h3 id="读IO分析"><a href="#读IO分析" class="headerlink" title="读IO分析"></a>读IO分析</h3><p>这里有一个 3-level 的 B-tree，每个方块代表一个 page，数字代表 page ID。</p><p><img src="btree-read.png" alt="btree-read.png"></p><p>上图 B-tree 结构是<strong>内存</strong>的一个表现形式，如果我们要读取的记录在 leaf-8上，read-path 如蓝色箭头所示:</p><p>root-9 –&gt; branch-6 –&gt; leaf-8</p><p>下图是 B-tree 在<strong>磁盘</strong>上的存储形式，meta page 是起点:</p><p><img src="btree-read-disk.png" alt="btree-read-disk.png"></p><p>这样读取的随机 IO (假设内存里没有 page 缓存且 page 存储是随机的)总数就是(蓝色箭头):</p><p>1(meta-10)IO + 1(root-9)IO + 1(branch-6)IO + 1(leaf-8)IO = 4次 IO，这里忽略一直缓存的 meta 和 root，就是 <strong>2</strong> 次随机 IO。<br>如果磁盘 seek 是 1ms，读取延迟就是 <strong>2ms</strong>。</p><p>通过推演就会发现，B-tree 是一种读优化(Read-Optimized)的数据结构，无论 LSM-tree 还是 Fractal-tree 等在读上只能比它慢，因为读放大(Read Amplification)问题。</p><p>存储引擎算法可谓日新月异，但是大部分都是在跟写优化(Write-Optimized)做斗争，那怕是一个常数项的优化那就是突破，自从 Fractal-tree 突破后再无来者了！</p><h3 id="写IO分析"><a href="#写IO分析" class="headerlink" title="写IO分析"></a>写IO分析</h3><p>现在写一条记录到 leaf-8。</p><p><img src="btree-update-raw.png" alt="btree-update-raw.png"></p><p>可以发现，每次写都需要先读取一遍，如上图蓝色路径所示。</p><p>假设这次写入导致 root, branch 都发生了变化，这种 in-place 的更新反映到磁盘上就是：</p><p><img src="btree-update-raw-disk.png" alt="btree-update-raw-disk.png"></p><p>基本是 <strong>2</strong> 次读 IO和写 <strong>2</strong> 次写 IO+WAL fsync，粗略为 <strong>4</strong> 次随机 IO。</p><p>通过分析发现，B-tree 对写操作不太友好，随机 IO 次数较多，而且 in-place 更新必须增加一个 page 级的 WAL 保证失败回滚，简直是要命。</p><h3 id="Write-Optimized-B-tree"><a href="#Write-Optimized-B-tree" class="headerlink" title="Write-Optimized B-tree"></a>Write-Optimized B-tree</h3><p>说到写优化，在机械盘的年代，大家的方向基本是把随机 IO 转换为顺序 IO，充分发挥磁盘的机械优势，于是出现一种 Append-only B-tree：</p><p><img src="btree-aof.png" alt="btree-aof.png"></p><ol><li>更新生成新的 page(蓝色)</li><li>page 回写磁盘时 append only 到文件末尾</li><li>无需 page WAL，数据不 overwrite，有写放大(Write Amplification)问题，需要做空洞重利用机制</li></ol><p>Append-only B-tree 节省了回写时的 2 次随机 IO，转换为常数级(constant)的1次顺序 IO，写性能大幅提升，总结起来就是：</p><blockquote><p><strong>随机变顺序，空间换时间</strong></p></blockquote><p>LSM-tree, Fractal-tree 等写优化算法的核心思想也是这个，只不过其实现机制不同。</p><h2 id="LSM-trees"><a href="#LSM-trees" class="headerlink" title="LSM-trees"></a>LSM-trees</h2><p>随着 LevelDB 的问世，LSM-tree 逐渐被大家所熟知。</p><p>LSM-tree 更像一种思想，模糊了 B-tree 里 tree 的严肃性，通过文件组织成一个更加松散的 tree。</p><p>这里不谈一个具体的 LSM-tree 是 Leveled 还是 Size-tiered，只谈大体思想。</p><p><img src="lsm-tree.png" alt="lsm-tree.png"></p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><ol><li>先写入内存的 C0</li><li>后台线程根据规则(Leveled/Sized)进行 merge，C0 –&gt; C1, C1 –&gt; C2 … CL</li><li>写入 C0 即可返回，IO 放到后台的 Merge 过程</li><li>每次 Merge 是硬伤，动作大就抖，动作小性能不好，每次 Merge 的数据流向不明确</li><li>写放大问题</li></ol><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><ol><li>读取 C0</li><li>读取 C1 .. CL</li><li>合并记录返回</li><li>读放大问题</li></ol><h2 id="Fractal-tree"><a href="#Fractal-tree" class="headerlink" title="Fractal-tree"></a>Fractal-tree</h2><p>终于发展到了“终极”优化(目前最先进的索引算法)，Fractal-tree。</p><p>它是在 Append-only B-tree 的基础上，对每个 branch 节点增加了一个 message buffer 作为缓冲，可以看做是 LSM-tree 和 Append-only B-tree 完美合体。</p><p>相对于 LSM-tree 它的优势非常明显:<br>Merge 更加有序，数据流向非常分明，消除了 Merge 的抖动问题，大家一直寻找的 compaction 防抖方案一直存在的！</p><p>这个高科技目前只有 <a href="https://github.com/xelabs/tokudb">TokuDB</a> 在使用，这个算法可以开篇新介，这里不做累述，感兴趣的可以参考原型实现 <a href="https://github.com/BohuTANG/nessDB">nessDB</a>。</p><h2 id="Cache-oblivious"><a href="#Cache-oblivious" class="headerlink" title="Cache-oblivious"></a>Cache-oblivious</h2><p>这个词对于大部分人都是陌生的，不过别怕。</p><p>在存储引擎里，有一个数据结构非常非常重要，它负责 page 数据有序性维护，比如在一个 page 里怎么快速定位到我要的记录。</p><p>在 LevelDB 里使用 skiplist，但大部分引擎使用的是一个有序数组来表示，比如 [1, 2, 3, … 100]，然后使用二分查找。</p><p>大概 10 年前一位内核开发者发表了一篇 &lt;<a href="https://queue.acm.org/detail.cfm?id=1814327">You’re Doing It Wrong</a>&gt;，这个小文讲了一个很有意思的事情：</p><p>数据的组织形式对性能有很大的影响，因为 CPU有 cache line。</p><p>抛开这篇文章不谈，咱们来看一张“神仙”图：</p><p><img src="veb-layout.png" alt="veb-layout.png"></p><p>这是一个 binary-tree 的 4 种 layout 表示形式，那么哪种 layout 对 CPU cache line 最友好？</p><p>也许你已经猜对了，那就是 van Emde Boas，简称 vEB。</p><p>因为它的相邻数据“扎堆”存储，point-query 和 range-query 的 cache line 可以最大化共享，skiplist 对 cache line 是非常不友好的，还可以更快！</p><p>对于 cache oblivious 数据结构，这里有一个简单的原型实现: <a href="https://github.com/BohuTANG/omt">omt</a></p><h2 id="B-tree优化魔力象限"><a href="#B-tree优化魔力象限" class="headerlink" title="B-tree优化魔力象限"></a>B-tree优化魔力象限</h2><p>写优化算法从原生的 B-tree 到 Append-only B-tree(代表作 LMDB)，又到 LSM-tree(LevelDB/RocksDB 等)，最后进化到目前最先进的 Fractal-tree (TokuDB)。</p><p>这些算法耗费了很多年才在工程上实现并被认可，研发一款存储引擎缺的不是算法而是“鉴宝”的能力，这个“宝”可能已经躺了几十年了。</p><p>其实，”科学家”们已经总结出一个 B-tree 优化魔力象限:</p><p><img src="btree-optimal-curve.png" alt="btree-optimal-curve.png"></p><p>横坐标是写性能，纵坐标是读性能，B-tree 和 Logging 数据结构分布在曲线的两个极端。</p><p>B-tree 的读性能非常好，但是写性能差。</p><p>Logging 的写性能非常好，但是读性能差(想想我们每次写都把数据追加到文件末尾，是不是很快？但是读…)。</p><p>在它们中间有一个优化曲度(Optimal Curve)。</p><p>在这个曲度上，你可以通过增加/减少一个常数(1-epsilon)来做读和写优化组合，LSM-tree/Fractal-tree 都在这个曲度之上。</p><p><img src="btree-epsilon.png" alt="btree-epsilon.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要讨论事务性引擎的技术演进，其中包含了 IO 复杂度分析，其实这个分析是基于一个 DAM(Disk Access Machine) 模型，这里不再展开。<br>这个模型要解决什么问题呢？</p><p>如果工程中涉及硬件层级关系，比如 Disk / Memory / CPU，数据在Disk，读取(以 block 为单位)到 Memory，查找计算(cache-line)在 CPU，不同介质间性能差距又非常之大，我们怎么做才能让整体性能更优的问题。</p><p>和当今的硬件相融合，这个模型也一样适用。</p><p>最后回到 ClickHouse 的 MergeTree 引擎，它只使用了本文中的部分优化，实现也比较简洁、高效，毕竟没有事务，撸起来也没啥心理负担。</p><p><strong>随机变顺序，空间换时间</strong>， MergeTree 原理，请听下回分解。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>[1] <a href="https://www.cs.au.dk/~gerth/papers/cacheoblivious05.pdf">Cache-Oblivious Data Structures</a></li><li>[2] <a href="https://www3.cs.stonybrook.edu/~bender/talks/2013-BenderKuszmaul-xldb-tutorial.pdf">Data Structures and Algorithms for Big Databases</a></li><li>[3] <a href="https://link.springer.com/chapter/10.1007%2F3-540-60220-8_74">The buffer tree: A new technique for optimal I/O-algorithms</a></li><li>[4] <a href="http://www.bzero.se/ldapd/btree.html">how the append-only btree works</a></li><li>[5] <a href="https://www.douban.com/note/269741273/">写优化的数据结构(1):AOF和b-tree之间</a></li><li>[6] <a href="https://www.douban.com/note/269744617/">写优化的数据结构(2):buffered tree</a></li><li>[7] <a href="https://www.douban.com/note/304123656/">存储引擎数据结构优化(1):cpu bound</a></li><li>[8] <a href="https://www.douban.com/note/304349195/">存储引擎数据结构优化(2):io bound</a></li><li>[9] <a href="https://github.com/BohuTANG/nessDB">nessDB</a></li><li>[10] <a href="https://github.com/BohuTANG/omt">omt</a></li></ul><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;&lt;strong&gt;本文首发于 2020-06-22 21:55:10&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://b</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="B-Tree" scheme="http://dbkernel.github.io/tags/B-Tree/"/>
    
    <category term="LSM-Tree" scheme="http://dbkernel.github.io/tags/LSM-Tree/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（4）Pipeline处理器和调度器</title>
    <link href="http://dbkernel.github.io/2020/06/12/clickhouse-and-friends-04-processor/"/>
    <id>http://dbkernel.github.io/2020/06/12/clickhouse-and-friends-04-processor/</id>
    <published>2020-06-12T12:57:10.000Z</published>
    <updated>2021-09-24T04:00:28.579Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>本文首发于 2020-06-12 19:57:10</strong></p><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/06/11/clickhouse-and-friends-processor/">https://bohutang.me/2020/06/11/clickhouse-and-friends-processor/</a><br>以下为正文。</p></blockquote><p><strong>最后更新: 2020-08-15</strong></p><p>本文谈下 ClickHouse 核心科技：处理器 Processor 和有向无环调度器 DAG Scheduler。</p><p>这些概念并不是 ClickHouse 首创，感兴趣的同学可以关注下 <a href="https://github.com/MaterializeInc/materialize">materialize</a> 的 <a href="https://github.com/TimelyDataflow/timely-dataflow">timely-dataflow</a>，虎哥用 golang 也写过一个<a href="https://github.com/vectorengine/vectorsql/tree/master/src/processors">原型</a>。</p><p>拼的是实现细节，正是这些模块的精良设计，才有了 ClickHous e整体的高性能。</p><h2 id="Pipeline问题"><a href="#Pipeline问题" class="headerlink" title="Pipeline问题"></a>Pipeline问题</h2><p>在传统数据库系统中，一个 Query 处理流程大体是:</p><p><img src="processor-plan.png" alt="processor-plan.png"></p><p>其中在 Plan 阶段，往往会增加一个 Pipeline 组装(一个 transformer 代表一次数据处理)：</p><p><img src="processor-transformer.png" alt="processor-transformer.png"></p><p>所有 transformer 被编排成一个流水线(pipeline)，然后交给 executor 串行式执行，每执行一个 transformer 数据集就会被加工并输出，一直到下游的 sinker。</p><p>可以看到，这种模型的优点是<strong>简单</strong>，缺点是<strong>性能低</strong>，无法发挥 CPU 的<strong>并行</strong>能力，通常叫火山模型(<strong>volcano</strong>-style)，对于 OLTP 低延迟来说足够，对于计算密集的 OLAP 来说是远远不够的，CPU 不到 100% 就是犯罪！</p><p>对于上面的例子，如果 transformer1 和 transformer2 没有交集，那么它们就可以并行处理：</p><p><img src="processor-transformer2.png" alt="processor-transformer2.png"></p><p>这样就涉及到一些比较灵魂的问题：</p><ol><li>如何实现 transformer 的灵活编排？</li><li>如何实现 transformer 间的数据同步？</li><li>如何实现 transformer 间的并行调度？</li></ol><h2 id="Processor-和-DAG-Scheduler"><a href="#Processor-和-DAG-Scheduler" class="headerlink" title="Processor 和 DAG Scheduler"></a>Processor 和 DAG Scheduler</h2><h3 id="1-Transformer-编排"><a href="#1-Transformer-编排" class="headerlink" title="1. Transformer 编排"></a>1. Transformer 编排</h3><p>ClickHouse 实现了一系列基础 transformer 模块，见 <a href="https://github.com/ClickHouse/ClickHouse/tree/master/src/Processors/Transforms">src/Processors/Transforms</a>，比如:</p><ul><li>FilterTransform – WHERE 条件过滤</li><li>SortingTransform – ORDER BY 排序</li><li>LimitByTransform – LIMIT 裁剪</li></ul><p>当我们执行:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span> LIMIT <span class="number">10</span></span><br></pre></td></tr></table></figure><p>对于 ClickHouse 的 QueryPipeline 来说，它会按照以下方式进行编排组装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryPipeline::<span class="built_in">addSimpleTransform</span>(Source)</span><br><span class="line">QueryPipeline::<span class="built_in">addSimpleTransform</span>(FilterTransform)</span><br><span class="line">QueryPipeline::<span class="built_in">addSimpleTransform</span>(SortingTransform)</span><br><span class="line">QueryPipeline::<span class="built_in">addSimpleTransform</span>(LimitByTransform)</span><br><span class="line">QueryPipeline::<span class="built_in">addSimpleTransform</span>(Sinker)</span><br></pre></td></tr></table></figure><p>这样就实现了 Transformer 的编排，但是执行时数据如何进行同步呢？</p><h3 id="2-Transformer-数据同步"><a href="#2-Transformer-数据同步" class="headerlink" title="2. Transformer 数据同步"></a>2. Transformer 数据同步</h3><p>当 QueryPipeline 进行 transformer 编排时，我们还需要进行更加底层的 DAG 连通构建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(Source.OutPort, FilterTransform.InPort)</span><br><span class="line"><span class="built_in">connect</span>(FilterTransform.OutPort, SortingTransform.InPort)</span><br><span class="line"><span class="built_in">connect</span>(SortingTransform.OutPort, LimitByTransform.InPort)</span><br><span class="line"><span class="built_in">connect</span>(LimitByTransform.OutPort, Sinker.InPort)</span><br></pre></td></tr></table></figure><p>这样就实现了数据的流向关系，一个 transformer 的 OutPort 对接另外一个的 InPort，就像我们现实中的水管管道一样，接口有 3 通甚至多通。</p><h3 id="3-Transformer-执行调度"><a href="#3-Transformer-执行调度" class="headerlink" title="3. Transformer 执行调度"></a>3. Transformer 执行调度</h3><p>现在管道组装起来了，那么管道内的水如何进行处理和给压流动呢？</p><p>ClickHouse 定义了一套 transform 状态，processor 根据这些状态来实现调度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NeedData  <span class="comment">// 等待数据流进入</span></span><br><span class="line">    PortFull, <span class="comment">// 管道流出端阻塞</span></span><br><span class="line">    Finished, <span class="comment">// 完成状态，退出</span></span><br><span class="line">    Ready,    <span class="comment">// 切换到 work 函数，进行逻辑处理</span></span><br><span class="line">    Async,    <span class="comment">// 切换到 schedule 函数，进行异步处理</span></span><br><span class="line">    Wait,     <span class="comment">// 等待异步处理</span></span><br><span class="line">    ExpandPipeline,      <span class="comment">// Pipeline 需要裂变</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 source 生成数据后，它的状态会设置为 PortFull，意思是等着流入其他 transformer 的 InPort，processor 会开始调度 FilterTransformer(NeedData) 的 Prepare，进行 PullData，然后它的状态设置为 Ready，等待 processor 调度 Work 方法进行数据Filter处理，大家就这样靠状态让 processor 去感知，来调度和做状态迁移，直到 Finished 状态。</p><p>这里值得一提的是 ExpandPipeline 状态，它会根据 transformer 的实现，可以把一个 transformer 裂变出更多个 transformer 并行执行，达到一个爆炸效果。</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> number <span class="operator">+</span> <span class="number">1</span> <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p>为了更加深入理解 ClickHouse 的 processor 和 scheduler 机制，我们来一个原生态的 example:</p><ol><li>一个 Source:{0,1,2,3,4}</li><li>AdderTransformer 对每个数字做加1操作</li><li>一个 Sinker，输出结果</li></ol><h3 id="1-Source"><a href="#1-Source" class="headerlink" title="1. Source"></a>1. Source</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySource</span> :</span> <span class="keyword">public</span> ISource</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MySource&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MySource</span>(UInt64 end_)</span><br><span class="line">        : <span class="built_in">ISource</span>(<span class="built_in">Block</span>(&#123;ColumnWithTypeAndName&#123;ColumnUInt64::<span class="built_in">create</span>(), std::make_shared&lt;DataTypeUInt64&gt;(), <span class="string">&quot;number&quot;</span>&#125;&#125;)), <span class="built_in">end</span>(end_)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UInt64 end;</span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Chunk <span class="title">generate</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (done)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Chunk</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        MutableColumns columns;</span><br><span class="line">        columns.<span class="built_in">emplace_back</span>(ColumnUInt64::<span class="built_in">create</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0U</span>; i &lt; end; i++)</span><br><span class="line">            columns[<span class="number">0</span>]-&gt;<span class="built_in">insert</span>(i);</span><br><span class="line"></span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Chunk</span>(std::<span class="built_in">move</span>(columns), end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-MyAddTransform"><a href="#2-MyAddTransform" class="headerlink" title="2. MyAddTransform"></a>2. MyAddTransform</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAddTransformer</span> :</span> <span class="keyword">public</span> IProcessor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MyAddTransformer&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyAddTransformer</span>()</span><br><span class="line">        : <span class="built_in">IProcessor</span>(</span><br><span class="line">            &#123;<span class="built_in">Block</span>(&#123;ColumnWithTypeAndName&#123;ColumnUInt64::<span class="built_in">create</span>(), std::make_shared&lt;DataTypeUInt64&gt;(), <span class="string">&quot;number&quot;</span>&#125;&#125;)&#125;,</span><br><span class="line">            &#123;<span class="built_in">Block</span>(&#123;ColumnWithTypeAndName&#123;ColumnUInt64::<span class="built_in">create</span>(), std::make_shared&lt;DataTypeUInt64&gt;(), <span class="string">&quot;number&quot;</span>&#125;&#125;)&#125;)</span><br><span class="line">        , <span class="built_in">input</span>(inputs.<span class="built_in">front</span>())</span><br><span class="line">        , <span class="built_in">output</span>(outputs.<span class="built_in">front</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">prepare</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (output.<span class="built_in">isFinished</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            input.<span class="built_in">close</span>();</span><br><span class="line">            <span class="keyword">return</span> Status::Finished;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!output.<span class="built_in">canPush</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            input.<span class="built_in">setNotNeeded</span>();</span><br><span class="line">            <span class="keyword">return</span> Status::PortFull;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (has_process_data)</span><br><span class="line">        &#123;</span><br><span class="line">            output.<span class="built_in">push</span>(std::<span class="built_in">move</span>(current_chunk));</span><br><span class="line">            has_process_data = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input.<span class="built_in">isFinished</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            output.<span class="built_in">finish</span>();</span><br><span class="line">            <span class="keyword">return</span> Status::Finished;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!input.<span class="built_in">hasData</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            input.<span class="built_in">setNeeded</span>();</span><br><span class="line">            <span class="keyword">return</span> Status::NeedData;</span><br><span class="line">        &#125;</span><br><span class="line">        current_chunk = input.<span class="built_in">pull</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> Status::Ready;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> num_rows = current_chunk.<span class="built_in">getNumRows</span>();</span><br><span class="line">        <span class="keyword">auto</span> result_columns = current_chunk.<span class="built_in">cloneEmptyColumns</span>();</span><br><span class="line">        <span class="keyword">auto</span> columns = current_chunk.<span class="built_in">detachColumns</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0U</span>; i &lt; num_rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> val = columns[<span class="number">0</span>]-&gt;<span class="built_in">getUInt</span>(i);</span><br><span class="line">            result_columns[<span class="number">0</span>]-&gt;<span class="built_in">insert</span>(val+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        current_chunk.<span class="built_in">setColumns</span>(std::<span class="built_in">move</span>(result_columns), num_rows);</span><br><span class="line">        has_process_data = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">InputPort &amp; <span class="title">getInputPort</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">    <span class="function">OutputPort &amp; <span class="title">getOutputPort</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> output; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">bool</span> has_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> has_process_data = <span class="literal">false</span>;</span><br><span class="line">    Chunk current_chunk;</span><br><span class="line">    InputPort &amp; input;</span><br><span class="line">    OutputPort &amp; output;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-MySink"><a href="#3-MySink" class="headerlink" title="3. MySink"></a>3. MySink</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySink</span> :</span> <span class="keyword">public</span> ISink</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MySinker&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MySink</span>() : <span class="built_in">ISink</span>(<span class="built_in">Block</span>(&#123;ColumnWithTypeAndName&#123;ColumnUInt64::<span class="built_in">create</span>(), std::make_shared&lt;DataTypeUInt64&gt;(), <span class="string">&quot;number&quot;</span>&#125;&#125;)) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WriteBufferFromFileDescriptor out&#123;STDOUT_FILENO&#125;;</span><br><span class="line">    FormatSettings settings;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(Chunk chunk)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> rows = chunk.<span class="built_in">getNumRows</span>();</span><br><span class="line">        <span class="keyword">size_t</span> columns = chunk.<span class="built_in">getNumColumns</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> row_num = <span class="number">0</span>; row_num &lt; rows; ++row_num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">writeString</span>(<span class="string">&quot;prefix-&quot;</span>, out);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> column_num = <span class="number">0</span>; column_num &lt; columns; ++column_num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (column_num != <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">writeChar</span>(<span class="string">&#x27;\t&#x27;</span>, out);</span><br><span class="line">                <span class="built_in">getPort</span>()</span><br><span class="line">                    .<span class="built_in">getHeader</span>()</span><br><span class="line">                    .<span class="built_in">getByPosition</span>(column_num)</span><br><span class="line">                    .type-&gt;<span class="built_in">serializeAsText</span>(*chunk.<span class="built_in">getColumns</span>()[column_num], row_num, out, settings);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">writeChar</span>(<span class="string">&#x27;\n&#x27;</span>, out);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-DAG-Scheduler"><a href="#4-DAG-Scheduler" class="headerlink" title="4. DAG Scheduler"></a>4. DAG Scheduler</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> **)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> source0 = std::make_shared&lt;MySource&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">auto</span> add0 = std::make_shared&lt;MyAddTransformer&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sinker0 = std::make_shared&lt;MySink&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Connect.</span></span><br><span class="line">    <span class="built_in">connect</span>(source0-&gt;<span class="built_in">getPort</span>(), add0-&gt;<span class="built_in">getInputPort</span>());</span><br><span class="line">    <span class="built_in">connect</span>(add0-&gt;<span class="built_in">getOutputPort</span>(), sinker0-&gt;<span class="built_in">getPort</span>());</span><br><span class="line"></span><br><span class="line">    std::vector&lt;ProcessorPtr&gt; processors = &#123;source0, add0, sinker0&#125;;</span><br><span class="line">    <span class="function">PipelineExecutor <span class="title">executor</span><span class="params">(processors)</span></span>;</span><br><span class="line">    executor.<span class="built_in">execute</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从开发者角度看还是比较复杂，状态迁移还需要开发者自己控制，不过 upstream 已经做了大量的基础工作，比如对 source的封装 ISource，对 sink 的封装 ISink，还有一个基础的 ISimpleTransform，让开发者在上层使用 processor 时更加容易，可以积木式搭建出自己想要的 pipeline。</p><p>ClickHouse 的 transformer 数据单元是 Chunk，transformer 对上游 OutPort 流过来的 Chunk 进行加工，然后输出给下游的 InPort，图连通式的流水线并行工作，让 CPU 尽量满负荷工作。</p><p>当一个 SQL 被解析成 AST 后，ClickHouse 根据 AST 构建 Query Plan，然后根据 QueryPlan 构建出 pipeline，最后由 processor 负责调度和执行。</p><p>目前，ClickHouse 新版本已经默认开启 QueryPipeline，同时这块代码也在不停的迭代。</p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;strong&gt;本文首发于 2020-06-12 19:57:10&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://bo</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="DAG Scheduler" scheme="http://dbkernel.github.io/tags/DAG-Scheduler/"/>
    
    <category term="pipeline" scheme="http://dbkernel.github.io/tags/pipeline/"/>
    
    <category term="processor" scheme="http://dbkernel.github.io/tags/processor/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（3）MySQL Protocol和Write调用栈</title>
    <link href="http://dbkernel.github.io/2020/06/08/clickhouse-and-friends-03-mysql-protocol-write-stack/"/>
    <id>http://dbkernel.github.io/2020/06/08/clickhouse-and-friends-03-mysql-protocol-write-stack/</id>
    <published>2020-06-08T11:57:10.000Z</published>
    <updated>2021-09-24T03:59:35.901Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>本文首发于 2020-06-08 19:57:10</strong></p><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/06/08/clickhouse-and-friends-mysql-protocol-write-stack/">https://bohutang.me/2020/06/08/clickhouse-and-friends-mysql-protocol-write-stack/</a><br>以下为正文。</p></blockquote><p>上篇的<a href="https://dbkernel.github.io/2020/06/07/clickhouse-and-friends-02-mysql-protocol-read-stack/">MySQL Protocol和Read调用</a>里介绍了 ClickHouse 一条查询语句的调用栈，本文继续介绍写的调用栈，开整。</p><h2 id="Write请求"><a href="#Write请求" class="headerlink" title="Write请求"></a><strong>Write请求</strong></h2><ol><li><p>建表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(a UInt8, b UInt8, c UInt8) ENGINE<span class="operator">=</span>MergeTree() <span class="keyword">PARTITION</span> <span class="keyword">BY</span> (a, b) <span class="keyword">ORDER</span> <span class="keyword">BY</span> c;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="调用栈分析"><a href="#调用栈分析" class="headerlink" title="调用栈分析"></a><strong>调用栈分析</strong></h2><h3 id="1-获取存储引擎-OutputStream"><a href="#1-获取存储引擎-OutputStream" class="headerlink" title="1. 获取存储引擎 OutputStream"></a>1. 获取存储引擎 OutputStream</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DB::StorageMergeTree::<span class="built_in">write</span>(std::__1::shared_ptr&lt;DB::IAST&gt; <span class="keyword">const</span>&amp;, DB::Context <span class="keyword">const</span>&amp;) StorageMergeTree.cpp:<span class="number">174</span></span><br><span class="line">DB::PushingToViewsBlockOutputStream::<span class="built_in">PushingToViewsBlockOutputStream</span>(std::__1::shared_ptr&lt;DB::IStorage&gt; <span class="keyword">const</span>&amp;, DB::Context <span class="keyword">const</span>&amp;, std::__1::shared_ptr&lt;DB::IAST&gt; <span class="keyword">const</span>&amp;, <span class="keyword">bool</span>) PushingToViewsBlockOutputStream.cpp:<span class="number">110</span></span><br><span class="line">DB::InterpreterInsertQuery::<span class="built_in">execute</span>() InterpreterInsertQuery.cpp:<span class="number">229</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, DB::Context &amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer *) executeQuery.cpp:<span class="number">364</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">696</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h3 id="2-从-SQL-组装-InputStream"><a href="#2-从-SQL-组装-InputStream" class="headerlink" title="2. 从 SQL 组装 InputStream"></a>2. 从 SQL 组装 InputStream</h3><p><code>(1,1,1), (2,2,2)</code> 如何组装成 inputstream 结构呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DB::InputStreamFromASTInsertQuery::<span class="built_in">InputStreamFromASTInsertQuery</span>(std::__1::shared_ptr&lt;DB::IAST&gt; <span class="keyword">const</span>&amp;, DB::ReadBuffer*,</span><br><span class="line">DB::InterpreterInsertQuery::<span class="built_in">execute</span>() InterpreterInsertQuery.cpp:<span class="number">300</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">char</span> <span class="keyword">const</span>*, DB::Context&amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer*) executeQuery.cpp:<span class="number">386</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">313</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">150</span></span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.in = std::make_shared&lt;InputStreamFromASTInsertQuery&gt;(query_ptr, <span class="literal">nullptr</span>, query_sample_block, context, <span class="literal">nullptr</span>);</span><br><span class="line">res.in = std::make_shared&lt;NullAndDoCopyBlockInputStream&gt;(res.in, out_streams.<span class="built_in">at</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>通过 NullAndDoCopyBlockInputStream的 copyData 方法构造出 Block：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DB::ValuesBlockInputFormat::<span class="built_in">readRow</span>(std::__1::vector&lt;COW&lt;DB::IColumn&gt;::mutable_ptr&lt;DB::IColumn&gt;, std::__1::allocator&lt;COW&lt;DB::IColumn&gt;::mutable_ptr&lt;DB::IColumn&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) ValuesBlockInputFormat.cpp:<span class="number">93</span></span><br><span class="line">DB::ValuesBlockInputFormat::<span class="built_in">generate</span>() ValuesBlockInputFormat.cpp:<span class="number">55</span></span><br><span class="line">DB::ISource::<span class="built_in">work</span>() ISource.cpp:<span class="number">48</span></span><br><span class="line">DB::InputStreamFromInputFormat::<span class="built_in">readImpl</span>() InputStreamFromInputFormat.h:<span class="number">48</span></span><br><span class="line">DB::IBlockInputStream::<span class="built_in">read</span>() IBlockInputStream.cpp:<span class="number">57</span></span><br><span class="line">DB::InputStreamFromASTInsertQuery::<span class="built_in">readImpl</span>() InputStreamFromASTInsertQuery.h:<span class="number">31</span></span><br><span class="line">DB::IBlockInputStream::<span class="built_in">read</span>() IBlockInputStream.cpp:<span class="number">57</span></span><br><span class="line"><span class="keyword">void</span> DB::copyDataImpl&lt;DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*)::$_0&amp;, <span class="built_in"><span class="keyword">void</span></span> (&amp;)(DB::Block <span class="keyword">const</span>&amp;)&gt;(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*)::$_0&amp;, <span class="built_in"><span class="keyword">void</span></span> (&amp;)(DB::Block <span class="keyword">const</span>&amp;)) copyData.cpp:<span class="number">26</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*) copyData.cpp:<span class="number">62</span></span><br><span class="line">DB::NullAndDoCopyBlockInputStream::<span class="built_in">readImpl</span>() NullAndDoCopyBlockInputStream.h:<span class="number">47</span></span><br><span class="line">DB::IBlockInputStream::<span class="built_in">read</span>() IBlockInputStream.cpp:<span class="number">57</span></span><br><span class="line"><span class="keyword">void</span> DB::copyDataImpl&lt;std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;&gt;(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">26</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">73</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">785</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">313</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">150</span></span><br></pre></td></tr></table></figure><h3 id="3-组装-OutputStream"><a href="#3-组装-OutputStream" class="headerlink" title="3. 组装 OutputStream"></a>3. 组装 OutputStream</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DB::InterpreterInsertQuery::<span class="built_in">execute</span>() InterpreterInsertQuery.cpp:<span class="number">107</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, DB::Context &amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer *) executeQuery.cpp:<span class="number">364</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">696</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><p>组装顺序:</p><ol><li>NullAndDoCopyBlockInputStream</li><li>CountingBlockOutputStream</li><li>AddingDefaultBlockOutputStream</li><li>SquashingBlockOutputStream</li><li>PushingToViewsBlockOutputStream</li><li>MergeTreeBlockOutputStream</li></ol><h3 id="4-写入OutputStream"><a href="#4-写入OutputStream" class="headerlink" title="4. 写入OutputStream"></a>4. 写入OutputStream</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DB::MergeTreeBlockOutputStream::<span class="built_in">write</span>(DB::Block <span class="keyword">const</span>&amp;) MergeTreeBlockOutputStream.cpp:<span class="number">17</span></span><br><span class="line">DB::PushingToViewsBlockOutputStream::<span class="built_in">write</span>(DB::Block <span class="keyword">const</span>&amp;) PushingToViewsBlockOutputStream.cpp:<span class="number">145</span></span><br><span class="line">DB::SquashingBlockOutputStream::<span class="built_in">finalize</span>() SquashingBlockOutputStream.cpp:<span class="number">30</span></span><br><span class="line">DB::SquashingBlockOutputStream::<span class="built_in">writeSuffix</span>() SquashingBlockOutputStream.cpp:<span class="number">50</span></span><br><span class="line">DB::AddingDefaultBlockOutputStream::<span class="built_in">writeSuffix</span>() AddingDefaultBlockOutputStream.cpp:<span class="number">25</span></span><br><span class="line">DB::CountingBlockOutputStream::<span class="built_in">writeSuffix</span>() CountingBlockOutputStream.h:<span class="number">37</span></span><br><span class="line">DB::copyDataImpl&lt;DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*)::&lt;<span class="built_in">lambda</span>()&gt;&amp;, <span class="built_in"><span class="keyword">void</span></span> (&amp;)(<span class="keyword">const</span> DB::Block&amp;)&gt;(DB::IBlockInputStream &amp;, DB::IBlockOutputStream &amp;, &lt;<span class="built_in">lambda</span>()&gt; &amp;, <span class="built_in"><span class="keyword">void</span></span> (&amp;)(<span class="keyword">const</span> DB::Block &amp;)) copyData.cpp:<span class="number">52</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*) copyData.cpp:<span class="number">138</span></span><br><span class="line">DB::NullAndDoCopyBlockInputStream::<span class="built_in">readImpl</span>() NullAndDoCopyBlockInputStream.h:<span class="number">57</span></span><br><span class="line">DB::IBlockInputStream::<span class="built_in">read</span>() IBlockInputStream.cpp:<span class="number">60</span></span><br><span class="line"><span class="keyword">void</span> DB::copyDataImpl&lt;std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;&gt;(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">29</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">154</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">748</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><p>通过 copyData 方法，让数据在 OutputStream 间层层透传，一直到 MergeTreeBlockOutputStream。</p><h3 id="5-返回-Client"><a href="#5-返回-Client" class="headerlink" title="5. 返回 Client"></a>5. 返回 Client</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DB::MySQLOutputFormat::<span class="built_in">finalize</span>() MySQLOutputFormat.cpp:<span class="number">62</span></span><br><span class="line">DB::IOutputFormat::<span class="built_in">doWriteSuffix</span>() IOutputFormat.h:<span class="number">78</span></span><br><span class="line">DB::OutputStreamToOutputFormat::<span class="built_in">writeSuffix</span>() OutputStreamToOutputFormat.cpp:<span class="number">18</span></span><br><span class="line">DB::MaterializingBlockOutputStream::<span class="built_in">writeSuffix</span>() MaterializingBlockOutputStream.h:<span class="number">22</span></span><br><span class="line"><span class="keyword">void</span> DB::copyDataImpl&lt;std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;&gt;(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">52</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">154</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">748</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>首先内核解析 SQL 语句生成 AST，根据 AST 获取 Interpreter：InterpreterInsertQuery。</p><p>其次 Interpreter 依次添加相应的 OutputStream。</p><p>然后从 InputStream 读取数据，写入到 OutputStream，stream 会层层渗透，一直写到底层的存储引擎。</p><p>最后写入到 Socket Output，返回结果。</p><p>ClickHouse 的 OutputStream 编排还是比较复杂，缺少类似 Pipeline 的调度和编排，但是由于模式比较固化，目前看还算清晰。</p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;strong&gt;本文首发于 2020-06-08 19:57:10&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://bo</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/tags/MySQL/"/>
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（2）MySQL Protocol和Read调用栈</title>
    <link href="http://dbkernel.github.io/2020/06/07/clickhouse-and-friends-02-mysql-protocol-read-stack/"/>
    <id>http://dbkernel.github.io/2020/06/07/clickhouse-and-friends-02-mysql-protocol-read-stack/</id>
    <published>2020-06-07T09:17:10.000Z</published>
    <updated>2021-09-24T03:58:59.682Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>本文首发于 2020-06-07 17:17:10</strong></p><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/06/07/clickhouse-and-friends-mysql-protocol-read-stack/">https://bohutang.me/2020/06/07/clickhouse-and-friends-mysql-protocol-read-stack/</a><br>以下为正文。</p></blockquote><p>作为一个 OLAP 的 DBMS 来说，有2个端非常重要：</p><ul><li>用户如何方便的链进来，这是入口端<ul><li>ClickHouse 除了自己的 client 外，还提供了 MySQL/PG/GRPC/HTTP 等接入方式</li></ul></li><li>数据如何方便的挂上去，这是数据源端<ul><li>ClickHouse 除了自己的引擎外，还可以挂载 MySQL/Kafka 等外部数据源</li></ul></li></ul><p>这样内外互通，多条朋友多条路，以实现“数据”级的编排能力。</p><p>今天谈的是入口端的 MySQL 协议，也是本系列 ClickHouse 的第一个好朋友，用户可通过 MySQL 客户端或相关 Driver 直接链接到 ClickHouse，进行数据读写等操作。</p><p>本文通过 MySQL的 Query 请求，借用调用栈来了解下 ClickHouse 的数据读取全过程。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a><strong>如何实现？</strong></h2><p>入口文件在:<br><a href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Server/MySQLHandler.cpp">MySQLHandler.cpp</a></p><h3 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a><strong>握手协议</strong></h3><ol><li>MySQLClient 发送 Greeting 数据报文到 MySQLHandler</li><li>MySQLHandler 回复一个 Greeting-Response 报文</li><li>MySQLClient 发送认证报文</li><li>MySQLHandler 对认证报文进行鉴权，并返回鉴权结果</li></ol><p>MySQL Protocol 实现在: <a href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Core/MySQLProtocol.h">Core/MySQLProtocol.h</a></p><blockquote><p>最近的代码中调整为了 <a href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Core/MySQL/PacketsProtocolText.h">Core/MySQL/PacketsProtocolText.h</a></p></blockquote><h3 id="Query请求"><a href="#Query请求" class="headerlink" title="Query请求"></a><strong>Query请求</strong></h3><p>当认证通过后，就可以进行正常的数据交互了。</p><ol><li><p>当 MySQLClient 发送请求:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> system.numbers LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>MySQLHandler 的调用栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;MySQLHandler::comQuery -&gt; executeQuery -&gt; pipeline-&gt;execute -&gt; MySQLOutputFormat::consume</span><br></pre></td></tr></table></figure></li><li><p>MySQLClient 接收到结果</p></li></ol><p>在步骤2里，executeQuery(executeQuery.cpp)非常重要。</p><p>它是所有前端 Server 和 ClickHouse 内核的接入口，第一个参数是 SQL 文本(‘select 1’)，第二个参数是结果集要发送到哪里去(socket net)。</p><h2 id="调用栈分析"><a href="#调用栈分析" class="headerlink" title="调用栈分析"></a><strong>调用栈分析</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM system.numbers LIMIT 5</span><br></pre></td></tr></table></figure><h3 id="1-获取数据源"><a href="#1-获取数据源" class="headerlink" title="1. 获取数据源"></a>1. 获取数据源</h3><p>StorageSystemNumbers 数据源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DB::StorageSystemNumbers::<span class="built_in">read</span>(std::__1::vector&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; &gt; &gt; <span class="keyword">const</span>&amp;, std::__1::shared_ptr&lt;DB::StorageInMemoryMetadata <span class="keyword">const</span>&gt; <span class="keyword">const</span>&amp;, DB::SelectQueryInfo <span class="keyword">const</span>&amp;, DB::Context <span class="keyword">const</span>&amp;, DB::QueryProcessingStage::Enum, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>) StorageSystemNumbers.cpp:<span class="number">135</span></span><br><span class="line">DB::ReadFromStorageStep::<span class="built_in">ReadFromStorageStep</span>(std::__1::shared_ptr&lt;DB::RWLockImpl::LockHolderImpl&gt;, std::__1::shared_ptr&lt;DB::StorageInMemoryMetadata <span class="keyword">const</span>&gt;&amp;, DB::SelectQueryOptions,</span><br><span class="line">DB::InterpreterSelectQuery::<span class="built_in">executeFetchColumns</span>(DB::QueryProcessingStage::Enum, DB::QueryPlan&amp;, std::__1::shared_ptr&lt;DB::PrewhereInfo&gt; <span class="keyword">const</span>&amp;, std::__1::vector&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; &gt; &gt; <span class="keyword">const</span>&amp;) memory:<span class="number">3028</span></span><br><span class="line">DB::InterpreterSelectQuery::<span class="built_in">executeFetchColumns</span>(DB::QueryProcessingStage::Enum, DB::QueryPlan&amp;, std::__1::shared_ptr&lt;DB::PrewhereInfo&gt; <span class="keyword">const</span>&amp;, std::__1::vector&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; &gt; &gt; <span class="keyword">const</span>&amp;) InterpreterSelectQuery.cpp:<span class="number">1361</span></span><br><span class="line">DB::InterpreterSelectQuery::<span class="built_in">executeImpl</span>(DB::QueryPlan&amp;, std::__1::shared_ptr&lt;DB::IBlockInputStream&gt; <span class="keyword">const</span>&amp;, std::__1::optional&lt;DB::Pipe&gt;) InterpreterSelectQuery.cpp:<span class="number">791</span></span><br><span class="line">DB::InterpreterSelectQuery::<span class="built_in">buildQueryPlan</span>(DB::QueryPlan&amp;) InterpreterSelectQuery.cpp:<span class="number">472</span></span><br><span class="line">DB::InterpreterSelectWithUnionQuery::<span class="built_in">buildQueryPlan</span>(DB::QueryPlan&amp;) InterpreterSelectWithUnionQuery.cpp:<span class="number">183</span></span><br><span class="line">DB::InterpreterSelectWithUnionQuery::<span class="built_in">execute</span>() InterpreterSelectWithUnionQuery.cpp:<span class="number">198</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, DB::Context &amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer *) executeQuery.cpp:<span class="number">385</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;,</span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">307</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><p>这里最主要的是 ReadFromStorageStep 函数，从不同 storage 里获取数据源 pipe:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipes pipes = storage-&gt;<span class="built_in">read</span>(required_columns, metadata_snapshot, query_info, *context, processing_stage, max_block_size, max_streams);</span><br></pre></td></tr></table></figure><h3 id="2-Pipeline构造"><a href="#2-Pipeline构造" class="headerlink" title="2. Pipeline构造"></a>2. Pipeline构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DB::LimitTransform::<span class="built_in">LimitTransform</span>(DB::Block <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>, std::__1::vector&lt;DB::SortColumnDescription, std::__1::allocator&lt;DB::SortColumnDescription&gt; &gt;) LimitTransform.cpp:<span class="number">21</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) memory:<span class="number">2214</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) memory:<span class="number">2299</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) memory:<span class="number">3570</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) memory:<span class="number">4400</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) LimitStep.cpp:<span class="number">33</span></span><br><span class="line">DB::ITransformingStep::<span class="built_in">updatePipeline</span>(std::__1::vector&lt;std::__1::unique_ptr&lt;DB::QueryPipeline, std::__1::default_delete&lt;DB::QueryPipeline&gt; &gt;, std::__1::allocator&lt;std::__1::unique_ptr&lt;DB::QueryPipeline, std::__1::default_delete&lt;DB::QueryPipeline&gt; &gt; &gt; &gt;) ITransformingStep.cpp:<span class="number">21</span></span><br><span class="line">DB::QueryPlan::<span class="built_in">buildQueryPipeline</span>() QueryPlan.cpp:<span class="number">154</span></span><br><span class="line">DB::InterpreterSelectWithUnionQuery::<span class="built_in">execute</span>() InterpreterSelectWithUnionQuery.cpp:<span class="number">200</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, DB::Context &amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer *) executeQuery.cpp:<span class="number">385</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">722</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">307</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h3 id="3-Pipeline执行"><a href="#3-Pipeline执行" class="headerlink" title="3. Pipeline执行"></a>3. Pipeline执行</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DB::LimitTransform::<span class="built_in">prepare</span>(std::__1::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::allocator&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::allocator&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; &gt; <span class="keyword">const</span>&amp;) LimitTransform.cpp:<span class="number">67</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">291</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">initializeExecution</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">747</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">executeImpl</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">764</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">execute</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">479</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">833</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">307</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h3 id="4-Output执行发送"><a href="#4-Output执行发送" class="headerlink" title="4. Output执行发送"></a>4. Output执行发送</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DB::MySQLOutputFormat::<span class="built_in">consume</span>(DB::Chunk) MySQLOutputFormat.cpp:<span class="number">53</span></span><br><span class="line">DB::IOutputFormat::<span class="built_in">work</span>() IOutputFormat.cpp:<span class="number">62</span></span><br><span class="line">DB::<span class="built_in">executeJob</span>(DB::IProcessor *) PipelineExecutor.cpp:<span class="number">155</span></span><br><span class="line"><span class="built_in"><span class="keyword">operator</span></span>() PipelineExecutor.cpp:<span class="number">172</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">executeStepImpl</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*) PipelineExecutor.cpp:<span class="number">630</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">executeSingleThread</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">546</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">executeImpl</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">812</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">execute</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">479</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">800</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>ClickHouse 的模块化比较清晰，像乐高积木一样可以组合拼装，当我们执行:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> system.numbers LIMIT <span class="number">5</span></span><br></pre></td></tr></table></figure><p>首先内核解析 SQL 语句生成 AST，然后根据 AST 获取数据源 Source，pipeline.Add(Source)。</p><p>其次根据 AST 信息生成 QueryPlan，根据 QueryPlan 再生成相应的 Transform，pipeline.Add(LimitTransform)。</p><p>然后添加 Output Sink 作为数据发送对象，pipeline.Add(OutputSink)。</p><p>执行 pipeline, 各个 Transformer 开始工作。</p><p>ClickHouse 的 Transformer 调度系统叫做 Processor，也是决定性能的重要模块，详情见 <a href="https://bohutang.me/2020/06/11/clickhouse-and-friends-processor/">Pipeline 处理器和调度器</a>。</p><p>ClickHouse 是一辆手动挡的豪华跑车，免费拥有，海啸们！</p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;strong&gt;本文首发于 2020-06-07 17:17:10&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://bo</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/tags/MySQL/"/>
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（1）编译、开发、测试</title>
    <link href="http://dbkernel.github.io/2020/06/05/clickhouse-and-friends-01-development/"/>
    <id>http://dbkernel.github.io/2020/06/05/clickhouse-and-friends-01-development/</id>
    <published>2020-06-05T11:37:10.000Z</published>
    <updated>2021-09-22T15:24:33.493Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>本文首发于 2020-06-05 19:37:10</strong></p><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/06/05/clickhouse-and-friends-development/">https://bohutang.me/2020/06/05/clickhouse-and-friends-development/</a><br>以下为正文。</p></blockquote><p>一次偶然的机会，和ClickHouse团队做了一次线下沟通，Alexey提到ClickHouse的设计哲学:</p><ol><li>The product must solve actual problem</li><li>And do it better than others</li></ol><p>用工程思维解决商业问题的典范啊！</p><p>对用户来说，他们关心的不是什么天花乱坠、上天入地的高科技，只是需要一个能很好解决自己问题的方案，这在开源社区是非常难得的，靠实力“野蛮式”生长。</p><p>于是，我对这个散发着伏特加味道的利器充满了好奇，并参与到ClickHouse的社区中一探究竟，第一感觉是开放、友好、战斗力强(AK47 vs CK16, ClickHouse 2016年开源)。</p><p>本文先从编译和测试入手，再到如何为社区贡献Patch，希望对那些想参与CK社区的同学有所帮助。</p><h2 id="如何本地编译和测试ClickHouse？"><a href="#如何本地编译和测试ClickHouse？" class="headerlink" title="如何本地编译和测试ClickHouse？"></a><strong>如何本地编译和测试ClickHouse？</strong></h2><h3 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a><strong>源码获取</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/ClickHouse/ClickHouse</span><br></pre></td></tr></table></figure><h3 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a><strong>编译准备</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo apt-add-repository ppa:ubuntu-toolchain-r/<span class="built_in">test</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install gcc-9 g++-9 git python ninja-build</span><br><span class="line">sudo snap install cmake</span><br></pre></td></tr></table></figure><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a><strong>开始编译</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ClickHouse</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="built_in">export</span> CC=gcc-9</span><br><span class="line"><span class="built_in">export</span> CXX=g++-9</span><br><span class="line">cmake ..</span><br><span class="line">ninja</span><br></pre></td></tr></table></figure><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a><strong>测试方法</strong></h3><p>ClickHouse的测试在官方<a href="https://github.com/ClickHouse/ClickHouse/blob/master/docs/en/development/tests.md">development/tests</a>文档里有详细的介绍，这里列举3个常用的测试模式：</p><h4 id="1-Functional-Tests"><a href="#1-Functional-Tests" class="headerlink" title="1. Functional Tests"></a>1. Functional Tests</h4><p>功能测试，主要用于ClickHouse内部功能测试，方式：输入一个sql文件，输出一个result，类似MySQL里的mtr，<a href="https://github.com/ClickHouse/ClickHouse/tree/master/tests/queries">测试集合</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tests</span><br><span class="line">./clickhouse-test -c <span class="string">&quot;../build/programs/clickhouse-client&quot;</span> 00001_select_1</span><br></pre></td></tr></table></figure><h4 id="2-Integration-Tests"><a href="#2-Integration-Tests" class="headerlink" title="2. Integration Tests"></a>2. Integration Tests</h4><p>集成测试，主要用于涉及第三方服务的测试，比如MySQL/Postgres/MongoDB等，以容器化方式编排调度(pytest)运行，<a href="https://github.com/ClickHouse/ClickHouse/tree/master/tests/integration">测试集合</a></p><p>由于涉及模块较多，集成测试环境的搭建有一定的难度，建议使用官方的docker镜像。比如要跑test_mysql_protocol下的集成测试集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tests/integration</span><br><span class="line">docker pull yandex/clickhouse-integration-tests-runner</span><br><span class="line">./runner --binary /your/ClickHouse/build/programs/clickhouse  --bridge-binary /your/ClickHouse/build/programs/clickhouse-odbc-bridge --configs-dir /your/ClickHouse/programs/server/ <span class="string">&#x27;test_mysql_protocol/test.py::test_java_client -ss -vv&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-Unit-Tests"><a href="#3-Unit-Tests" class="headerlink" title="3. Unit Tests"></a>3. Unit Tests</h4><p>单元测试，主要用于代码模块的测试，测试集在各个模块的tests目录，比如: <a href="https://github.com/ClickHouse/ClickHouse/tree/master/src/Core/tests">Core/tests</a></p><p>如果大家想了解某个模块是如何工作的，强烈建议去翻翻该模块的tests目录，比如想了解processor的工作机制，跟踪调试 <a href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Processors/tests/processors_test.cpp">Processors/tests/</a> 即可。</p><h2 id="如何给ClickHouse社区提Patch？"><a href="#如何给ClickHouse社区提Patch？" class="headerlink" title="如何给ClickHouse社区提Patch？"></a><strong>如何给ClickHouse社区提Patch？</strong></h2><h4 id="1-fork"><a href="#1-fork" class="headerlink" title="1. fork"></a>1. fork</h4><p>首先在自己的github上fork一份ClickHouse代码，比如 <a href="https://github.com/BohuTANG/ClickHouse">https://github.com/BohuTANG/ClickHouse</a></p><h4 id="2-clone到本地"><a href="#2-clone到本地" class="headerlink" title="2. clone到本地"></a>2. clone到本地</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/BohuTANG/ClickHouse</span><br><span class="line">git checkout -B mysql_replica(branch名字)</span><br></pre></td></tr></table></figure><h4 id="3-创建新的分支"><a href="#3-创建新的分支" class="headerlink" title="3. 创建新的分支"></a>3. 创建新的分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -B mysql_replica(branch名字)</span><br></pre></td></tr></table></figure><h4 id="4-功能开发"><a href="#4-功能开发" class="headerlink" title="4. 功能开发"></a>4. 功能开发</h4><p>开发者可以提交一个Draft Pull Request到官方，github会显示这个Pull Request处于Draft状态，官方是无法Merge的</p><h4 id="5-can-be-testd标签"><a href="#5-can-be-testd标签" class="headerlink" title="5. can be testd标签"></a>5. can be testd标签</h4><p>等待Upstream打[can be tested]标签，一旦被标记CI狂魔们就强势开跑，跑一轮大概需要几十个小时。<br>协助开发者发现一些代码Style、编译以及测试等错误，这样开发者就可以在自己的分支不停的迭代、修正。<br><img src="github-ck-ci.jpeg" alt="img"></p><p>如果只是修改typo，这个标签Upstream通常不会添加。</p><h4 id="6-开发完毕"><a href="#6-开发完毕" class="headerlink" title="6. 开发完毕"></a>6. 开发完毕</h4><p>开发完成，测试OK，把Draft提升为正式Pull Request，等待Upstraem Review。</p><h4 id="7-Merge到Master"><a href="#7-Merge到Master" class="headerlink" title="7. Merge到Master"></a>7. Merge到Master</h4><p>如果Upstream通过，你的代码会被Merge到Master，恭喜你成为ClickHouse贡献者</p><h4 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8. 注意事项"></a>8. 注意事项</h4><p>ClickHouse Upstream迭代非常快，一定要多关注master分支进度，尽量保持自己的分支代码与master同步。否则Upstream Docker更新，自己的test可能就过不了。</p><p>建议把<a href="https://github.com/ClickHouse/ClickHouse/tree/master/docs/en/development">doc/development</a>读一遍。</p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;strong&gt;本文首发于 2020-06-05 19:37:10&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://bo</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>特性介绍 | MySQL select count(*) 、count(1)、count(列) 详解（1）：概念及区别</title>
    <link href="http://dbkernel.github.io/2020/05/06/mysql-select-count-functions-01-concepts-and-differences/"/>
    <id>http://dbkernel.github.io/2020/05/06/mysql-select-count-functions-01-concepts-and-differences/</id>
    <published>2020-05-06T07:55:15.000Z</published>
    <updated>2021-09-24T04:11:08.572Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文首发于 2020-05-05 21:55:15</strong></p></blockquote><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>从接触MySQL开始断断续续的看过一些文章，对<code>count()</code>操作众说纷纭，其中分歧点主要在于<code>count(1)</code>和<code>count(*)</code>哪个效率高，有说<code>count(1)</code>比<code>count(*)</code>快的（<code>这种说法更普遍</code>），有说二者一样快的。个人理解这两种行为可能适用于的是不同的版本，我只关心较新的MySQL版本是什么行为，详见下文。</p><h3 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a>二、含义</h3><p>首先，先说明一下常见<code>count()</code>操作及含义：</p><blockquote><p><code>count(*)</code>：计算包括NULL值在内的行数，SQL92定义的标准统计行数的语法。</p><p><code>count(1)</code>：计算包括NULL值在内的行数，其中的1是恒真表达式。</p><p><code>count(列名)</code>：计算指定列的行数，但不包含NULL值。</p></blockquote><h3 id="三、具体区别"><a href="#三、具体区别" class="headerlink" title="三、具体区别"></a>三、具体区别</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-functions.html#function_count">MySQL手册</a>中相关描述如下：</p><blockquote><p>For transactional storage engines such as InnoDB, storing an exact row count is problematic. Multiple transactions may be occurring at the same time, each of which may affect the count.</p><p>InnoDB does not keep an internal count of rows in a table because concurrent transactions might “see” different numbers of rows at the same time. Consequently, <code>SELECT COUNT(*)</code> statements only count rows visible to the current transaction.</p><p>Prior to <code>MySQL 5.7.18</code>, InnoDB processes <code>SELECT COUNT(*)</code> statements by scanning the clustered index. As of <code>MySQL 5.7.18</code>, InnoDB processes <code>SELECT COUNT(*)</code> statements by traversing the smallest available secondary index unless an index or optimizer hint directs the optimizer to use a different index. If a secondary index is not present, the clustered index is scanned.</p><p>Processing <code>SELECT COUNT(*)</code> statements takes some time if index records are not entirely in the buffer pool. For a faster count, create a counter table and let your application update it according to the inserts and deletes it does. However, this method may not scale well in situations where thousands of concurrent transactions are initiating updates to the same counter table. If an approximate row count is sufficient, use <code>SHOW TABLE STATUS</code>.</p><p>InnoDB handles <code>SELECT COUNT(*)</code> and <code>SELECT COUNT(1)</code> operations in the same way. There is no performance difference.</p><p>For <code>MyISAM</code> tables, <code>COUNT(*)</code> is optimized to return very quickly if the SELECT retrieves from one table, no other columns are retrieved, and there is no WHERE clause. For example:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span>mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><p>This optimization only applies to MyISAM tables, because an exact row count is stored for this storage engine and can be accessed very quickly.COUNT(1) is only subject to the same optimization if the first column is defined as NOT NULL.</p></blockquote><p><strong>官方这段描述要点如下：</strong></p><blockquote><ol><li>InnoDB是事务引擎，支持MVCC，并发事务可能同时“看到”不同的行数，所以，<strong>InnoDB不保留表中的行数</strong>，<code>SELECT COUNT(*)</code>语句只计算当前事务可见的行数。</li><li>在MySQL 5.7.18之前，InnoDB通过<strong>扫描聚集索引</strong>处理<code>SELECT COUNT(*)</code>语句。从MySQL 5.7.18开始，<code>InnoDB</code>通过<strong>遍历最小的可用二级索引</strong>来处理<code>SELECT COUNT(*)</code>语句，除非索引或优化器明确指示使用不同的索引。<strong>如果不存在二级索引，则扫描聚集索引</strong>。这样的设计单从 IO 的角度就节省了很多开销。</li><li><strong>InnoDB以同样的方式处理<code>SELECT COUNT(*)</code>和<code>SELECT COUNT(1)</code>操作，没有性能差异。</strong> 因此，建议使用符合SQL标准的<code>count(*)</code>。</li><li>对于<code>MyISAM</code>表，由于MyISAM引擎存储了精确的行数，因此，如果<code>SELECT COUNT(*)</code>语句不包含WHERE子句，则会很快返回。这个很好理解，如果带了where条件，就需要扫表了。</li><li>如果索引记录不完全在缓冲池中，则处理<code>SELECT(*)</code>语句需要一些时间。为了更快的计数，您可以创建一个计数器表，并让您的应用程序按插入和删除操作更新它。然而，这种方法在同一计数器表中启动成千上万个并发事务的情况下，可能无法很好地扩展。如果一个近似的行数足够，可以使用<code>SHOW TABLE STATUS</code>查询行数。</li></ol></blockquote><p>到这里我们明白了 <code>count(*)</code> 和 <code>count(1)</code> 本质上面其实是一样的，那么 <code>count(column)</code> 又是怎么回事呢？</p><blockquote><p><code>count(column)</code> 也是会遍历整张表，但是不同的是它会<strong>拿到 column 的值以后判断是否为空，然后再进行累加</strong>，那么如果<strong>针对主键需要解析内容</strong>，如果是<strong>二级索引需要再次根据主键获取内容，则要多一次 IO 操作</strong>，所以 <code>count(column)</code> 的性能肯定不如前两者，如果按照效率比较的话：*<em>count(</em>)=count(1)&gt;count(primary key)&gt;count(非主键column)**。</p></blockquote><h3 id="四、建议"><a href="#四、建议" class="headerlink" title="四、建议"></a>四、建议</h3><p>基于以上描述，如果要查询innodb存储引擎的表的总行数，有如下建议：</p><ol><li>若仅仅是想获取大概的行数，建议使用<code>show table status</code>或查询<code>information_schema.tables</code>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use db6;</span><br><span class="line">Reading <span class="keyword">table</span> information <span class="keyword">for</span> completion <span class="keyword">of</span> <span class="keyword">table</span> <span class="keyword">and</span> <span class="keyword">column</span> names</span><br><span class="line">You can turn off this feature <span class="keyword">to</span> <span class="keyword">get</span> a quicker startup <span class="keyword">with</span> <span class="operator">-</span>A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_db6 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span> t1            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">table</span> status\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: <span class="number">10</span></span><br><span class="line">     Row_format: <span class="keyword">Dynamic</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">2</span></span><br><span class="line"> Avg_row_length: <span class="number">8192</span></span><br><span class="line">    Data_length: <span class="number">16384</span></span><br><span class="line">Max_data_length: <span class="number">0</span></span><br><span class="line">   Index_length: <span class="number">0</span></span><br><span class="line">      Data_free: <span class="number">0</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="number">2020</span><span class="number">-04</span><span class="number">-21</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">44</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: utf8mb4_general_ci</span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_name <span class="operator">=</span> <span class="string">&#x27;t1&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  TABLE_CATALOG: def</span><br><span class="line">   TABLE_SCHEMA: db6</span><br><span class="line">     TABLE_NAME: t1</span><br><span class="line">     TABLE_TYPE: BASE <span class="keyword">TABLE</span></span><br><span class="line">         ENGINE: InnoDB</span><br><span class="line">        VERSION: <span class="number">10</span></span><br><span class="line">     ROW_FORMAT: <span class="keyword">Dynamic</span></span><br><span class="line">     TABLE_ROWS: <span class="number">2</span></span><br><span class="line"> AVG_ROW_LENGTH: <span class="number">8192</span></span><br><span class="line">    DATA_LENGTH: <span class="number">16384</span></span><br><span class="line">MAX_DATA_LENGTH: <span class="number">0</span></span><br><span class="line">   INDEX_LENGTH: <span class="number">0</span></span><br><span class="line">      DATA_FREE: <span class="number">0</span></span><br><span class="line"> AUTO_INCREMENT: <span class="keyword">NULL</span></span><br><span class="line">    CREATE_TIME: <span class="number">2020</span><span class="number">-04</span><span class="number">-21</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">44</span></span><br><span class="line">    UPDATE_TIME: <span class="keyword">NULL</span></span><br><span class="line">     CHECK_TIME: <span class="keyword">NULL</span></span><br><span class="line">TABLE_COLLATION: utf8mb4_general_ci</span><br><span class="line">       CHECKSUM: <span class="keyword">NULL</span></span><br><span class="line"> CREATE_OPTIONS:</span><br><span class="line">  TABLE_COMMENT:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li>反之，如果必须要获取准确的总行数，建议：<blockquote><ol><li><p>创建一个计数器表，并让您的应用程序按插入和删除操作更新它。</p></li><li><p>若业务插入和删除相对较少，也可以考虑缓存到 redis。</p></li></ol></blockquote></li></ol><p>篇幅有限，深入验证、源码分析将在下一篇文章中介绍。</p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2020-05-05 21:55:15&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/tags/MySQL/"/>
    
    <category term="Select" scheme="http://dbkernel.github.io/tags/Select/"/>
    
    <category term="Count" scheme="http://dbkernel.github.io/tags/Count/"/>
    
  </entry>
  
  <entry>
    <title>特性介绍 | MySQL 自增列详解（1）：自增列概念及使用</title>
    <link href="http://dbkernel.github.io/2019/12/09/mysql-auto_increment-details-01-concepts-and-usage/"/>
    <id>http://dbkernel.github.io/2019/12/09/mysql-auto_increment-details-01-concepts-and-usage/</id>
    <published>2019-12-09T11:37:10.000Z</published>
    <updated>2021-09-24T04:10:26.285Z</updated>
    
    <content type="html"><![CDATA[<p>一直想写一些关于自增列的文章，今天下班比较早，Let’s do this.</p><span id="more"></span><blockquote><p><strong>本文首发于 2019-12-09 19:37:10</strong></p></blockquote><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>自增列，即 AUTO_INCREMENT，可用于为新的记录生成唯一标识。</p><p><strong>要求：</strong></p><ol><li>AUTO_INCREMENT 是数据列的一种属性，只适用于整数类型数据列。</li><li>AUTO_INCREMENT 数据列必须具备 NOT NULL 属性。</li></ol><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h3><h4 id="2-1-创建含自增列的表"><a href="#2-1-创建含自增列的表" class="headerlink" title="2.1. 创建含自增列的表"></a>2.1. 创建含自增列的表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不指定 AUTO_INCREMENT 的值，则从1开始</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t1(a <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,b <span class="type">int</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 手动指定 AUTO_INCREMENT 的值</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t2(a <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,b <span class="type">int</span>) AUTO_INCREMENT<span class="operator">=</span><span class="number">100</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><h4 id="2-2-插入数据"><a href="#2-2-插入数据" class="headerlink" title="2.2. 插入数据"></a>2.2. 插入数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不指定自增列</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(b) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="operator">|</span> a <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定自增列</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="2-3-如何查看表的-AUTO-INCREMENT-涨到了多少？"><a href="#2-3-如何查看表的-AUTO-INCREMENT-涨到了多少？" class="headerlink" title="2.3. 如何查看表的 AUTO_INCREMENT 涨到了多少？"></a>2.3. 如何查看表的 AUTO_INCREMENT 涨到了多少？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="2-4-插入数据时能否有空洞？"><a href="#2-4-插入数据时能否有空洞？" class="headerlink" title="2.4. 插入数据时能否有空洞？"></a>2.4. 插入数据时能否有空洞？</h4><p>可以的，但要注意 <code>AUTO_INCREMENT 的值一定比自增列当前最大的记录值大</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创造空洞</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="operator">|</span> a <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">6</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="2-5-能否插入重复记录"><a href="#2-5-能否插入重复记录" class="headerlink" title="2.5. 能否插入重复记录"></a>2.5. 能否插入重复记录</h4><p>既然自增列是唯一记录，那么肯定不能插入重复记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 尝试插入重复记录</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;5&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-6-怎么修改-AUTO-INCREMENT-的值？"><a href="#2-6-怎么修改-AUTO-INCREMENT-的值？" class="headerlink" title="2.6. 怎么修改 AUTO_INCREMENT 的值？"></a>2.6. 怎么修改 AUTO_INCREMENT 的值？</h4><p><strong>注意</strong>：AUTO_INCREMENT 不能小于当前自增列记录的最大值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 尝试将 AUTO_INCREMENT 设为10</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 AUTO_INCREMENT<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">10</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试将 AUTO_INCREMENT 设为4</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于自增列最大记录值是5，那么 AUTO_INCREMENT 不能小于5，因此该值为6</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">6</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h3><h4 id="3-1-自增列是否有上限？"><a href="#3-1-自增列是否有上限？" class="headerlink" title="3.1. 自增列是否有上限？"></a>3.1. 自增列是否有上限？</h4><p><strong>由上文可见，自增列会一直增加，那是否有上限呢？</strong></p><p>上文中表 t1 的自增列是 int 类型，由下表（MySQL 5.7）可见取值范围是 -2147483648 到 2147483647（ -2<sup>31</sup> ~ 2<sup>31</sup> - 1 ）。</p><table><thead><tr><th>Type</th><th>Storage (Bytes)</th><th>Minimum Value Signed</th><th>Minimum Value Unsigned</th><th>Maximum Value Signed</th><th>Maximum Value Unsigned</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1</td><td>-128</td><td>0</td><td>127</td><td>255</td></tr><tr><td><code>SMALLINT</code></td><td>2</td><td>-32768</td><td>0</td><td>32767</td><td>65535</td></tr><tr><td><code>MEDIUMINT</code></td><td>3</td><td>-8388608</td><td>0</td><td>8388607</td><td>16777215</td></tr><tr><td><code>INT</code></td><td>4</td><td>-2147483648</td><td>0</td><td>2147483647</td><td>4294967295</td></tr><tr><td><code>BIGINT</code></td><td>8</td><td>-2<sup>63</sup></td><td>0</td><td>2<sup>63</sup>-1</td><td>2<sup>64</sup>-1</td></tr></tbody></table><p>验证如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2147483644</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(b) <span class="keyword">values</span>(<span class="number">0</span>),(<span class="number">0</span>),(<span class="number">0</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(b) <span class="keyword">values</span>(<span class="number">0</span>);</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;2147483647&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2147483647</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>这里需要补充说明下 <code>int(11)</code> 中的数字的含义：</p><blockquote><ul><li>MySQL中整数数据类型后面的(N)指定<strong>显示宽度</strong>。</li><li>显示宽度不影响查询出来的结果。</li><li>显示宽度限制了小数点的位置(只要实际数字不超过显示宽度，这种情况下，数字显示为原样)。</li><li>显示宽度也是一个有用的工具，可以让开发人员知道应该将值填充到哪个长度。</li></ul></blockquote><h4 id="3-2-如何避免自增列超过最大值？"><a href="#3-2-如何避免自增列超过最大值？" class="headerlink" title="3.2. 如何避免自增列超过最大值？"></a>3.2. 如何避免自增列超过最大值？</h4><p>可以采用<code>无符号的 BIGINT 类型</code>（也可根据业务产生自增列的速度采用合适的类型），能极大提升自增列的范围。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t2(a <span class="type">bigint</span> unsigned <span class="keyword">primary</span> key auto_increment,b <span class="type">int</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t2 auto_increment<span class="operator">=</span><span class="number">18446744073709551613</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t2;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t2    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `a` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">18446744073709551613</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t2(b) <span class="keyword">values</span>(<span class="number">0</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t2(b) <span class="keyword">values</span>(<span class="number">0</span>);</span><br><span class="line">ERROR <span class="number">1467</span> (HY000): Failed <span class="keyword">to</span> read auto<span class="operator">-</span>increment <span class="keyword">value</span> <span class="keyword">from</span> storage engine</span><br><span class="line">mysql<span class="operator">&gt;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+------+</span></span><br><span class="line"><span class="operator">|</span> a                    <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">18446744073709551613</span> <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong><code>UNSIGNED BIGINT</code> 类型的范围究竟有多大呢？</strong></p><blockquote><p>假如每秒自增100万次，想要消耗完需要 <code>18446744073709551613/1000000/3600/24/365</code>=584942年。</p></blockquote><p><strong>有的朋友会问如果自增列不是采用BIGINT类型，那么达到最大值后该表就无法写入，此时该怎么办呢？</strong></p><blockquote><p>一般达到最大值后再次插入数据会报错<code>ERROR 1467 (HY000): Failed to read auto-increment value from storage engine</code>，可以通过alter table 将自增列的类型设为数值范围更大的类型（比如BIGINT）。</p></blockquote><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol><li>AUTO_INCREMENT 列必定唯一，且仅用于整型类型。</li><li>AUTO_INCREMENT 列会持续增长，不会因 delete 自增列最大的记录而变小。</li><li>当 AUTO_INCREMENT 列达到当前类型的最大值后将无法插入数据，会报错<code>ERROR 1467 (HY000): Failed to read auto-increment value from storage engine</code>，此时将自增列改为 BIGINT 类型可解决问题。</li><li>为了避免自增列达到最大值，可将其设为BIGINT类型。</li><li>使用 alter table 修改 AUTO_INCREMENT 列时，其值会取<code>自增列当前最大记录值+1</code>与<code>将要设置的值</code>的最大值。</li><li>在MySQL 5.7 中，将列设置成 AUTO_INCREMENT 之后，必须将其设置成主键/或者是主键的一部分，否则会报错<code>ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key</code>。</li></ol><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直想写一些关于自增列的文章，今天下班比较早，Let’s do this.&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/tags/MySQL/"/>
    
    <category term="auto_increment" scheme="http://dbkernel.github.io/tags/auto-increment/"/>
    
  </entry>
  
  <entry>
    <title>引擎特性 | MySQL MEMORY(HEAP) 存储引擎导致 Slave 节点有本地事务</title>
    <link href="http://dbkernel.github.io/2019/04/22/mysql-memory-engine-slave-has-local-transactions/"/>
    <id>http://dbkernel.github.io/2019/04/22/mysql-memory-engine-slave-has-local-transactions/</id>
    <published>2019-04-22T12:56:52.000Z</published>
    <updated>2021-09-22T15:24:33.493Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2019-04-22 20:56:52</strong></p></blockquote><h2 id="1-MEMORY-引擎简介"><a href="#1-MEMORY-引擎简介" class="headerlink" title="1. MEMORY 引擎简介"></a>1. MEMORY 引擎简介</h2><p>可能有的朋友对MEMORY存储引擎不太了解，首先介绍一下（以下描述来自<a href="https://dev.mysql.com/doc/refman/5.7/en/memory-storage-engine.html">官方</a>）：</p><ol><li>MEMROY存储引擎（以前称为HEAP）的表<strong>把表结构存放到磁盘上，而把数据放在内存中</strong>。</li><li>每个Memory表只实际对应一个磁盘文件，在磁盘中表现为.frm文件。因为它的数据是放在内存中的，并且默认使用<code>hash索引</code>（也支持B-Tree索引），因此Memory类型的表访问速度非常快（比使用B-Tree索引的MyISAM表快），但是<code>一旦服务关闭，表中的数据就会丢失</code>。</li><li>由于MEMRORY表在mysqld重启后数据会丢失，为了获得稳定的数据源，可以在启动mysqld时添加<code>--init-file</code>选项，把类似<code>insert into ... select</code>或<code>load data</code>的语句放进去。</li><li>MEMROY存储引擎的典型适用场景包含如下特征：<ol><li>涉及瞬态非关键数据的操作，如会话管理或缓存。</li><li>数据可以完全放入内存而不会导致操作系统交换虚拟内存页，并且要求快速访问。</li><li>只读或以读为主的数据访问模式（有限的更新）。</li></ol></li><li>关于性能：<ol><li>在处理更新时，单线程执行和表锁开销导致的争用会限制MEMORY性能。</li><li>尽管MEMORY表在内存中进行处理，但是对于繁忙的服务器、通用查询或读/写工作负载，它们并不一定比InnoDB表快。特别是，执行更新所涉及的表锁定会降低多个会话中内存表的并发使用速度。</li></ol></li><li>MEMORY表具有以下特征：<ol><li>MEMORY表的空间以小块形式分配。表对插入使用100%动态哈希，不需要占用额外的内存。</li><li>被删除的行并未释放，而是放在链表中，并在插入新数据时重用。</li><li>MEMORY表使用固定长度的行存储数据。（即使是VARCHAR也不例外）</li><li>MEMORY表不支持 BLOB、TEXT 列。</li><li>MEMORY表支持 AUTO_INCREMENT 列。</li></ol></li><li>MEMORY表是有大小限制的，主要受限于两个参数：<code> max_heap_table_size</code> 和 <code>MAX_ROWS</code>（默认情况下<code>MAX_ROWS</code>依赖于<code>max_heap_table_size</code>，可执行<code>ALTER TABLE tbl_name MAX_ROWS= MAX_ROWS</code>修改<code>MAX_ROWS</code>）。</li></ol><p><strong>问：MEMORY表和临时表有什么区别？</strong></p><blockquote><ol><li>临时表默认使用的存储引擎是服务器指定的存储引擎（对于5.7是InnoDB），由于临时表定义和数据都放在内存中，未放到磁盘，因此用<code>show tables</code>招不到临时表。</li><li>如果临时表占用空间太大，MySQL会将其转为磁盘存储。而对于用户创建的MEMORY表，则不会转为磁盘存储。</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t1(a <span class="type">int</span> <span class="keyword">primary</span> key, b <span class="type">int</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_db4 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span> t1            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="2-故障分析"><a href="#2-故障分析" class="headerlink" title="2. 故障分析"></a>2. 故障分析</h2><p><strong>现象：</strong></p><p>最近碰到有用户使用 MEMORY 存储引擎，引发主从 GTID 不一致、从节点 GTID 比主节点多一条的情况。</p><p><strong>分析：</strong></p><ol><li>检查日志，确认没有发生过主从切换，也就排除了<code>主节点有 prepare 的事务然后故障（从节点变为主）、重启导致 local commit</code>的情况。</li><li>在从节点 binlog 中找到那条本地事务，发现是 MEMORY 表的 <code>DELETE FROM</code> 。</li><li>该从节点发生过重启，根据 MEMORY 引擎的特性，确认是 MEMORY 表生成的。</li></ol><p>向用户反馈问题原因后，用户将 MEMORY 表改为了 InnoDB 表。</p><h2 id="3-疑问"><a href="#3-疑问" class="headerlink" title="3. 疑问"></a>3. 疑问</h2><h3 id="3-1-何时生成-DELETE-FROM？"><a href="#3-1-何时生成-DELETE-FROM？" class="headerlink" title="3.1. 何时生成 DELETE FROM？"></a>3.1. 何时生成 <code>DELETE FROM</code>？</h3><blockquote><p>A server’s <code>MEMORY</code> tables become empty when it is shut down and restarted. If the server is a replication master, its slaves are not aware that these tables have become empty, so you see out-of-date content if you select data from the tables on the slaves. To synchronize master and slave <code>MEMORY</code> tables, when a <code>MEMORY</code> table is used on a master for the first time since it was started, a <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html"><code>DELETE</code></a> statement is written to the master’s binary log, to empty the table on the slaves also. The slave still has outdated data in the table during the interval between the master’s restart and its first use of the table. To avoid this interval when a direct query to the slave could return stale data, use the <a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_init-file"><code>--init-file</code></a> option to populate the <code>MEMORY</code> table on the master at startup.</p></blockquote><p>这段描述的含义是：</p><blockquote><ol><li>服务器的 MEMORY 表在关闭和重新启动时会变为空。</li><li>为了防止主服务器重启、从服务器未重启导致从服务器上有过期的 MEMORY 表数据，会在重启服务器时向 binlog 写入一条 <code>DELETE FROM</code> 语句，这条语句会复制到从节点，以达到主从数据一致的目的。</li></ol></blockquote><h3 id="3-2-对于主从复制的-MySQL-集群，主或从故障重启有什么问题？"><a href="#3-2-对于主从复制的-MySQL-集群，主或从故障重启有什么问题？" class="headerlink" title="3.2. 对于主从复制的 MySQL 集群，主或从故障重启有什么问题？"></a>3.2. 对于主从复制的 MySQL 集群，主或从故障重启有什么问题？</h3><blockquote><p><strong>PS：不想看过程的朋友，请跳到最后看总结。</strong></p></blockquote><p>举例来说，集群有三个节点A、B、C，节点A为主节点。</p><p><strong>情形一：MEMORY 表有数据的情况下，重启主节点、触发主从切换：</strong></p><ol><li>创建 <code>MEMORY</code> 表 <code>mdb.t1</code> ，执行 <code>insert into mdb.t1 values(1,1),(2,2),(3,3),(4,4)</code> 插入一些数据。</li><li>关闭节点A的 MySQL，节点B变为主，之后节点A以从节点启动，此时：</li></ol><ul><li><p><strong>节点A无数据：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mdb.t1;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><strong>节点B、C有数据：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mdb.t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> a    <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>并且，节点A的 GTID 为 <code>uuid_a:1-11</code>，节点B、C的 GTID 为 <code>uuid_a:1-10</code>，节点A的 binlog 比另外两个节点多一条 <code>DELTE FROM mdb.t1</code>。</p></li></ul><p><strong>情形二：MEMORY 表无数据的情况下，重启主节点、触发主从切换：</strong></p><ol><li>将节点A切换为主节点，节点B、C同步了 <code>uuid_a:1-11</code> 这条事务，三个节点的 <code>mdb.t1</code> 数据为空。</li><li>关闭节点A的 MySQL，节点B变为主，之后节点A以从节点启动，此时，节点A生成了一条本地 <code>DELETE FROM</code> 事务 <code>uuid_b:1-12</code>。</li></ol><p><strong>情形三：MEMORY 表无数据的情况下，重启从节点：</strong></p><ol><li> 将节点A切换为主节点，节点B、C同步了 <code>uuid_a:1-12</code> 这条事务</li><li>重启节点A的MySQL，节点A生成一条本地 <code>DELETE FROM</code> 事务 <code>uuid_a:1-13</code>。</li></ol><p><strong>情形四：MEMORY 表有数据的情况下，重启从节点：</strong></p><ol><li>将节点A切换为主节点，另外两个节点同步节点A的本地事务，三个节点 GTID 为 <code>uuid_a:1-13</code> 。</li><li>执行 <code>INSERT</code> 语句向 <code>mdb.t1</code> 插入一些数据，三个节点 GTID 为 <code>uuid_a:1-14</code>。</li><li>重启节点B，其生成了一条本地 <code>DELETE FROM</code> 事务 <code>uuid_b:1</code>。</li></ol><h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3. 总结"></a>3.3. 总结</h3><ol><li>测试发现，无论什么情况下，MEMORY存储引擎都会生成一条本地 <code>DELETE FROM</code> 事务。</li><li>在某些情况下，必须主动访问（比如 <code>SELECT</code>）MEMORY 表，才会触发生成 <code>DELETE FROM</code>。</li><li>最重要的一点，<code>在生产环境中千万不要使用MEMORY存储引擎</code>。</li></ol><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2019-04-22 20:56:52&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-MEMORY-引擎简介&quot;&gt;&lt;a href=&quot;#1-ME</summary>
      
    
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/tags/MySQL/"/>
    
    <category term="MEMORY引擎" scheme="http://dbkernel.github.io/tags/MEMORY%E5%BC%95%E6%93%8E/"/>
    
    <category term="HEAP引擎" scheme="http://dbkernel.github.io/tags/HEAP%E5%BC%95%E6%93%8E/"/>
    
    <category term="本地事务" scheme="http://dbkernel.github.io/tags/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>特性介绍 | Linux 操作系统启动流程</title>
    <link href="http://dbkernel.github.io/2018/09/16/process-for-starting-the-linux-os/"/>
    <id>http://dbkernel.github.io/2018/09/16/process-for-starting-the-linux-os/</id>
    <published>2018-09-16T13:35:02.000Z</published>
    <updated>2021-09-24T05:23:09.880Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2018-09-16 21:35:02</strong></p></blockquote><h1 id="总启动流程"><a href="#总启动流程" class="headerlink" title="总启动流程"></a>总启动流程</h1><blockquote><p>这部分转自：<a href="https://www.cnblogs.com/liang-io/p/9651656.html">https://www.cnblogs.com/liang-io/p/9651656.html</a></p></blockquote><p>一般来说，所有的操作系统的启动流程基本就是：</p><p><img src="linux-start-process-0-overview.jpg" alt="总启动流程"></p><p>总的来说，linux系统启动流程可以简单总结为以下几步：</p><blockquote><ol><li>开机BIOS自检，加载硬盘。</li><li>读取MBR,进行MBR引导。</li><li>grub引导菜单(Boot Loader)。</li><li>加载内核kernel。</li><li>启动init进程，依据inittab文件设定运行级别</li><li>init进程，执行rc.sysinit文件。</li><li>启动内核模块，执行不同级别的脚本程序。</li><li>执行/etc/rc.d/rc.local</li><li>启动mingetty，进入系统登陆界面。</li></ol></blockquote><p>linux系统安装时，如果要想设置开启启动项，可以：</p><blockquote><p>开机到BIOS提醒界面，按键F11（Dell服务器的做法）进入BIOS设置BOOT MENU，继而设置启动项：硬盘HD启动，光盘CD/DVD启动，还是U盘USB启动。</p></blockquote><h1 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h1><p>下面就linux操作系统的启动过程做一详细解析记录。</p><h2 id="1-加载内核"><a href="#1-加载内核" class="headerlink" title="1. 加载内核"></a>1. 加载内核</h2><p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p><p><img src="linux-start-process-1-load-kernel.jpg" alt="加载内核"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@bastion-IDC ~]# ll /boot/</span><br><span class="line">total 21668</span><br><span class="line">-rw-r--r--. 1 root root   105195 Nov 22  2013 config-2.6.32-431.el6.x86_64</span><br><span class="line">drwxr-xr-x. 3 root root     1024 Aug 22 16:31 efi</span><br><span class="line">drwxr-xr-x. 2 root root     1024 Aug 22 16:32 grub</span><br><span class="line">-rw-------. 1 root root 15217153 Aug 22 16:32 initramfs-2.6.32-431.el6.x86_64.img</span><br><span class="line">drwx------. 2 root root    12288 Aug 22 16:24 lost+found</span><br><span class="line">-rw-r--r--. 1 root root   193758 Nov 22  2013 symvers-2.6.32-431.el6.x86_64.gz</span><br><span class="line">-rw-r--r--. 1 root root  2518236 Nov 22  2013 System.map-2.6.32-431.el6.x86_64</span><br><span class="line">-rwxr-xr-x. 1 root root  4128368 Nov 22  2013 vmlinuz-2.6.32-431.el6.x86_64</span><br></pre></td></tr></table></figure><h2 id="2-启动初始化进程"><a href="#2-启动初始化进程" class="headerlink" title="2. 启动初始化进程"></a>2. 启动初始化进程</h2><p>内核文件加载以后，就开始运行第一个程序 /sbin/init，它的作用是初始化系统环境。</p><p><img src="linux-start-process-2-start-init.jpg" alt="启动初始化进程"></p><p>由于init是第一个运行的程序，它的进程编号（pid）就是1。其他所有进程都从它衍生，都是它的子进程。</p><h2 id="3-确定运行级别"><a href="#3-确定运行级别" class="headerlink" title="3. 确定运行级别"></a>3. 确定运行级别</h2><p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>init进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p><p><img src="linux-start-process-3-run-level.jpg" alt="确定运行级别"></p><p>Linux预置七种init运行级别（0-6）：</p><blockquote><p>0：关机模式    （相当于poweroff）</p><p>1：单用户模式</p><p>2：无网络支持的多用户模式</p><p>3：有网络支持的多用户模式（也就是文本模式，工作中最常用的模式）</p><p>4：保留，未使用</p><p>5：有网络支持的X-windows支持多用户模式（也就是桌面图形模式）</p><p>6: 重新引导系统，即重启（相当于reboot）</p></blockquote><p>init进程首先读取文件 <code>/etc/inittab</code>，它是运行级别的设置文件。<br>如果打开它，可以看到第一行是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bastion-IDC ~]# cat /etc/inittab</span><br><span class="line">....</span><br><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure><p>initdefault的值是3，表明系统启动时的运行级别为3。如果需要指定其他级别，可以手动修改这个值。</p><p><strong>那么，运行级别3有哪些程序呢，系统怎么知道每个级别应该加载哪些程序呢？</strong></p><p>答案是每个运行级别在/etc目录下面，都有一个对应的子目录，指定要加载的程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc0.d</span><br><span class="line">/etc/rc1.d</span><br><span class="line">/etc/rc2.d</span><br><span class="line">/etc/rc3.d</span><br><span class="line">/etc/rc4.d</span><br><span class="line">/etc/rc5.d</span><br><span class="line">/etc/rc6.d</span><br></pre></td></tr></table></figure><p>上面目录名中的”rc”，表示<code>run command（运行程序）</code>，最后的d表示<code>directory（目录）</code>。下面让我们看看 /etc/rc3.d 目录中到底指定了哪些程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@bastion-IDC ~]# ll /etc/rc3.d/</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx. 1 root root 19 Aug 22 16:30 K10saslauthd -&gt; ../init.d/saslauthd</span><br><span class="line">lrwxrwxrwx. 1 root root 18 Aug 22 16:47 K15svnserve -&gt; ../init.d/svnserve</span><br><span class="line">lrwxrwxrwx. 1 root root 15 Aug 23 16:21 K25squid -&gt; ../init.d/squid</span><br><span class="line">lrwxrwxrwx. 1 root root 19 Dec 23 13:14 K45memcached -&gt; ../init.d/memcached</span><br><span class="line">lrwxrwxrwx. 1 root root 20 Aug 22 16:30 K50netconsole -&gt; ../init.d/netconsole</span><br><span class="line">lrwxrwxrwx. 1 root root 13 Dec 21 17:45 K60nfs -&gt; ../init.d/nfs</span><br><span class="line">lrwxrwxrwx. 1 root root 20 Dec 21 17:45 K69rpcsvcgssd -&gt; ../init.d/rpcsvcgssd</span><br><span class="line">lrwxrwxrwx. 1 root root 17 Nov 24 14:45 K75ntpdate -&gt; ../init.d/ntpdate</span><br><span class="line">lrwxrwxrwx. 1 root root 20 Aug 22 16:31 K87multipathd -&gt; ../init.d/multipathd</span><br><span class="line">lrwxrwxrwx. 1 root root 21 Aug 22 16:30 K87restorecond -&gt; ../init.d/restorecond</span><br><span class="line">lrwxrwxrwx. 1 root root 15 Aug 22 16:30 K89rdisc -&gt; ../init.d/rdisc</span><br><span class="line">lrwxrwxrwx. 1 root root 22 Aug 22 16:31 S02lvm2-monitor -&gt; ../init.d/lvm2-monitor</span><br><span class="line">lrwxrwxrwx. 1 root root 16 Aug 22 16:31 S07iscsid -&gt; ../init.d/iscsid</span><br><span class="line">lrwxrwxrwx. 1 root root 19 Aug 22 16:30 S08ip6tables -&gt; ../init.d/ip6tables</span><br><span class="line">lrwxrwxrwx. 1 root root 18 Aug 22 16:30 S08iptables -&gt; ../init.d/iptables</span><br><span class="line">lrwxrwxrwx. 1 root root 17 Aug 22 16:30 S10network -&gt; ../init.d/network</span><br><span class="line">lrwxrwxrwx. 1 root root 16 Aug 22 16:31 S11auditd -&gt; ../init.d/auditd</span><br><span class="line">lrwxrwxrwx. 1 root root 17 Aug 22 16:30 S12rsyslog -&gt; ../init.d/rsyslog</span><br><span class="line">lrwxrwxrwx. 1 root root 15 Dec 21 17:45 S13iscsi -&gt; ../init.d/iscsi</span><br><span class="line">lrwxrwxrwx. 1 root root 17 Dec 21 17:45 S13rpcbind -&gt; ../init.d/rpcbind</span><br><span class="line">lrwxrwxrwx. 1 root root 17 Dec 21 17:45 S14nfslock -&gt; ../init.d/nfslock</span><br><span class="line">lrwxrwxrwx. 1 root root 19 Aug 22 16:31 S15mdmonitor -&gt; ../init.d/mdmonitor</span><br><span class="line">lrwxrwxrwx. 1 root root 17 Dec 21 17:45 S19rpcgssd -&gt; ../init.d/rpcgssd</span><br><span class="line">lrwxrwxrwx. 1 root root 26 Aug 22 16:31 S25blk-availability -&gt; ../init.d/blk-availability</span><br><span class="line">lrwxrwxrwx. 1 root root 15 Aug 22 16:30 S25netfs -&gt; ../init.d/netfs</span><br><span class="line">lrwxrwxrwx. 1 root root 19 Aug 22 16:30 S26udev-post -&gt; ../init.d/udev-post</span><br><span class="line">lrwxrwxrwx. 1 root root 18 Oct 25 11:49 S50onealert -&gt; ../init.d/onealert</span><br><span class="line">lrwxrwxrwx. 1 root root 14 Aug 22 16:31 S55sshd -&gt; ../init.d/sshd</span><br><span class="line">lrwxrwxrwx. 1 root root 16 Oct 26 09:47 S56xinetd -&gt; ../init.d/xinetd</span><br><span class="line">lrwxrwxrwx. 1 root root 17 Aug 22 16:30 S80postfix -&gt; ../init.d/postfix</span><br><span class="line">lrwxrwxrwx. 1 root root 15 Aug 22 16:30 S90crond -&gt; ../init.d/crond</span><br><span class="line">lrwxrwxrwx. 1 root root 11 Aug 22 16:30 S99local -&gt; ../rc.local</span><br></pre></td></tr></table></figure><p>可以看到：</p><blockquote><p><code>字母S表示Start</code>，也就是启动的意思（启动脚本的运行参数为start）。</p><p>如果这个位置是<code>字母K</code>，就代表<code>Kill（关闭）</code>，即<strong>如果从其他运行级别切换过来，需要关闭的程序（启动脚本的运行参数为stop）</strong>。</p><p>后面的两位数字表示<code>处理顺序</code>，<strong>数字越小越早处理</strong>，所以第一个启动的程序是motd，然后是rpcbing、nfs……数字相同时，则按照程序名的字母顺序启动，所以rsyslog会先于sudo启动。</p><p>这个目录里的所有文件（除了README），就是启动时要加载的程序。如果想增加或删除某些程序，不建议手动修改 /etc/rcN.d 目录，最好是用一些专门命令进行管理（参考这里和这里）。</p></blockquote><h2 id="4-加载开机启动程序"><a href="#4-加载开机启动程序" class="headerlink" title="4. 加载开机启动程序"></a>4. 加载开机启动程序</h2><p>前面提到，七种预设的”运行级别”各自有一个目录，存放需要开机启动的程序。不难想到，如果多个”运行级别”需要启动同一个程序，那么这个程序的启动脚本，就会在每一个目录里都有一个拷贝。这样会造成管理上的困扰：如果要修改启动脚本，岂不是每个目录都要改一遍？</p><p>Linux的解决办法，就是七个 <code>/etc/rcN.d</code> 目录里列出的程序，都设为链接文件，指向另外一个目录 <code>/etc/init.d</code>，真正的启动脚本都统一放在这个目录中。init进程逐一加载开机启动程序，其实就是运行这个目录里的启动脚本。</p><p><img src="linux-start-process-4-initd.jpg" alt="加载开机启动程序"></p><p>下面就是链接文件真正的指向：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bastion-IDC ~]# ls -l /etc/rc3.d</span><br><span class="line">lrwxrwxrwx. 1 root root 10 Aug 22 16:30 /etc/rc3.d -&gt; rc.d/rc3.d</span><br></pre></td></tr></table></figure><p>这样做的另一个好处，就是如果你要手动关闭或重启某个进程，直接到目录 /etc/init.d 中寻找启动脚本即可。</p><p>比如，我要重启iptables服务器，就运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@bastion-IDC ~]# /etc/init.d/iptables restart</span><br></pre></td></tr></table></figure><p>/etc/init.d 这个目录名最后一个字母d，是directory的意思，表示这是一个目录，用来与程序 /etc/init 区分。</p><h2 id="5-用户登录"><a href="#5-用户登录" class="headerlink" title="5. 用户登录"></a>5. 用户登录</h2><p>开机启动程序加载完毕以后，就要让用户登录了。</p><p><img src="linux-start-process-5-user-login.jpg" alt="用户登录"></p><p>一般来说，用户的登录方式有三种：命令行登录、ssh登录、图形界面登录。这三种情况，都有自己的方式对用户进行认证。</p><blockquote><p>1）<strong>命令行登录</strong>：init进程调用getty程序（意为get teletype），让用户输入用户名和密码。输入完成后，再调用login程序，核对密码（Debian还会再多运行一个身份核对程序/etc/pam.d/login）。如果密码正确，就从文件 /etc/passwd 读取该用户指定的shell，然后启动这个shell。</p><p>2）<strong>ssh登录</strong>：这时系统调用sshd程序（Debian还会再运行/etc/pam.d/ssh ），取代getty和login，然后启动shell。</p><p>3）<strong>图形界面登录</strong>：init进程调用显示管理器，Gnome图形界面对应的显示管理器为gdm（GNOME Display Manager），然后用户输入用户名和密码。如果密码正确，就读取/etc/gdm3/Xsession，启动用户的会话。</p></blockquote><h2 id="6-进入-login-shell"><a href="#6-进入-login-shell" class="headerlink" title="6. 进入 login shell"></a>6. 进入 login shell</h2><p>所谓shell，简单说就是命令行界面，让用户可以直接与操作系统对话。用户登录时打开的shell，就叫做login shell。</p><p><img src="linux-start-process-6-login-shell.jpg" alt="进入 login shell"></p><p>Linux默认的shell是Bash，它会读入一系列的配置文件。上一步的三种情况，在这一步的处理，也存在差异。</p><ol><li><p><strong>命令行登录</strong>：首先读入 <code>/etc/profile</code>，这是对所有用户都有效的配置；然后依次寻找下面三个文件，这是针对当前用户的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.bash_profile</span><br><span class="line">~/.bash_login</span><br><span class="line">~/.profile</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，<strong>这三个文件只要有一个存在，就不再读入后面的文件了</strong>。比如，要是 <code>~/.bash_profile</code> 存在，就不会再读入后面两个文件了。</p></blockquote></li><li><p><strong>ssh登录</strong>：与第一种情况完全相同。</p></li><li><p><strong>图形界面登录</strong>：只加载 <code>/etc/profile</code> 和 <code>~/.profile</code>。也就是说，<code>~/.bash_profile</code> 不管有没有，都不会运行。</p></li></ol><h2 id="7-打开-non-login-shell"><a href="#7-打开-non-login-shell" class="headerlink" title="7. 打开 non-login shell"></a>7. 打开 non-login shell</h2><p>老实说，上一步完成以后，Linux的启动过程就算结束了，用户已经可以看到命令行提示符或者图形界面了。但是，为了内容的完整，必须再介绍一下这一步。</p><p>用户进入操作系统以后，常常会再手动开启一个shell。这个shell就叫做 <code>non-login shell</code>，意思是它不同于登录时出现的那个shell，不读取<code>/etc/profile</code>和<code>.profile</code>等配置文件。</p><p><img src="linux-start-process-7-non-login-shell.jpg" alt="打开 non-login shell"></p><p>non-login shell的重要性，不仅在于它是用户最常接触的那个shell，还在于它会读入用户自己的bash配置文件 <code>~/.bashrc</code>。大多数时候，我们对于bash的定制，都是写在这个文件里面的。</p><p>你也许会问，<strong>要是不进入 non-login shell，岂不是.bashrc就不会运行了，因此bash 也就不能完成定制了？</strong></p><p>事实上，Debian已经考虑到这个问题了，请打开文件 <code>~/.profile</code>，可以看到下面的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$BASH_VERSION</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">　　<span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$HOME</span>/.bashrc&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">　　　　. <span class="string">&quot;<span class="variable">$HOME</span>/.bashrc&quot;</span></span><br><span class="line">　　<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>上面代码先判断变量 <code>$BASH_VERSION</code> 是否有值，然后判断主目录下是否存在 .bashrc 文件，如果存在就运行该文件。</p><p>第三行开头的那个点，是source命令的简写形式，表示运行某个文件，写成”source ~/.bashrc”也是可以的。</p><p>因此，只要运行<code>～/.profile</code>文件，<code>～/.bashrc</code>文件就会连带运行。但是上一节的第一种情况提到过，如果存在<code>～/.bash_profile</code>文件，那么有可能不会运行<code>～/.profile</code>文件。解决这个问题很简单，把下面代码写入<code>.bash_profile</code>就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f ~/.profile ]; <span class="keyword">then</span></span><br><span class="line">　　. ~/.profile</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这样一来，不管是哪种情况，<code>.bashrc</code>都会执行，用户的设置可以放心地都写入这个文件了。</p><p>Bash的设置之所以如此繁琐，是由于历史原因造成的。早期的时候，计算机运行速度很慢，载入配置文件需要很长时间，Bash的作者只好把配置文件分成了几个部分，阶段性载入。<strong>系统的通用设置放在 /etc/profile，用户个人的、需要被所有子进程继承的设置放在.profile，不需要被继承的设置放在.bashrc。</strong></p><p>顺便提一下，除了Linux以外， Mac OS X 使用的shell也是Bash。但是，它只加载.bash_profile，然后在.bash_profile里面调用.bashrc。而且，不管是ssh登录，还是在图形界面里启动shell窗口，都是如此。</p><h1 id="附：启动流程的思维导图"><a href="#附：启动流程的思维导图" class="headerlink" title="附：启动流程的思维导图"></a>附：启动流程的思维导图</h1><blockquote><p>图片转自：<a href="https://mm.edrawsoft.cn/template/12597">https://mm.edrawsoft.cn/template/12597</a></p></blockquote><p><img src="linux-start-process-mind-mapping.jpg" alt="Linux启动流程思维导图"></p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2018-09-16 21:35:02&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;总启动流程&quot;&gt;&lt;a href=&quot;#总启动流程&quot; class=</summary>
      
    
    
    
    <category term="Linux" scheme="http://dbkernel.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://dbkernel.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>实用工具 | Linux 定时任务 crontab 命令详解</title>
    <link href="http://dbkernel.github.io/2016/11/23/description-of-the-crontab-command/"/>
    <id>http://dbkernel.github.io/2016/11/23/description-of-the-crontab-command/</id>
    <published>2016-11-23T02:24:45.000Z</published>
    <updated>2021-09-24T04:03:03.936Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2016-11-23 10:24:45</strong></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux 下的任务调度分为两类：<strong>系统任务调度</strong>和<strong>用户任务调度</strong>。Linux 系统任务是由 <code>cron (crond)</code> 这个系统服务来控制的，这个系统服务是默认启动的。用户自己设置的计划任务则使用 <code>crontab</code> 命令。</p><h2 id="cron-配置文件"><a href="#cron-配置文件" class="headerlink" title="cron 配置文件"></a>cron 配置文件</h2><p>在 Ubuntu/Debian 中，配置文件路径为 <code>/etc/crontab</code>（CentOS也类似），其内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="comment"># Unlike any other crontab you don&#x27;t have to run the `crontab&#x27;</span></span><br><span class="line"><span class="comment"># command to install the new version when you edit this file</span></span><br><span class="line"><span class="comment"># and files in /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="comment"># that none of the other crontabs do.</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br><span class="line">17 ** * *root    <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6* * *root<span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.daily )</span><br><span class="line">47 6* * 7root<span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.weekly )</span><br><span class="line">52 61 * *root<span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.monthly )</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li><code>SHELL</code> 环境变量用于指定系统要使用的shell，此处为<code>/bin/sh</code>。</li><li><code>PATH</code> 环境变量指定了系统执行命令的路径。</li><li>也可以添加<code>MAILTO</code>变量，如果指定，则表示 crond 的任务执行信息将通过电子邮件发送给指定的用户。</li><li>其他部分在后文详细讲述。</li></ul><p>用户定期要执行的工作，比如用户数据备份、定时邮件提醒等，都可以使用 crontab 工具来定制自己的计划任务。所有<code>非root用户</code>定义的 crontab 文件都被保存在 <code>/var/spool/cron</code> 目录中，其文件名与用户名一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /var/spool/cron/crontabs/admin</span><br></pre></td></tr></table></figure><p>除此之外，还有两个文件<code>/etc/cron.deny</code>和<code>/etc/cron.allow</code>，前者中可列出不允许哪些用户使用 crontab 命令，后者中可列出允许哪些用户使用 crontab 命令。</p><h2 id="crontab-文件含义"><a href="#crontab-文件含义" class="headerlink" title="crontab 文件含义"></a>crontab 文件含义</h2><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute hour day month week <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>各字段含义如下：</p><ul><li>minute：表示分钟，可以是从0到59之间的任何整数。</li><li>hour：表示小时，可以是从0到23之间的任何整数。</li><li>day：表示日期，可以是从1到31之间的任何整数。</li><li>month：表示月份，可以是从1到12之间的任何整数。</li><li>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</li><li>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</li></ul><p>在以上各个字段中，还可以使用以下特殊字符：</p><ul><li><code>星号(*)</code>：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</li><li><code>逗号(,)</code>：可以用逗号隔开的值指定一个列表范围，例如：<code>1,2,5,7,8,9</code> 。</li><li><code>中杠(-)</code>：可以用整数之间的中杠表示一个整数范围，例如：<code>2-6</code> 表示<code>2,3,4,5,6</code> 。</li><li><code>正斜线(/)</code>：可以用正斜线指定时间的间隔频率，例如：<code>0-23/2</code>表示每两小时执行一次。同时正斜线可以和星号一起使用，例如：<code>*/10</code>，如果用在minute字段，表示<strong>每十分钟执行一次</strong>。</li></ul><h2 id="crontab命令详解"><a href="#crontab命令详解" class="headerlink" title="crontab命令详解"></a>crontab命令详解</h2><p><strong>命令格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">usage:crontab [-u user] file</span><br><span class="line">crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125;</span><br><span class="line">(default operation is replace, per 1003.2)</span><br><span class="line">-e(edit user<span class="string">&#x27;s crontab)</span></span><br><span class="line"><span class="string">-l(list user&#x27;</span>s crontab)</span><br><span class="line">-r(delete user<span class="string">&#x27;s crontab)</span></span><br><span class="line"><span class="string">-i(prompt before deleting user&#x27;</span>s crontab)</span><br></pre></td></tr></table></figure><ul><li>-u user：用于设定某个用户的crontab服务。</li><li>file: file 为命令文件名，表示将 file 作为 crontab 的任务列表文件并载入 crontab ；如果在命令行中没有指定这个文件，crontab 命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab 。</li><li>-e：编辑某个用户的 crontab 文件内容，如不指定用户则表示当前用户。</li><li>-l：显示某个用户的 crontab 文件内容，如不指定用户则表示当前用户。</li><li>-r：从 /var/spool/cron 目录中删除某个用户的crontab文件，如不指定用户，则默认删除当前用户 crontab 文件。</li><li>-i：在删除用户的 crontab 文件时给确认提示。</li></ul><h2 id="crontab-注意事项"><a href="#crontab-注意事项" class="headerlink" title="crontab 注意事项"></a>crontab 注意事项</h2><ol><li>crontab有2种编辑方式：<strong>直接编辑/etc/crontab文件</strong>与<strong>crontab –e</strong>，其中<code>/etc/crontab</code>里的计划任务是<strong>系统的计划任务</strong>，而<strong>用户的计划任务</strong>需要通过<code>crontab –e</code>来编辑。</li><li>每次编辑完某个用户的 cron 设置后，cron 自动在 /var/spool/cron 下生成一个与此用户同名的文件，此用户的 cron 信息都记录在这个文件中，<code>这个文件是不可以直接编辑的，只可以用 crontab -e 来编辑</code>。</li><li>crontab 中的 command 尽量使用绝对路径，否则会经常因为路径错误导致任务无法执行。</li><li>新创建的 cron job 不会马上执行，至少要等2分钟才能执行，可重启 cron 来立即执行。</li><li><code>%</code> 在crontab文件中表示<code>换行</code>，因此假如脚本或命令含有<code>%</code>，需要使用<code>\%</code>来进行转义。</li><li><code>crontab -e</code>的默认编辑器是 nano ，如需使用 vim，可在<code>/etc/profile</code>或<code>~/.bashrc</code>中添加 <code>export EDITOR=vi</code> 来解决。</li></ol><h2 id="crontab-配置示例"><a href="#crontab-配置示例" class="headerlink" title="crontab 配置示例"></a>crontab 配置示例</h2><ul><li><p>每分钟执行1次 command（因cron默认每1分钟扫描一次，因此全为<code>*</code>即可）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每小时的第3和第15分钟执行 command ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 * * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每天上午8-11点的第3和15分钟执行 command ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每隔2天的上午8-11点的第3和15分钟执行 command ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 */2 * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每个星期一的上午8点到11点的第3和第15分钟执行 command ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每晚的21:30分重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每月1、10、22日的 4:45 重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每周六、周日的 1:10 重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每天 18:00 至 23:00 之间每隔30分钟重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每隔1小时重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>晚上23点到早上7点之间，每隔1小时重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 23-7/1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每月的4号与每周一到周三的11点重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 11 4 * mon-wed /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每小时执行<code>/etc/cron.hourly</code>目录内的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 * * * root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure></li></ul><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2016-11-23 10:24:45&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Linux" scheme="http://dbkernel.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://dbkernel.github.io/tags/Linux/"/>
    
    <category term="crontab" scheme="http://dbkernel.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>特性分析 | GreenPlum 的并行查询优化策略详解</title>
    <link href="http://dbkernel.github.io/2016/11/21/greenplum-parallel-query-optimization-strategy/"/>
    <id>http://dbkernel.github.io/2016/11/21/greenplum-parallel-query-optimization-strategy/</id>
    <published>2016-11-21T01:43:07.000Z</published>
    <updated>2021-09-24T04:06:27.294Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2016-11-21 09:43:07</strong></p></blockquote><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>GreenPlum 采用 Share Nothing 的架构，良好的发挥了廉价PC的作用。自此I/O不在是 DW(data warehouse) 的瓶颈，相反网络的压力会大很多。但是 GreenPlum 的查询优化策略能够避免尽量少的网络交换。对于初次接触 GreenPlum 的人来说，肯定耳目一新。</p><p><img src="greenplum-architecture.jpg" alt="GreenPlum 架构"></p><h1 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h1><p>GreenPlum 的 master 节点负责 SQL 解析和执行计划的生成，具体来说，查询优化器会将 SQL 解析成每个节点（segments）要执行的物理执行计划。</p><p>GreenPlum 采用的是基于成本的优化策略：如果有多条执行路径，会评估执行代价，找出代价最小、最有效率的一条。</p><p>不像传统的查询优化器，GreenPlum 的查询优化器必须全局的考虑整个集群，在每个候选的执行计划中考虑到节点间移动数据的开销。比如有 join，那么 join 是在各个节点分别进行的（每个节点只和自身数据做 join），所以它的查询很快。</p><p>查询计划包括了一些传统的操作，比如：扫描、Join、排序、聚合等等。</p><p><strong>GreenPlum 中有三种数据的移动操作：</strong></p><ul><li><code>Broadcast Motion (N:N)</code>：广播数据。每个节点向其他节点广播需要发送的数据。</li><li><code>Redistribute Motion (N:N)</code>：重新分布数据。利用 join 列数据的 hash 值不同，将筛选后的数据在其他 segment 重新分布。</li><li><code>Gather Motion (N:1)</code>：聚合汇总数据。每个节点将 join 后的数据发到一个单节点上，通常是发到主节点 master 。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> d.<span class="operator">*</span>,j.customer_id <span class="keyword">from</span> data d <span class="keyword">join</span>  jd1 j <span class="keyword">on</span> d.partner_id<span class="operator">=</span>j.partner_id <span class="keyword">where</span> j.gmt_modified<span class="operator">&gt;</span> <span class="built_in">current_date</span> <span class="number">-80</span>;</span><br><span class="line">                                       QUERY PLAN</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------</span></span><br><span class="line"> Gather Motion <span class="number">88</span>:<span class="number">1</span>  (slice2)  (cost<span class="operator">=</span><span class="number">3.01</span>.<span class="number">.939</span><span class="number">.49</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2717</span> width<span class="operator">=</span><span class="number">59</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">3.01</span>.<span class="number">.939</span><span class="number">.49</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2717</span> width<span class="operator">=</span><span class="number">59</span>)</span><br><span class="line">         Hash Cond: d.partner_id::text <span class="operator">=</span> j.partner_id::text</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> data d  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.260</span><span class="number">.74</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">20374</span> width<span class="operator">=</span><span class="number">50</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">1.91</span>.<span class="number">.1</span><span class="number">.91</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">88</span> width<span class="operator">=</span><span class="number">26</span>)</span><br><span class="line">               <span class="operator">-</span><span class="operator">&gt;</span>  Broadcast Motion <span class="number">88</span>:<span class="number">88</span>  (slice1)  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.91</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">88</span> width<span class="operator">=</span><span class="number">26</span>)</span><br><span class="line">                     <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> jd1 j  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">26</span>)</span><br><span class="line">                           <span class="keyword">Filter</span>: gmt_modified <span class="operator">&gt;</span> (<span class="string">&#x27;now&#x27;</span>::text::<span class="type">date</span> <span class="operator">-</span> <span class="number">80</span>)</span><br></pre></td></tr></table></figure><p><strong>执行计划需要自下而上分析：</strong></p><ol><li>在各个节点扫描自己的 <code>jd1</code> 表数据，按照条件过滤生成数据（记为 <code>rs</code>）。</li><li>各节点将自己生成的 <code>rs</code> 依次发送到其他节点。（<code>Broadcast Motion (N:N)</code>）</li><li>每个节点上的 <code>data</code> 表的数据，和各自节点上收到的 <code>rs</code> 进行 join，这样能保证本机数据只和本机数据做 join 。</li><li>各节点将 join 后的结果发送给 master(<code>Gather Motion (N:1)</code>) 。</li></ol><p>由上面的执行过程可以看出， GreenPlum 将 rs 给每个含有 data 表数据的节点都发了一份。</p><p><strong>问：如果 <code>rs</code> 很大或者压根就没有过滤条件，会有什么问题？如何处理？</strong></p><p>比如本例中的表 <code>jd1</code> 和表<code>data</code>的数据行数如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> jd1;</span><br><span class="line"> count</span><br><span class="line"><span class="comment">-------</span></span><br><span class="line">    <span class="number">20</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> data;</span><br><span class="line"> count</span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"> <span class="number">113367</span></span><br></pre></td></tr></table></figure><p>如果 <code>rs</code> 很大的话，广播数据时网络就会成为瓶颈。GreenPlum 的优化器很聪明，它是将<strong>小表</strong>广播到各个 segment 上，极大的降低网络开销。从这个例子能看出统计信息对于生成好的查询计划是何等重要。</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>下面看一个复杂点的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    c_custkey, c_name,</span><br><span class="line">    <span class="built_in">sum</span>(l_extendedprice <span class="operator">*</span> (<span class="number">1</span> <span class="operator">-</span> <span class="number">1</span>_discount)) <span class="keyword">as</span> revenue,</span><br><span class="line">    c_acctbal, n_name, c_address, c_phone, c_comment</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    customer, orders, lineitem, nation</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    c_custkey <span class="operator">=</span> o_custkey</span><br><span class="line"><span class="keyword">and</span> <span class="number">1</span>_orderkey <span class="operator">=</span> o_orderkey</span><br><span class="line"><span class="keyword">and</span> o_orderdate <span class="operator">&gt;=</span> <span class="type">date</span> <span class="string">&#x27;1994-08-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> o_orderdate <span class="operator">&lt;</span> <span class="type">date</span> <span class="string">&#x27;1994-08-0l&#x27;</span></span><br><span class="line">                  <span class="operator">+</span> <span class="type">interval</span> <span class="string">&#x27;3 month&#x27;</span></span><br><span class="line"><span class="keyword">and</span> l_returnflag <span class="operator">=</span> <span class="string">&#x27;R&#x27;</span></span><br><span class="line"><span class="keyword">and</span> c_nationkey <span class="operator">=</span> n_nationkey</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    c_custkey, c_name, c_acctbal,</span><br><span class="line">    c_phone, n_name, c_address, c_comment</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">    revenue <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>执行计划如下：</p><p><img src="greenplum-hashjoin-plan.jpeg" alt="GreenPlum HashJoin 执行计划"></p><ol><li>各个节点上同时扫描各自的 nation 表数据，将各 segment 上的 nation 数据向其他节点广播（<code>Broadcast Motion (N:N)</code>）。</li><li>各个节点上同时扫描各自 customer 数据，和收到的 nation 数据 join 生成<code>RS-CN</code> 。</li><li>各个 segment 同时扫描自己 orders 表数据，过滤数据生成 <code>RS-O</code> 。</li><li>各个 segment 同时扫描自己 lineitem 表数据，过滤生成 <code>RS-L</code> 。</li><li>各个 segment 同时将各自 <code>RS-O</code> 和 <code>RS-L</code> 进行 join，生成<code>RS-OL</code>。注意此过程不需要 <code>Redistribute Motion (N:N)</code> 重新分布数据，因为 orders 和 lineitem 的 distribute column 都是orderkey，这就保证了各自需要 join 的对象都是在各自的机器上，所以 n 个节点就开始并行 join 了。</li><li>各个节点将自己在步骤5生成的 <code>RS-OL</code> 按照 cust-key 在所有节点间重新分布数据（<code>Redistribute Motion (N:N)</code>，可以按照 hash 和 range 在节点间来重新分布数据，默认是 hash），这样每个节点都会有自己的 <code>RS-OL</code> 。</li><li>各个节点将自己在步骤2生成的 <code>RS-CN</code> 和自己节点上的 <code>RS-OL</code> 数据进行 join，又是本机只和本机的数据进行 join 。</li><li>聚合，排序，发往主节点 master 。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>Greenplum如何处理和优化一张大表和小表的join?</strong></p><blockquote><p>Greenplum是选择将小表广播数据，而不是将大表广播。</p></blockquote><p><strong>举例说明：</strong></p><p>表 A 有10亿条数据（<code>empno&lt;pk&gt;,deptno,ename</code>），表 B 有500条数据（<code>deptno&lt;pk&gt;,dname,loc</code>）</p><p>表 A 与表 B join on deptno</p><p>集群有11个节点：1个 master，10个 segment</p><p>按照正常的主键列 hash 分布，每个 segment 节点上只会有 1/10 的表 A 和 1/10 的表 B。</p><p>此时 GreenPlum 会<strong>让所有节点给其他节点发送各自所拥有的小表 B 的1/10的数据</strong>，这样就保证了10个节点上，每个节点都有一份完整的表 B 的数据。此时，每个节点上1/10的 A 只需要和自己节点上的 B 进行 join 就OK。所以 GreenPlum 并行处理能力惊人的原因就在这里。</p><p>最终所有节点会将 join 的结果都发给主节点 master。</p><p>由该例可见统计信息十分重要，GreenPlum 通过统计信息来确定将哪张表进行（<code>Broadcast Motion (N:N)</code>）。</p><p>另外，实际使用中还会出现<strong>列值倾斜</strong>的情况，比如 A 没有按照主键来 hash 分布，而是人为指定按照 deptno 的 hash 在各个节点上分布数据。若 A 中80%的数据都是sales（deptno=10）部门的，此时10个节点中，就会有一个节点上拥有了 10亿×80% 的数据，就算是将表 B 广播到其他节点 也无济于事，因为<strong>计算的压力都集中在一台机器</strong>了。所以，<strong>必须选择合适的列进行hash分布</strong>。</p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2016-11-21 09:43:07&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="GreenPlum" scheme="http://dbkernel.github.io/categories/GreenPlum/"/>
    
    
    <category term="PostgreSQL" scheme="http://dbkernel.github.io/tags/PostgreSQL/"/>
    
    <category term="GreenPlum" scheme="http://dbkernel.github.io/tags/GreenPlum/"/>
    
    <category term="并行查询" scheme="http://dbkernel.github.io/tags/%E5%B9%B6%E8%A1%8C%E6%9F%A5%E8%AF%A2/"/>
    
    <category term="优化器" scheme="http://dbkernel.github.io/tags/%E4%BC%98%E5%8C%96%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>问题定位 | PostgreSQL 报错 requested WAL segment has already been removed</title>
    <link href="http://dbkernel.github.io/2016/04/25/postgresql-error-wal-segment-has-already-been-removed/"/>
    <id>http://dbkernel.github.io/2016/04/25/postgresql-error-wal-segment-has-already-been-removed/</id>
    <published>2016-04-25T12:59:52.000Z</published>
    <updated>2021-09-22T15:24:33.122Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2016-04-25 20:59:52</strong></p></blockquote><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用配置了热备的 PostgreSQL 数据库时，在执行大量事务时，尤其是一个需要插入几千万条数据的 insert 事务时（典型的做法是持续 <code>insert into t select * from t;</code>），后台 csv log 中报错如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">01</span> <span class="number">13</span>:<span class="number">25</span>:<span class="number">29</span><span class="variable">.430</span> CST,,,<span class="number">27738</span>,,<span class="number">51</span>d112c8<span class="variable">.6c5a</span>,<span class="number">1</span>,,<span class="number">2015</span>-<span class="number">07</span>-<span class="number">01</span> <span class="number">13</span>:<span class="number">25</span>:<span class="number">28</span> CST,,<span class="number">0</span>,LOG,<span class="number">00000</span>,<span class="string">&quot;streaming replication successfully connected to primary&quot;</span>,,,,,,,,<span class="string">&quot;libpqrcv_connect, libpqwalreceiver.c:171&quot;</span>,<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">01</span> <span class="number">13</span>:<span class="number">25</span>:<span class="number">29</span><span class="variable">.430</span> CST,,,<span class="number">27738</span>,,<span class="number">51</span>d112c8<span class="variable">.6c5a</span>,<span class="number">2</span>,,<span class="number">2015</span>-<span class="number">07</span>-<span class="number">01</span> <span class="number">13</span>:<span class="number">25</span>:<span class="number">28</span> CST,,<span class="number">0</span>,FATAL,XX000,<span class="string">&quot;could not receive data from WAL stream:FATAL:  requested WAL segment 0000000800002A0000000000 has already been removed</span></span><br><span class="line"><span class="string">&quot;</span>,,,,,,,,<span class="string">&quot;libpqrcv_receive, libpqwalreceiver.c:389&quot;</span>,<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>根据报错信息分析，推测是主库大事务产生了大量 xlog，这是因为 PostgreSQL 在执行事务过程中，直到提交时才会发送到备库。</p><p>由于该事务需要执行的时间过长，超过了 checkpoint 的默认间隔，所以导致有的 xlog 还未发送到备库却被 remove 掉了。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>要解决该问题，一般可用的方案有：</p><h2 id="方法一：调大参数-wal-keep-segments-的值"><a href="#方法一：调大参数-wal-keep-segments-的值" class="headerlink" title="方法一：调大参数 wal_keep_segments 的值"></a>方法一：调大参数 wal_keep_segments 的值</h2><p>将 GUC 参数 <code>wal_keep_segments</code> 设大一些，比如设置为2000，而每个 segment 默认值为16MB，就相当于有 32000MB，那么，最多可保存 30GB 的 xlog ，超过则删除最早的 xlog 。</p><p>不过，<strong>该方法并不能从根本上解决该问题</strong>。毕竟，在生产环境中或TPCC等测试灌数时，如果某条事务需要插入几十亿条记录，有可能还是会出现该问题。</p><h2 id="方法二：启用归档"><a href="#方法二：启用归档" class="headerlink" title="方法二：启用归档"></a>方法二：启用归档</h2><p>归档，就是将未发送到备库的 xlog 备份到某个目录下，待重启数据库时再将其恢复到备库中去。</p><p>GUC 参数设置示例如下：</p><ul><li><p>主库的 postgresql.conf 文件中：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wal_level</span> = hot_standby</span><br><span class="line"><span class="attr">archive_mode</span> = <span class="literal">on</span></span><br><span class="line"><span class="attr">archive_command</span> = <span class="string">&#x27;rsync -zaq %p postgres@pg-slave:/var/lib/pgsql/wal_restore/%f &amp;&amp; test ! -f /var/lib/pgsql/backup/wal_archive/%f &amp;&amp; cp %p /var/lib/pgsql/backup/wal_archive/&#x27;</span></span><br><span class="line"><span class="attr">archive_timeout</span> = <span class="number">300</span></span><br><span class="line"><span class="attr">max_wal_senders</span> = <span class="number">5</span></span><br><span class="line"><span class="attr">wal_keep_segments</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>备库的 postgresql.conf 文件中：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wal_level</span> = hot_standby</span><br><span class="line"><span class="attr">archive_mode</span> = <span class="literal">on</span></span><br><span class="line"><span class="attr">archive_command</span> = <span class="string">&#x27;test ! -f /var/lib/pgsql/backup/wal_archive/%f &amp;&amp; cp -i %p /var/lib/pgsql/backup/wal_archive/%f &lt; /dev/null&#x27;</span></span><br><span class="line"><span class="attr">hot_standby</span> = <span class="literal">on</span></span><br><span class="line"><span class="attr">wal_keep_segments</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>备库的 recovery.conf 文件中：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">standby_mode</span> = <span class="string">&#x27;on&#x27;</span></span><br><span class="line"><span class="attr">primary_conninfo</span> = <span class="string">&#x27;host=pg-master port=5432 user=replicator&#x27;</span></span><br><span class="line"><span class="attr">restore_command</span> = <span class="string">&#x27;cp /var/lib/psql/wal_restore/%f %p&#x27;</span></span><br><span class="line"><span class="attr">archive_cleanup_command</span> = <span class="string">&#x27;pg_archivecleanup /var/lib/pgsql/wal_restore/ %r&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="方法三：启用-replication-slot（PG-9-4-开始支持）"><a href="#方法三：启用-replication-slot（PG-9-4-开始支持）" class="headerlink" title="方法三：启用 replication slot（PG 9.4 开始支持）"></a>方法三：启用 replication slot（PG 9.4 开始支持）</h2><p><strong>该方法是根本解决方法，不会造成xlog的丢失</strong>。也就是说，在 xlog 被拷贝到从库之前，主库不会删除。</p><p><strong>启用方法：</strong></p><ol><li><p>在 postgresql.conf 中添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max_replication_slots</span> = <span class="number">2000</span></span><br></pre></td></tr></table></figure></li><li><p>在拷贝到备库之前，主库要创建一个 slot：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_create_physical_replication_slot(<span class="string">&#x27;node_a_slot&#x27;</span>);</span><br><span class="line">  slot_name  <span class="operator">|</span> xlog_position</span><br><span class="line"><span class="comment">-------------+---------------</span></span><br><span class="line"> node_a_slot <span class="operator">|</span></span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_replication_slots;</span><br><span class="line">  slot_name  <span class="operator">|</span> slot_type <span class="operator">|</span> datoid <span class="operator">|</span> database <span class="operator">|</span> active <span class="operator">|</span> xmin <span class="operator">|</span> restart_lsn</span><br><span class="line"><span class="comment">-------------+-----------+--------+----------+--------+------+-------------</span></span><br><span class="line"> node_a_slot <span class="operator">|</span> physical  <span class="operator">|</span>        <span class="operator">|</span>          <span class="operator">|</span> f      <span class="operator">|</span>      <span class="operator">|</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure></li><li><p>在备库的 recovery.conf 文件中添加一行：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">standby_mode</span> = <span class="string">&#x27;on&#x27;</span></span><br><span class="line"><span class="attr">primary_conninfo</span> = <span class="string">&#x27;host=192.168.4.225 port=19000 user=wslu password=xxxx&#x27;</span></span><br><span class="line"><span class="attr">primary_slot_name</span> = <span class="string">&#x27;node_a_slot&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.postgresql.org/docs/9.4/static/runtime-config-replication.html">https://www.postgresql.org/docs/9.4/static/runtime-config-replication.html</a></p><p><a href="https://www.postgresql.org/docs/9.4/static/warm-standby.html#CASCADING-REPLICATION">https://www.postgresql.org/docs/9.4/static/warm-standby.html#CASCADING-REPLICATION</a><br><a href="http://blog.2ndquadrant.com/postgresql-9-4-slots/">http://blog.2ndquadrant.com/postgresql-9-4-slots/</a></p><p><a href="http://grokbase.com/t/postgresql/pgsql-general/13654jchy3/trouble-with-replication">http://grokbase.com/t/postgresql/pgsql-general/13654jchy3/trouble-with-replication</a></p><p><a href="http://stackoverflow.com/questions/28201475/how-do-i-fix-a-postgresql-9-3-slave-that-cannot-keep-up-with-the-master">http://stackoverflow.com/questions/28201475/how-do-i-fix-a-postgresql-9-3-slave-that-cannot-keep-up-with-the-master</a></p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2016-04-25 20:59:52&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;h</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="http://dbkernel.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="http://dbkernel.github.io/tags/PostgreSQL/"/>
    
    <category term="问题定位" scheme="http://dbkernel.github.io/tags/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    
    <category term="WAL" scheme="http://dbkernel.github.io/tags/WAL/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | 使用 gcov 和 lcov 测试 PostgreSQL 代码覆盖率</title>
    <link href="http://dbkernel.github.io/2016/03/30/test-postgresql-code-coverage-using-gcov-and-lcov/"/>
    <id>http://dbkernel.github.io/2016/03/30/test-postgresql-code-coverage-using-gcov-and-lcov/</id>
    <published>2016-03-30T07:34:34.000Z</published>
    <updated>2021-09-24T05:23:45.713Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2016-03-30 15:34:34</strong></p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>通常我们评判一个 test case 好坏的标准之一是代码的覆盖率，一个好的 test case 应该覆盖到所有的代码。</p><p>那么问题来了，我们<strong>怎么知道这个 test case 有没有覆盖到所有的代码呢？</strong></p><p>以 PostgreSQL 为例，我们看看如何检测 C 语言程序的代码覆盖率。</p><p>C 代码覆盖率测试，需要用到 gcc 的配套工具<code>gcov</code>，还有一个可视化工具<code>lcov</code>。</p><h1 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h1><p>首先需要安装依赖 gcov 和 lcov 。</p><p>gcov 在 gcc 包中已经包含了，lcov 是 ltp 的一个 gcov 扩展插件，用来产生HTML报告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lcov</span><br></pre></td></tr></table></figure><h1 id="2-编译、安装-PG"><a href="#2-编译、安装-PG" class="headerlink" title="2. 编译、安装 PG"></a>2. 编译、安装 PG</h1><h2 id="2-1-编译选项介绍"><a href="#2-1-编译选项介绍" class="headerlink" title="2.1. 编译选项介绍"></a>2.1. 编译选项介绍</h2><p>首先介绍一下 PostgreSQL 的编译选项 <code>--enable-coverage</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-coverage       build with coverage testing instrumentation</span><br></pre></td></tr></table></figure><p>这个编译项对应gcc的两个参数：<code>-fprofile-arcs</code> 和 <code>-ftest-coverage</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enable code coverage if --enable-coverage</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$enable_coverage</span>&quot;</span> = yes; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$GCC</span>&quot;</span> = yes; <span class="keyword">then</span></span><br><span class="line">    CFLAGS=<span class="string">&quot;<span class="variable">$CFLAGS</span> -fprofile-arcs -ftest-coverage&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    as_fn_error $? <span class="string">&quot;--enable-coverage is supported only when using GCC&quot;</span> <span class="string">&quot;<span class="variable">$LINENO</span>&quot;</span> 5</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>通过<code>man gcc</code>查看这两个参数的含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-fprofile-arcs</span><br><span class="line">           Add code so that program flow arcs are instrumented.  During execution the program records how many times each branch and call is executed and how many times it is taken or returns.  When</span><br><span class="line">           the compiled program exits it saves this data to a file called auxname.gcda for each source file.  The data may be used for profile-directed optimizations (-fbranch-probabilities), or for</span><br><span class="line">           test coverage analysis (-ftest-coverage).  Each object file&#x27;s auxname is generated from the name of the output file, if explicitly specified and it is not the final executable, otherwise</span><br><span class="line">           it is the basename of the source file.  In both cases any suffix is removed (e.g. foo.gcda for input file dir/foo.c, or dir/foo.gcda for output file specified as -o dir/foo.o).</span><br><span class="line"></span><br><span class="line">--coverage</span><br><span class="line">           This option is used to compile and link code instrumented for coverage analysis.  The option is a synonym for -fprofile-arcs -ftest-coverage (when compiling) and -lgcov (when linking).</span><br><span class="line">           See the documentation for those options for more details.</span><br><span class="line"></span><br><span class="line">           *   Compile the source files with -fprofile-arcs plus optimization and code generation options.  For test coverage analysis, use the additional -ftest-coverage option.  You do not need to</span><br><span class="line">               profile every source file in a program.</span><br><span class="line"></span><br><span class="line">           *   Link your object files with -lgcov or -fprofile-arcs (the latter implies the former).</span><br><span class="line"></span><br><span class="line">           *   Run the program on a representative workload to generate the arc profile information.  This may be repeated any number of times.  You can run concurrent instances of your program, and</span><br><span class="line">               provided that the file system supports locking, the data files will be correctly updated.  Also &quot;fork&quot; calls are detected and correctly handled (double counting will not happen).</span><br><span class="line"></span><br><span class="line">           *   For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus -fbranch-probabilities.</span><br><span class="line"></span><br><span class="line">           *   For test coverage analysis, use gcov to produce human readable information from the .gcno and .gcda files.  Refer to the gcov documentation for further information.</span><br><span class="line"></span><br><span class="line">           With -fprofile-arcs, for each function of your program GCC creates a program flow graph, then finds a spanning tree for the graph.  Only arcs that are not on the spanning tree have to be</span><br><span class="line">           instrumented: the compiler adds code to count the number of times that these arcs are executed.  When an arc is the only exit or only entrance to a block, the instrumentation code can be</span><br><span class="line">           added to the block; otherwise, a new basic block must be created to hold the instrumentation code.</span><br><span class="line"></span><br><span class="line">-ftest-coverage</span><br><span class="line">           Produce a notes file that the gcov code-coverage utility can use to show program coverage.  Each source file&#x27;s note file is called auxname.gcno.  Refer to the -fprofile-arcs option above</span><br><span class="line">           for a description of auxname and instructions on how to generate test coverage data.  Coverage data matches the source files more closely if you do not optimize.</span><br></pre></td></tr></table></figure><p><strong>-fprofile-arcs</strong>：</p><blockquote><p><code>-fprofile-arcs</code> 用于产生 .c 文件对应的 .gcda 文件，.gcda 文件可以被用于 profile 驱动的优化，或者结合 gcov 来做代码覆盖分析。</p><p>编译时尽量不要使用 -O 优化，这样代码覆盖数据 .gcda 才能尽可能和代码接近。</p><p>当代码被调用时，.gcda 文件中对应的计数器会被修改，记录代码被调用的次数。</p></blockquote><p><strong>-ftest-coverage</strong>：</p><blockquote><p><code>-ftest-coverage</code> 这个选项用于产生 .c 文件的 .gcno 文件。这个文件生成后不会被修改。结合 .gcda，可以分析测试代码覆盖率。</p></blockquote><h2 id="2-2-编译安装"><a href="#2-2-编译安装" class="headerlink" title="2.2. 编译安装"></a>2.2. 编译安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/pgsql9.4.4 --with-pgport=1921 --with-perl --with-python --with-tcl --with-openssl --with-pam --with-ldap --with-libxml --with-libxslt --enable-thread-safety --enable-debug --enable-dtrace --enable-coverage</span><br><span class="line"></span><br><span class="line">gmake world &amp;&amp; gmake install-world</span><br></pre></td></tr></table></figure><p>安装好后，我们会发现在源码目录中多了一些.gcda和.gcno的文件，每个.c文件都会对应这两个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">postgres@wslu-&gt; ll</span><br><span class="line">total 1.3M</span><br><span class="line">-rw-r--r-- 1 postgres postgres  22K Jun 10 03:29 gistbuildbuffers.c</span><br><span class="line">-rw------- 1 postgres postgres 1.6K Sep  7 14:42 gistbuildbuffers.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres  15K Sep  7 14:38 gistbuildbuffers.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  70K Sep  7 14:38 gistbuildbuffers.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres  37K Jun 10 03:29 gistbuild.c</span><br><span class="line">-rw------- 1 postgres postgres 2.2K Sep  7 14:42 gistbuild.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres  20K Sep  7 14:38 gistbuild.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  92K Sep  7 14:38 gistbuild.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres  43K Jun 10 03:29 gist.c</span><br><span class="line">-rw------- 1 postgres postgres 3.1K Sep  7 14:42 gist.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres  29K Sep  7 14:38 gist.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  16K Jun 10 03:29 gistget.c</span><br><span class="line">-rw------- 1 postgres postgres 1.3K Sep  7 14:42 gistget.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres  13K Sep  7 14:38 gistget.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  74K Sep  7 14:38 gistget.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres 101K Sep  7 14:38 gist.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres  39K Jun 10 03:29 gistproc.c</span><br><span class="line">-rw------- 1 postgres postgres 3.1K Sep  7 14:42 gistproc.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres  31K Sep  7 14:38 gistproc.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  79K Sep  7 14:38 gistproc.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres 9.1K Jun 10 03:29 gistscan.c</span><br><span class="line">-rw------- 1 postgres postgres  848 Sep  7 14:42 gistscan.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres 6.7K Sep  7 14:38 gistscan.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  60K Sep  7 14:38 gistscan.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres  24K Jun 10 03:29 gistsplit.c</span><br><span class="line">-rw------- 1 postgres postgres 1.5K Sep  7 14:42 gistsplit.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres  15K Sep  7 14:38 gistsplit.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  68K Sep  7 14:38 gistsplit.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres  21K Jun 10 03:29 gistutil.c</span><br><span class="line">-rw------- 1 postgres postgres 2.2K Sep  7 14:42 gistutil.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres  20K Sep  7 14:38 gistutil.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  84K Sep  7 14:38 gistutil.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres 7.1K Jun 10 03:29 gistvacuum.c</span><br><span class="line">-rw------- 1 postgres postgres  784 Sep  7 14:42 gistvacuum.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres 7.3K Sep  7 14:38 gistvacuum.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  56K Sep  7 14:38 gistvacuum.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres  14K Jun 10 03:29 gistxlog.c</span><br><span class="line">-rw------- 1 postgres postgres 1.2K Sep  7 14:42 gistxlog.gcda</span><br><span class="line">-rw-r--r-- 1 postgres postgres  12K Sep  7 14:38 gistxlog.gcno</span><br><span class="line">-rw-r--r-- 1 postgres postgres  50K Sep  7 14:38 gistxlog.o</span><br><span class="line">-rw-r--r-- 1 postgres postgres  538 Jun 10 03:29 Makefile</span><br><span class="line">-rw-r--r-- 1 postgres postgres  357 Sep  7 14:38 objfiles.txt</span><br><span class="line">-rw-r--r-- 1 postgres postgres  20K Jun 10 03:29 README</span><br><span class="line"></span><br><span class="line">postgres@wslu-&gt; <span class="built_in">pwd</span></span><br><span class="line">/opt/soft_bak/postgresql-9.4.4/src/backend/access/gist</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><p>源码文件目录的权限需要改为数据库启动用户的权限，否则无法修改 .gcda 的值，也就无法获取代码被调用的次数了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@wslu-&gt; chown -R postgres:postgres /opt/soft_bak/postgresql-9.4.4</span><br></pre></td></tr></table></figure><p>接下来我们看看文件的变化，以 dbsize.c 中的两个获取 pg_database_size 的 C 函数为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres@wslu-&gt; ls -la|grep dbsize</span><br><span class="line">-rw-r--r--  1 postgres postgres  19342 Jun 10 03:29 dbsize.c</span><br><span class="line">-rw-------  1 postgres postgres   2664 Sep  7 15:01 dbsize.gcda</span><br><span class="line">-rw-r--r--  1 postgres postgres  23272 Sep  7 14:38 dbsize.gcno</span><br><span class="line">-rw-r--r--  1 postgres postgres  89624 Sep  7 14:38 dbsize.o</span><br></pre></td></tr></table></figure><p>调用一次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">postgres@wslu-&gt; psql</span><br><span class="line">psql (9.4.4)</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line">postgres=<span class="comment"># select pg_database_size(oid) from pg_database;</span></span><br><span class="line"> pg_database_size</span><br><span class="line">------------------</span><br><span class="line">          6898180</span><br><span class="line">          6889988</span><br><span class="line">         24742560</span><br><span class="line">          6898180</span><br><span class="line">          6898180</span><br><span class="line">          6898180</span><br><span class="line">(6 rows)</span><br><span class="line">postgres=<span class="comment"># \q</span></span><br></pre></td></tr></table></figure><p>再次查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres@wslu-&gt; ls -la|grep dbsize</span><br><span class="line">-rw-r--r--  1 postgres postgres  19342 Jun 10 03:29 dbsize.c</span><br><span class="line">-rw-------  1 postgres postgres   2664 Sep  7 15:12 dbsize.gcda</span><br><span class="line">-rw-r--r--  1 postgres postgres  23272 Sep  7 14:38 dbsize.gcno</span><br><span class="line">-rw-r--r--  1 postgres postgres  89624 Sep  7 14:38 dbsize.o</span><br></pre></td></tr></table></figure><p>dbsize.gcda 文件的修改时间发送了变化，说明刚才我们调用pg_database_size(oid) 时，调用了 dbsize.c 中的代码。对应的行计数器会发生变化。</p><h1 id="3-生成-HTML-报告"><a href="#3-生成-HTML-报告" class="headerlink" title="3. 生成 HTML 报告"></a>3. 生成 HTML 报告</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir html</span><br><span class="line">$ <span class="built_in">cd</span> html</span><br><span class="line"></span><br><span class="line">$ lcov --directory /opt/soft_bak/postgresql-9.4.4 --capture --output-file ./app.info</span><br><span class="line"><span class="comment"># 如果你不需要所有的代码，修改以上目录即可，譬如只看 contrib 下面的代码覆盖率。</span></span><br><span class="line"></span><br><span class="line">$ genhtml ./app.info</span><br><span class="line">postgres@wslu-&gt; ll</span><br><span class="line">total 3.7M</span><br><span class="line">drwxrwxr-x 12 postgres postgres 4.0K Sep  7 15:02 access</span><br><span class="line">-rw-rw-r--  1 postgres postgres  141 Sep  7 15:02 amber.png</span><br><span class="line">-rw-rw-r--  1 postgres postgres 3.4M Sep  7 15:02 app.info</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 bootstrap</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 catalog</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 commands</span><br><span class="line">-rw-rw-r--  1 postgres postgres  141 Sep  7 15:02 emerald.png</span><br><span class="line">drwxrwxr-x  2 postgres postgres  12K Sep  7 15:02 executor</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 foreign</span><br><span class="line">-rw-rw-r--  1 postgres postgres 9.7K Sep  7 15:02 gcov.css</span><br><span class="line">-rw-rw-r--  1 postgres postgres  167 Sep  7 15:02 glass.png</span><br><span class="line">-rw-rw-r--  1 postgres postgres  57K Sep  7 15:02 index.html</span><br><span class="line">-rw-rw-r--  1 postgres postgres  57K Sep  7 15:02 index-sort-f.html</span><br><span class="line">-rw-rw-r--  1 postgres postgres  57K Sep  7 15:02 index-sort-l.html</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 lib</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 libpq</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 main</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 nodes</span><br><span class="line">drwxrwxr-x  3 postgres postgres 4.0K Sep  7 15:02 opt</span><br><span class="line">drwxrwxr-x  7 postgres postgres 4.0K Sep  7 15:02 optimizer</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 parser</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 port</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 postmaster</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 regex</span><br><span class="line">drwxrwxr-x  3 postgres postgres 4.0K Sep  7 15:02 replication</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 rewrite</span><br><span class="line">-rw-rw-r--  1 postgres postgres  141 Sep  7 15:02 ruby.png</span><br><span class="line">drwxrwxr-x  3 postgres postgres 4.0K Sep  7 15:02 snowball</span><br><span class="line">-rw-rw-r--  1 postgres postgres  141 Sep  7 15:02 snow.png</span><br><span class="line">drwxrwxr-x 10 postgres postgres 4.0K Sep  7 15:02 storage</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 tcop</span><br><span class="line">drwxrwxr-x  2 postgres postgres 4.0K Sep  7 15:02 tsearch</span><br><span class="line">-rw-rw-r--  1 postgres postgres  117 Sep  7 15:02 updown.png</span><br><span class="line">drwxrwxr-x  3 postgres postgres 4.0K Sep  7 15:02 usr</span><br><span class="line">drwxrwxr-x 14 postgres postgres 4.0K Sep  7 15:02 utils</span><br></pre></td></tr></table></figure><h1 id="4-查看报告"><a href="#4-查看报告" class="headerlink" title="4. 查看报告"></a>4. 查看报告</h1><p>浏览器中打开 <code>index.html</code> 即可查看。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>PostgreSQL 其实已经在 Makefile 提供了生成代码覆盖 HTML 的 target 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@wslu postgresql-9.4.4]<span class="comment"># make coverage-html</span></span><br></pre></td></tr></table></figure><p>产生的html目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@wslu postgresql-9.4.4]<span class="comment"># cd coverage</span></span><br><span class="line">[root@wslu coverage]<span class="comment"># ll</span></span><br><span class="line">total 224</span><br><span class="line">-rw-r--r--  1 root root   141 Sep  7 19:17 amber.png</span><br><span class="line">-rw-r--r--  1 root root   141 Sep  7 19:17 emerald.png</span><br><span class="line">-rw-r--r--  1 root root  9893 Sep  7 19:17 gcov.css</span><br><span class="line">-rw-r--r--  1 root root   167 Sep  7 19:17 glass.png</span><br><span class="line">-rw-r--r--  1 root root 58737 Sep  7 19:18 index.html</span><br><span class="line">-rw-r--r--  1 root root 58730 Sep  7 19:18 index-sort-f.html</span><br><span class="line">-rw-r--r--  1 root root 58730 Sep  7 19:18 index-sort-l.html</span><br><span class="line">-rw-r--r--  1 root root   141 Sep  7 19:17 ruby.png</span><br><span class="line">-rw-r--r--  1 root root   141 Sep  7 19:17 snow.png</span><br><span class="line">drwxr-xr-x 11 root root  4096 Sep  7 19:18 src</span><br><span class="line">-rw-r--r--  1 root root   117 Sep  7 19:17 updown.png</span><br><span class="line">drwxr-xr-x  3 root root  4096 Sep  7 19:18 usr</span><br></pre></td></tr></table></figure><p>每次对代码改动后，执行完 <code>make check</code> 或其他回归测试手段后，就可以执行 <code>make coverage-html</code> 了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://magustest.com/blog/whiteboxtesting/using-gcov-lcov/">Magus Test Archive</a></li><li><a href="http://ltp.sourceforge.net/coverage/lcov.php">lcov</a></li><li><a href="http://ltp.sourceforge.net/coverage/lcov/readme.php">lcov readme</a></li><li><a href="https://github.com/linux-test-project/ltp">GitHub - linux-test-project/ltp: Linux Test Project http://linux-test-project.github.io/</a></li><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Gcov.html">Gcov (Using the GNU Compiler Collection (GCC))</a></li><li><a href="https://wiki.postgresql.org/wiki/CodeCoverage">CodeCoverage - PostgreSQL wiki</a></li><li><a href="http://www.postgresql.org/docs/devel/static/regress-coverage.html">PostgreSQL: Documentation: devel: 33.5. Test Coverage Examination</a></li></ol><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2016-03-30 15:34:34&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="http://dbkernel.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="http://dbkernel.github.io/tags/PostgreSQL/"/>
    
    <category term="gcov" scheme="http://dbkernel.github.io/tags/gcov/"/>
    
    <category term="lcov" scheme="http://dbkernel.github.io/tags/lcov/"/>
    
    <category term="测试" scheme="http://dbkernel.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | PostgreSQL 回归测试详解</title>
    <link href="http://dbkernel.github.io/2016/03/30/postgresql-regression-test-details/"/>
    <id>http://dbkernel.github.io/2016/03/30/postgresql-regression-test-details/</id>
    <published>2016-03-30T07:29:35.000Z</published>
    <updated>2021-09-22T15:24:33.492Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2016-03-30 15:29:35</strong></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>回归测试是 PostgreSQL 的测试方法之一。</p><p>回归测试，需要事先定义好测试脚本（通常是 SQL 脚本，放在 sql 目录中），同时定义好调用执行测试脚本的预期正确输出文件（通常放在 expected 目录中)。</p><p>测试使用 <code>make check</code> 或 <code>make installcheck</code> 进行，它会通过 <code>pg_regress</code> 程序调用 sql 目录中的 SQL，并收集输出结果（通常放到 results 目录中），最后 pg_regress 会对 expected 目录和 results 目录中的文件使用 diff 进行一一比较。</p><p>如果比较发现文件内容不一致，会将不一致的结果输出到 <code>regression.diffs</code> 文件中，并返回这个 TEST CASE failed。</p><p>但是这种测试方法实际上有一些需要注意的地方，例如我们使用不同的本地化设置，时区可能得到的结果和期望的结果就不一样。另外有些不可预知的结果，例如随机值，数据的顺序，执行计划和优化器相关参数有关。这些因素都可能导致测试结果和预期不一致，那么我们就需要人为去修复这种 failed。</p><p>PostgreSQL 的主代码测试文件在 <code>src/test/regress</code> 目录中。</p><p>这个目录的结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">postgres@digoal-&gt; ll -rt</span><br><span class="line">total 1.2M</span><br><span class="line">-rw-r--r-- 1 postgres postgres  579 Jun 10 03:29 standby_schedule <span class="comment"># 测试standby的调度配置, 其实就是调度sql里的文件名</span></span><br><span class="line">-rw-r--r-- 1 postgres postgres 2.3K Jun 10 03:29 serial_schedule <span class="comment"># 串行测试的调度配置</span></span><br><span class="line">-rw-r--r-- 1 postgres postgres  937 Jun 10 03:29 resultmap <span class="comment"># 不同的测试平台的结果映射文件，因为不同平台某些测试结果可能不相同，所以一个expected文件不能支持所有的平台。例如浮点数测试。</span></span><br><span class="line">-rwxr-xr-x 1 postgres postgres 4.4K Jun 10 03:29 regressplans.sh</span><br><span class="line">-rw-r--r-- 1 postgres postgres  20K Jun 10 03:29 regress.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres  159 Jun 10 03:29 README</span><br><span class="line">-rw-r--r-- 1 postgres postgres 2.7K Jun 10 03:29 pg_regress_main.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres 1.6K Jun 10 03:29 pg_regress.h</span><br><span class="line">-rw-r--r-- 1 postgres postgres  69K Jun 10 03:29 pg_regress.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres 3.6K Jun 10 03:29 parallel_schedule <span class="comment"># 并行测试的调度配置</span></span><br><span class="line">-rw-r--r-- 1 postgres postgres  624 Jun 10 03:29 Makefile</span><br><span class="line">-rw-r--r-- 1 postgres postgres 5.6K Jun 10 03:29 GNUmakefile</span><br><span class="line">drwxrwxrwx 2 postgres postgres 4.0K Jun 10 03:38 output</span><br><span class="line">drwxrwxrwx 2 postgres postgres 4.0K Jun 10 03:38 input</span><br><span class="line">drwxrwxrwx 2 postgres postgres 4.0K Jun 10 03:38 data   一些测试数据</span><br><span class="line">drwxrwxrwx 2 postgres postgres 4.0K Sep  7 14:51 sql <span class="comment"># 测试用到的SQL</span></span><br><span class="line">drwxrwxr-x 2 postgres postgres 4.0K Sep  7 14:52 results <span class="comment"># 通过pg_regress调用sql目录中的脚本，得到的结果</span></span><br><span class="line">drwxrwxrwx 2 postgres postgres 4.0K Sep  7 14:51 expected <span class="comment"># 执行sql目录中的文件对应的正确返回结果</span></span><br></pre></td></tr></table></figure><p>上层目录结构如下，其中包含了一些其他的测试目标，例如隔离级别的测试，本地化测试，性能测试，线程安全测试。等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres@digoal-&gt; <span class="built_in">cd</span> /opt/soft_bak/postgresql-9.4.4/src/<span class="built_in">test</span></span><br><span class="line">postgres@digoal-&gt; ll</span><br><span class="line">total 36K</span><br><span class="line">drwxrwxrwx  2 postgres postgres 4.0K Jun 10 03:38 examples</span><br><span class="line">drwxrwxrwx  4 postgres postgres 4.0K Jun 10 03:41 isolation</span><br><span class="line">drwxrwxrwx  6 postgres postgres 4.0K Jun 10 03:38 locale</span><br><span class="line">-rw-r--r--  1 postgres postgres  389 Jun 10 03:29 Makefile</span><br><span class="line">drwxrwxrwx  4 postgres postgres 4.0K Jun 10 03:38 mb</span><br><span class="line">drwxrwxrwx  4 postgres postgres 4.0K Jun 10 03:38 performance</span><br><span class="line">drwxrwxrwx  2 postgres postgres 4.0K Jun 10 03:38 perl</span><br><span class="line">drwxrwxrwx 10 postgres postgres 4.0K Sep  7 19:17 regress</span><br><span class="line">drwxrwxrwx  2 postgres postgres 4.0K Jun 10 03:38 thread</span><br></pre></td></tr></table></figure><p>接下来我们看看 PostgreSQL 的回归测试程序 pg_regress 的用法，它不会安装到 PGHOME/bin 中，只在 src/test/regress 中存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> src/<span class="built_in">test</span>/regress</span><br><span class="line">$ src/<span class="built_in">test</span>/regress/pg_regress --<span class="built_in">help</span></span><br><span class="line">PostgreSQL regression <span class="built_in">test</span> driver</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  pg_regress [OPTION]... [EXTRA-TEST]...</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --config-auth=DATADIR     update authentication settings <span class="keyword">for</span> DATADIR</span><br><span class="line">  --create-role=ROLE        create the specified role before testing</span><br><span class="line">  --dbname=DB               use database DB (default <span class="string">&quot;regression&quot;</span>)</span><br><span class="line">  --debug                   turn on debug mode <span class="keyword">in</span> programs that are run</span><br><span class="line">  --dlpath=DIR              look <span class="keyword">for</span> dynamic libraries <span class="keyword">in</span> DIR</span><br><span class="line">  --encoding=ENCODING       use ENCODING as the encoding</span><br><span class="line">  --inputdir=DIR            take input files from DIR (default <span class="string">&quot;.&quot;</span>)</span><br><span class="line">  --launcher=CMD            use CMD as launcher of psql</span><br><span class="line">  --load-extension=EXT      load the named extension before running the</span><br><span class="line">                            tests; can appear multiple <span class="built_in">times</span></span><br><span class="line">  --load-language=LANG      load the named language before running the</span><br><span class="line">                            tests; can appear multiple <span class="built_in">times</span></span><br><span class="line">  --max-connections=N       maximum number of concurrent connections</span><br><span class="line">                            (default is 0, meaning unlimited)</span><br><span class="line">  --outputdir=DIR           place output files <span class="keyword">in</span> DIR (default <span class="string">&quot;.&quot;</span>)</span><br><span class="line">  --schedule=FILE           use <span class="built_in">test</span> ordering schedule from FILE</span><br><span class="line">                            (can be used multiple <span class="built_in">times</span> to concatenate)</span><br><span class="line">  --temp-install=DIR        create a temporary installation <span class="keyword">in</span> DIR</span><br><span class="line">  --use-existing            use an existing installation</span><br><span class="line"></span><br><span class="line">Options <span class="keyword">for</span> <span class="string">&quot;temp-install&quot;</span> mode:</span><br><span class="line">  --extra-install=DIR       additional directory to install (e.g., contrib)</span><br><span class="line">  --no-locale               use C locale</span><br><span class="line">  --port=PORT               start postmaster on PORT</span><br><span class="line">  --temp-config=FILE        append contents of FILE to temporary config</span><br><span class="line">  --top-builddir=DIR        (relative) path to top level build directory</span><br><span class="line"></span><br><span class="line">Options <span class="keyword">for</span> using an existing installation:</span><br><span class="line">  --host=HOST               use postmaster running on HOST</span><br><span class="line">  --port=PORT               use postmaster running at PORT</span><br><span class="line">  --user=USER               connect as USER</span><br><span class="line">  --psqldir=DIR             use psql <span class="keyword">in</span> DIR (default: configured bindir)</span><br><span class="line"></span><br><span class="line">The <span class="built_in">exit</span> status is 0 <span class="keyword">if</span> all tests passed, 1 <span class="keyword">if</span> some tests failed, and 2</span><br><span class="line"><span class="keyword">if</span> the tests could not be run <span class="keyword">for</span> some reason.</span><br><span class="line"></span><br><span class="line">Report bugs to &lt;pgsql-bugs@postgresql.org&gt;.</span><br></pre></td></tr></table></figure><h2 id="回归测试用法"><a href="#回归测试用法" class="headerlink" title="回归测试用法"></a>回归测试用法</h2><p>在 PostgreSQL 源码根目录，或者源码的 regress 目录中执行如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make check <span class="comment"># 测试时需要初始化数据库集群</span></span><br><span class="line">make installcheck <span class="comment"># 使用以及启动的数据库集群测试，不需要初始化数据库集群</span></span><br></pre></td></tr></table></figure><p>以下同时测试主代码以及 contrib 的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make check-world</span><br><span class="line">make installcheck-world</span><br></pre></td></tr></table></figure><p>如果要使用自定义的 diff 参数，可以设置一个环境变量，例如：<code>make check PG_REGRESS_DIFF_OPTS=&#39;-u&#39;</code>。</p><p>同时我们还可以使用不同的 LOCALE 进行测试。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make check LANG=de_DE.utf8</span><br><span class="line">make check NO_LOCALE=1</span><br><span class="line">make check LANG=C ENCODING=EUC_JP</span><br></pre></td></tr></table></figure><p>当我们要测试调度中不包含的测试 SQL 时，可以使用 <code>EXTRA_TESTS</code> 参数，至于这些脚本为什么默认不包含在调度中，可能是因为这些 SQL 脚本可能对平台的依赖比较严重，所以没有放到默认的测试中。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make check EXTRA_TESTS=collate.linux.utf8 LANG=en_US.utf8</span><br><span class="line">make check EXTRA_TESTS=numeric_big</span><br></pre></td></tr></table></figure><p>接下来我们看看调度文件以及 sql 脚本目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">postgres@digoal-&gt; <span class="built_in">pwd</span></span><br><span class="line">/opt/soft_bak/postgresql-9.4.4/src/<span class="built_in">test</span>/regress</span><br><span class="line">postgres@digoal-&gt; less serial_schedule</span><br><span class="line"><span class="comment"># src/test/regress/serial_schedule</span></span><br><span class="line"><span class="comment"># This should probably be in an order similar to parallel_schedule.</span></span><br><span class="line"><span class="built_in">test</span>: tablespace</span><br><span class="line"><span class="built_in">test</span>: boolean</span><br><span class="line"><span class="built_in">test</span>: char</span><br><span class="line"><span class="built_in">test</span>: name</span><br><span class="line"><span class="built_in">test</span>: varchar</span><br><span class="line"><span class="built_in">test</span>: text</span><br><span class="line"><span class="built_in">test</span>: int2</span><br><span class="line"><span class="built_in">test</span>: int4</span><br><span class="line"><span class="built_in">test</span>: int8</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>并行调度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">postgres@digoal-&gt; less parallel_schedule</span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># src/test/regress/parallel_schedule</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By convention, we put no more than twenty tests in any one parallel group;</span></span><br><span class="line"><span class="comment"># this limits the number of connections needed to run the tests.</span></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># run tablespace by itself, and first, because it forces a checkpoint;</span></span><br><span class="line"><span class="comment"># we&#x27;d prefer not to have checkpoints later in the tests because that</span></span><br><span class="line"><span class="comment"># interferes with crash-recovery testing.</span></span><br><span class="line"><span class="built_in">test</span>: tablespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># The first group of parallel tests</span></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="built_in">test</span>: boolean char name varchar text int2 int4 int8 oid float4 float8 bit numeric txid uuid enum money rangetypes pg_lsn regproc</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>调度文件的 test: 后面跟的就是sql目录下的文件名(不含 .sql 后缀)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">postgres@digoal-&gt; less sql/</span><br><span class="line">total 1940</span><br><span class="line">drwxrwxrwx  2 postgres postgres   4096 Sep  7 14:51 ./</span><br><span class="line">drwxrwxrwx 10 postgres postgres   4096 Sep  7 22:34 ../</span><br><span class="line">-rw-r--r--  1 postgres postgres   2237 Jun 10 03:29 abstime.sql</span><br><span class="line">-rw-r--r--  1 postgres postgres   4097 Jun 10 03:29 advisory_lock.sql</span><br><span class="line">-rw-r--r--  1 postgres postgres  20295 Jun 10 03:29 aggregates.sql</span><br><span class="line">-rw-r--r--  1 postgres postgres  24882 Jun 10 03:29 alter_generic.sql</span><br><span class="line">-rw-r--r--  1 postgres postgres  54461 Jun 10 03:29 alter_table.sql</span><br><span class="line">-rw-r--r--  1 postgres postgres  17244 Jun 10 03:29 arrays.sql</span><br><span class="line">-rw-r--r--  1 postgres postgres    594 Jun 10 03:29 async.sql</span><br><span class="line">-rw-r--r--  1 postgres postgres   1365 Jun 10 03:29 bitmapops.sql</span><br><span class="line">-rw-r--r--  1 postgres postgres   6406 Jun 10 03:29 bit.sql</span><br><span class="line">-rw-r--r--  1 postgres postgres   4164 Jun 10 03:29 boolean.sql</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>所以前面提到的 EXTRA_TESTS 实际上也是 sql 目录中的文件名(不带 .sql 后缀)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make check EXTRA_TESTS=collate.linux.utf8 LANG=en_US.utf8</span><br><span class="line">make check EXTRA_TESTS=numeric_big</span><br></pre></td></tr></table></figure><p>来实际的试一下吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">postgres@digoal-&gt; <span class="built_in">pwd</span></span><br><span class="line">/opt/soft_bak/postgresql-9.4.4/src/<span class="built_in">test</span>/regress</span><br><span class="line">postgres@digoal-&gt; make installcheck-parallel  //并行测试，使用已经开启的现有的数据库集群</span><br><span class="line">make -C ../../../src/port all</span><br><span class="line">......</span><br><span class="line">../../../src/<span class="built_in">test</span>/regress/pg_regress --inputdir=. --psqldir=<span class="string">&#x27;/opt/pgsql9.4.4/bin&#x27;</span>    --dlpath=.  --schedule=./parallel_schedule</span><br><span class="line">(using postmaster on /data01/pg_root_1921, port 1921)</span><br><span class="line">============== dropping database <span class="string">&quot;regression&quot;</span>         ==============</span><br><span class="line">DROP DATABASE</span><br><span class="line">============== creating database <span class="string">&quot;regression&quot;</span>         ==============</span><br><span class="line">CREATE DATABASE</span><br><span class="line">ALTER DATABASE</span><br><span class="line">============== running regression <span class="built_in">test</span> queries        ==============</span><br><span class="line"><span class="built_in">test</span> tablespace               ... ok</span><br><span class="line">......</span><br><span class="line">parallel group (19 tests):  <span class="built_in">limit</span> conversion sequence returning without_oid polymorphism copy2 xml prepare plancache rowtypes temp domain with truncate largeobject rangefuncs alter_table plpgsql</span><br><span class="line">     plancache                ... ok</span><br><span class="line">     <span class="built_in">limit</span>                    ... ok</span><br><span class="line">     plpgsql                  ... ok</span><br><span class="line">     copy2                    ... ok</span><br><span class="line">     temp                     ... ok</span><br><span class="line">     domain                   ... ok</span><br><span class="line">     rangefuncs               ... FAILED</span><br><span class="line">     prepare                  ... ok</span><br><span class="line">     without_oid              ... ok</span><br><span class="line">     conversion               ... ok</span><br><span class="line">     truncate                 ... ok</span><br><span class="line">     alter_table              ... ok</span><br><span class="line">     sequence                 ... ok</span><br><span class="line">     polymorphism             ... FAILED</span><br><span class="line">     rowtypes                 ... ok</span><br><span class="line">     returning                ... ok</span><br><span class="line">     largeobject              ... ok</span><br><span class="line">     with                     ... FAILED</span><br><span class="line">     xml                      ... ok</span><br><span class="line"><span class="built_in">test</span> stats                    ... ok</span><br><span class="line">......</span><br><span class="line">=========================</span><br><span class="line"> 22 of 145 tests failed.</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line">The differences that caused some tests to fail can be viewed <span class="keyword">in</span> the</span><br><span class="line">file <span class="string">&quot;/opt/soft_bak/postgresql-9.4.4/src/test/regress/regression.diffs&quot;</span>.  A copy of the <span class="built_in">test</span> summary that you see</span><br><span class="line">above is saved <span class="keyword">in</span> the file <span class="string">&quot;/opt/soft_bak/postgresql-9.4.4/src/test/regress/regression.out&quot;</span>.</span><br><span class="line"></span><br><span class="line">make: *** [installcheck-parallel] Error 1</span><br></pre></td></tr></table></figure><p>有些测试失败了，diff 文件已经输出到 <code>/opt/soft_bak/postgresql-9.4.4/src/test/regress/regression.diffs</code>，我们可以查看一下看看为什么测试结果和预期结果不一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">postgres@digoal-&gt; less regression.diffs</span><br><span class="line">*** /opt/soft_bak/postgresql-9.4.4/src/<span class="built_in">test</span>/regress/expected/pg_lsn.out 2015-06-10 03:29:38.000000000 +0800</span><br><span class="line">--- /opt/soft_bak/postgresql-9.4.4/src/<span class="built_in">test</span>/regress/results/pg_lsn.out  2015-09-07 22:45:04.413922536 +0800</span><br><span class="line">***************</span><br><span class="line">*** 72,92 ****</span><br><span class="line">         generate_series(1, 5) k</span><br><span class="line">    WHERE i &lt;= 10 AND j &gt; 0 AND j &lt;= 10</span><br><span class="line">    ORDER BY f;</span><br><span class="line">!                                 QUERY PLAN</span><br><span class="line">! --------------------------------------------------------------------------</span><br><span class="line">!  Sort</span><br><span class="line">!    Sort Key: (((((i.i)::text || <span class="string">&#x27;/&#x27;</span>::text) || (j.j)::text))::pg_lsn)</span><br><span class="line">!    -&gt;  HashAggregate</span><br><span class="line">!          Group Key: ((((i.i)::text || <span class="string">&#x27;/&#x27;</span>::text) || (j.j)::text))::pg_lsn</span><br><span class="line">           -&gt;  Nested Loop</span><br><span class="line">                 -&gt;  Function Scan on generate_series k</span><br><span class="line">!                -&gt;  Materialize</span><br><span class="line">!                      -&gt;  Nested Loop</span><br><span class="line">!                            -&gt;  Function Scan on generate_series j</span><br><span class="line">!                                  Filter: ((j &gt; 0) AND (j &lt;= 10))</span><br><span class="line">!                            -&gt;  Function Scan on generate_series i</span><br><span class="line">!                                  Filter: (i &lt;= 10)</span><br><span class="line">! (12 rows)</span><br><span class="line"></span><br><span class="line">  SELECT DISTINCT (i || <span class="string">&#x27;/&#x27;</span> || j)::pg_lsn f</span><br><span class="line">    FROM generate_series(1, 10) i,</span><br><span class="line">--- 72,90 ----</span><br><span class="line">         generate_series(1, 5) k</span><br><span class="line">    WHERE i &lt;= 10 AND j &gt; 0 AND j &lt;= 10</span><br><span class="line">    ORDER BY f;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>对于主代码，如果我们需要自定义测试 SQL，我们可以修改 <code>regress/sql</code> 目录下的文件，或者新增文件。同时修改 <code>regress/expected</code> 目录下的对应期望文件，或者现在期望文件。</p><p>如果是新增文件的情况，我们还需要修改调度文件 <code>regress/serial_schedule和regress/parallel_schedule</code>，把测试加入调度。</p><p>最后，再以 <code>ltree</code> 插件为例，看看如何配置一个外加插件的回归测试。</p><p>ltree 的源码目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">postgres@digoal-&gt; <span class="built_in">cd</span> contrib/</span><br><span class="line">postgres@digoal-&gt; <span class="built_in">cd</span> ltree/</span><br><span class="line">postgres@digoal-&gt; ll -rt</span><br><span class="line">total 1.1M</span><br><span class="line">-rw-r--r-- 1 postgres postgres  517 Jun 10 03:29 Makefile</span><br><span class="line">-rw-r--r-- 1 postgres postgres 2.4K Jun 10 03:29 ltxtquery_op.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres  11K Jun 10 03:29 ltxtquery_io.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres 7.9K Jun 10 03:29 ltree--unpackaged--1.0.sql</span><br><span class="line">-rw-r--r-- 1 postgres postgres  994 Jun 10 03:29 ltreetest.sql</span><br><span class="line">-rw-r--r-- 1 postgres postgres  13K Jun 10 03:29 ltree_op.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres 6.9K Jun 10 03:29 _ltree_op.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres  14K Jun 10 03:29 ltree_io.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres 7.3K Jun 10 03:29 ltree.h</span><br><span class="line">-rw-r--r-- 1 postgres postgres  16K Jun 10 03:29 ltree_gist.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres  13K Jun 10 03:29 _ltree_gist.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres  155 Jun 10 03:29 ltree.control</span><br><span class="line">-rw-r--r-- 1 postgres postgres  18K Jun 10 03:29 ltree--1.0.sql</span><br><span class="line">-rw-r--r-- 1 postgres postgres 7.1K Jun 10 03:29 lquery_op.c</span><br><span class="line">-rw-r--r-- 1 postgres postgres  263 Jun 10 03:29 crc32.h</span><br><span class="line">-rw-r--r-- 1 postgres postgres 4.1K Jun 10 03:29 crc32.c</span><br><span class="line">drwxrwxrwx 2 postgres postgres 4.0K Jun 10 03:38 sql</span><br><span class="line">drwxrwxrwx 2 postgres postgres 4.0K Jun 10 03:38 expected</span><br><span class="line">drwxrwxrwx 2 postgres postgres 4.0K Jun 10 03:38 data</span><br></pre></td></tr></table></figure><p>contrib/ltree 的 Makefile 如下（在这里配置回归测试的调度，用到变量 REGRESS，对应 sql 目录中的脚本文件名）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># contrib/ltree/Makefile</span></span><br><span class="line"></span><br><span class="line">MODULE_big = ltree</span><br><span class="line">OBJS =  ltree_io.o ltree_op.o lquery_op.o _ltree_op.o crc32.o \</span><br><span class="line">        ltxtquery_io.o ltxtquery_op.o ltree_gist.o _ltree_gist.o</span><br><span class="line">PG_CPPFLAGS = -DLOWER_NODE</span><br><span class="line"></span><br><span class="line">EXTENSION = ltree</span><br><span class="line">DATA = ltree--1.0.sql ltree--unpackaged--1.0.sql</span><br><span class="line"></span><br><span class="line">REGRESS = ltree</span><br><span class="line"></span><br><span class="line">ifdef USE_PGXS</span><br><span class="line">PG_CONFIG = pg_config</span><br><span class="line">PGXS := $(shell $(PG_CONFIG) --pgxs)</span><br><span class="line">include $(PGXS)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">subdir = contrib/ltree</span><br><span class="line">top_builddir = ../..</span><br><span class="line">include $(top_builddir)/src/Makefile.global</span><br><span class="line">include $(top_srcdir)/contrib/contrib-global.mk</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(PGXS)</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(top_builddir)/src/Makefile.global</span><br></pre></td></tr></table></figure><p>都指向了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/makefiles/pgxs.mk</span><br></pre></td></tr></table></figure><p>这个 makefile 中会用到回归测试相关的两个变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   REGRESS -- list of regression test cases (without suffix)</span></span><br><span class="line"><span class="comment">#   REGRESS_OPTS -- additional switches to pass to pg_regress</span></span><br></pre></td></tr></table></figure><p>引用 <code>src/makefiles/pgxs.mk</code> 的部分内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">ifdef REGRESS</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select database to use for running the tests</span></span><br><span class="line">ifneq ($(USE_MODULE_DB),)</span><br><span class="line">  REGRESS_OPTS += --dbname=$(CONTRIB_TESTDB_MODULE)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  REGRESS_OPTS += --dbname=$(CONTRIB_TESTDB)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment"># where to find psql for running the tests</span></span><br><span class="line">PSQLDIR = $(bindir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># When doing a VPATH build, must copy over the data files so that the</span></span><br><span class="line"><span class="comment"># driver script can find them.  We have to use an absolute path for</span></span><br><span class="line"><span class="comment"># the targets, because otherwise make will try to locate the missing</span></span><br><span class="line"><span class="comment"># files using VPATH, and will find them in $(srcdir), but the point</span></span><br><span class="line"><span class="comment"># here is that we want to copy them from $(srcdir) to the build</span></span><br><span class="line"><span class="comment"># directory.</span></span><br><span class="line"></span><br><span class="line">ifdef VPATH</span><br><span class="line">abs_builddir := $(shell <span class="built_in">pwd</span>)</span><br><span class="line">test_files_src := $(wildcard $(srcdir)/data/*.data)</span><br><span class="line">test_files_build := $(patsubst $(srcdir)/%, $(abs_builddir)/%, $(test_files_src))</span><br><span class="line"></span><br><span class="line">all: $(test_files_build)</span><br><span class="line">$(test_files_build): $(abs_builddir)/%: $(srcdir)/%</span><br><span class="line">        $(MKDIR_P) $(dir <span class="variable">$@</span>)</span><br><span class="line">        ln -s $&lt; <span class="variable">$@</span></span><br><span class="line">endif <span class="comment"># VPATH</span></span><br><span class="line"></span><br><span class="line">.PHONY: submake</span><br><span class="line">submake:</span><br><span class="line">ifndef PGXS</span><br><span class="line">        $(MAKE) -C $(top_builddir)/src/<span class="built_in">test</span>/regress pg_regress$(X)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment"># against installed postmaster</span></span><br><span class="line">installcheck: submake $(REGRESS_PREP)</span><br><span class="line">        $(pg_regress_installcheck) $(REGRESS_OPTS) $(REGRESS)</span><br><span class="line"></span><br><span class="line">ifdef PGXS</span><br><span class="line">check:</span><br><span class="line">        @<span class="built_in">echo</span> <span class="string">&#x27;&quot;$(MAKE) check&quot; is not supported.&#x27;</span></span><br><span class="line">        @<span class="built_in">echo</span> <span class="string">&#x27;Do &quot;$(MAKE) install&quot;, then &quot;$(MAKE) installcheck&quot; instead.&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">check: all submake $(REGRESS_PREP)</span><br><span class="line">        $(pg_regress_check) --extra-install=$(subdir) $(REGRESS_OPTS) $(REGRESS)</span><br><span class="line">endif</span><br><span class="line">endif <span class="comment"># REGRESS</span></span><br></pre></td></tr></table></figure><p>这里用到了 ltree 中 Makefile 中定义的 subdir 和 REGRESS 变量，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top_builddir = ../..</span><br><span class="line">subdir = contrib/ltree</span><br><span class="line">REGRESS = ltree</span><br></pre></td></tr></table></figure><p>所以我们在 contrib/ltree 中执行 make check 会执行：(指PGXS未定义时)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(pg_regress_check) --extra-install=$(subdir) $(REGRESS_OPTS) $(REGRESS)</span><br></pre></td></tr></table></figure><p>pg_regress_check 这个变量在 <code>src/Makefile.global</code> 中定义了，其实就是 pg_regress 命令的调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src/Makefile.global</span><br><span class="line">src/Makefile.global:srcdir = .</span><br><span class="line">pg_regress_locale_flags = $(<span class="keyword">if</span> $(ENCODING),--encoding=$(ENCODING)) $(NOLOCALE)</span><br><span class="line">pg_regress_check = $(top_builddir)/src/<span class="built_in">test</span>/regress/pg_regress --inputdir=$(srcdir) --temp-install=./tmp_check --top-builddir=$(top_builddir) $(pg_regress_locale_flags) $(EXTRA_REGRESS_OPTS)</span><br></pre></td></tr></table></figure><p>在 contrib/ltree 中执行 make check 最终执行的是(没有定义的变量直接忽略)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../src/<span class="built_in">test</span>/regress/pg_regress --inputdir=. --temp-install=./tmp_check --top-builddir=../.. --extra-install=contrib/ltree ltree</span><br></pre></td></tr></table></figure><p>我们可以直接到 ltree 的源码目录测试这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@digoal ~]<span class="comment"># chown -R postgres:postgres /opt/soft_bak/postgresql-9.4.4</span></span><br><span class="line">[root@digoal ~]<span class="comment"># su - postgres</span></span><br><span class="line">postgres@digoal-&gt; <span class="built_in">cd</span> /opt/soft_bak/postgresql-9.4.4/contrib/ltree/</span><br><span class="line">postgres@digoal-&gt; ../../src/<span class="built_in">test</span>/regress/pg_regress --inputdir=. --temp-install=./tmp_check --top-builddir=../.. --extra-install=contrib/ltree ltree</span><br><span class="line">============== removing existing temp installation    ==============</span><br><span class="line">============== creating temporary installation        ==============</span><br><span class="line">============== initializing database system           ==============</span><br><span class="line">============== starting postmaster                    ==============</span><br><span class="line">running on port 57636 with PID 27852</span><br><span class="line">============== creating database <span class="string">&quot;regression&quot;</span>         ==============</span><br><span class="line">CREATE DATABASE</span><br><span class="line">ALTER DATABASE</span><br><span class="line">============== running regression <span class="built_in">test</span> queries        ==============</span><br><span class="line"><span class="built_in">test</span> ltree                    ... ok</span><br><span class="line">============== shutting down postmaster               ==============</span><br><span class="line">============== removing temporary installation        ==============</span><br><span class="line"></span><br><span class="line">=====================</span><br><span class="line"> All 1 tests passed.</span><br><span class="line">=====================</span><br></pre></td></tr></table></figure><p>另外一种测试时 installcheck，和 check 不同的是，installcheck 不需要初始化数据库，是在我们开启了数据库集群的情况下的测试。</p><p>同样的方法，我们可以发现它调用的是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(pg_regress_installcheck) $(REGRESS_OPTS) $(REGRESS)</span><br></pre></td></tr></table></figure><p>通过 src/Makefile.global 的定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pg_regress_installcheck = $(top_builddir)/src/<span class="built_in">test</span>/regress/pg_regress --inputdir=$(srcdir) --psqldir=<span class="string">&#x27;$(PSQLDIR)&#x27;</span> $(pg_regress_locale_flags) $(EXTRA_REGRESS_OPTS)</span><br><span class="line">bindir := $(shell $(PG_CONFIG) --bindir)</span><br></pre></td></tr></table></figure><p>以及 src/makefiles/pgxs.mk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSQLDIR = $(bindir)</span><br></pre></td></tr></table></figure><p>最终转换为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../src/<span class="built_in">test</span>/regress/pg_regress --inputdir=. --psqldir=<span class="string">&#x27;/opt/pgsql/bin&#x27;</span> ltree</span><br></pre></td></tr></table></figure><p>启动数据库后，就可以进行测试了。同样需要注意(PGPORT PGHOST PGDATABASE PGUSER 等)环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">postgres@digoal-&gt; pg_ctl start</span><br><span class="line">postgres@digoal-&gt; <span class="built_in">pwd</span></span><br><span class="line">/opt/soft_bak/postgresql-9.4.4/contrib/ltree</span><br><span class="line">postgres@digoal-&gt; ../../src/<span class="built_in">test</span>/regress/pg_regress --inputdir=. --psqldir=<span class="string">&#x27;/opt/pgsql/bin&#x27;</span> ltree</span><br><span class="line">(using postmaster on /data01/pg_root_1921, port 1921)</span><br><span class="line">============== dropping database <span class="string">&quot;regression&quot;</span>         ==============</span><br><span class="line">DROP DATABASE</span><br><span class="line">============== creating database <span class="string">&quot;regression&quot;</span>         ==============</span><br><span class="line">CREATE DATABASE</span><br><span class="line">ALTER DATABASE</span><br><span class="line">============== running regression <span class="built_in">test</span> queries        ==============</span><br><span class="line"><span class="built_in">test</span> ltree                    ... ok</span><br><span class="line"></span><br><span class="line">=====================</span><br><span class="line"> All 1 tests passed.</span><br><span class="line">=====================</span><br></pre></td></tr></table></figure><p>所以插件的回归测试配置也很简单，同样需要 sql, expected 目录，以及通过配置 Makefile 来指定需要回归测试的 sql 脚本。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.postgresql.org/docs/devel/static/regress-run.html">http://www.postgresql.org/docs/devel/static/regress-run.html</a></li><li><a href="http://www.postgresql.org/docs/devel/static/regress-variant.html">http://www.postgresql.org/docs/devel/static/regress-variant.html</a></li></ol><p>各种Makefile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/Makefile.global</span><br><span class="line">src/Makefile</span><br><span class="line">src/makefiles/pgxs.mk</span><br><span class="line">contrib/contrib-global.mk</span><br><span class="line">contrib/xx/Makefile</span><br><span class="line">......</span><br></pre></td></tr></table></figure><blockquote><p>本文转自：<a href="https://github.com/digoal/blog/blob/master/201509/20150907_04.md">https://github.com/digoal/blog/blob/master/201509/20150907_04.md</a></p></blockquote><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2016-03-30 15:29:35&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="http://dbkernel.github.io/categories/PostgreSQL/"/>
    
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="PostgreSQL" scheme="http://dbkernel.github.io/tags/PostgreSQL/"/>
    
    <category term="回归测试" scheme="http://dbkernel.github.io/tags/%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>最佳实践 | 源码编译安装配置 Postgres-XC 集群并用 pg_basebackup 配置 Datanode 热备</title>
    <link href="http://dbkernel.github.io/2016/03/15/how-to-install-postgres-xc-on-linux/"/>
    <id>http://dbkernel.github.io/2016/03/15/how-to-install-postgres-xc-on-linux/</id>
    <published>2016-03-15T11:56:52.000Z</published>
    <updated>2021-09-22T15:24:33.492Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2016-03-15 19:56:52</strong></p></blockquote><p>注意：本篇文章成文时 Postgres-XC 还未改名为 Postgres-X2 。</p><h1 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:postgres-x2/postgres-x2.git</span><br></pre></td></tr></table></figure><h1 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2. 安装依赖"></a>2. 安装依赖</h1><p><strong>对于 Ubuntu/Debian：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y git-core</span><br><span class="line">apt-get install -y gcc g++</span><br><span class="line">apt-get install -y ccache</span><br><span class="line">apt-get install -y libreadline-dev</span><br><span class="line">apt-get install -y bison flex</span><br><span class="line">apt-get install -y zlib1g-dev</span><br><span class="line">apt-get install -y openssl libssl-dev</span><br><span class="line">apt-get install -y libpam-dev</span><br><span class="line">apt-get install -y libcurl4-dev</span><br><span class="line">apt-get install -y libbz2-dev</span><br><span class="line">apt-get install -y python-dev</span><br><span class="line">apt-get install -y ssh</span><br><span class="line"></span><br><span class="line">apt-get install -y libcurl4-dev</span><br><span class="line">Package libcurl4-dev is a virtual package provided by:</span><br><span class="line">libcurl4-openssl-dev 7.38.0-4+deb8u2</span><br><span class="line">libcurl4-nss-dev 7.38.0-4+deb8u2</span><br><span class="line">libcurl4-gnutls-dev 7.38.0-4+deb8u2</span><br><span class="line"></span><br><span class="line">apt-get install -y python-pip</span><br><span class="line"></span><br><span class="line">pip install lockfile</span><br><span class="line">pip install paramiko</span><br><span class="line">pip install setuptools</span><br><span class="line">pip install epydoc</span><br><span class="line">pip install psi</span><br><span class="line"></span><br><span class="line">Note: debian8 required pip install --pre psi</span><br></pre></td></tr></table></figure><p><strong>对于 CentOS：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yum install –y git.x86_64</span><br><span class="line">yum install –y gcc.x86_64 gcc-c++.x86_64</span><br><span class="line">yum install –y ccache.x86_64</span><br><span class="line">yum install readline.x86_64 readline-devel.x86_64</span><br><span class="line">yum install bison.x86_64 bison-devel.x86_64</span><br><span class="line">yum install flex.x86_64 flex-devel.x86_64</span><br><span class="line">yum install zlib.x86_64 zlib-devel.x86_64</span><br><span class="line">yum install -y openssl.x86_64 openssl-devel.x86_64</span><br><span class="line">yum install -y pam.x86_64 pam-devel.x86_64</span><br><span class="line">yum install –y libcurl.x86_64 libcurl-devel.x86_64</span><br><span class="line">yum install bzip2-libs.x86_64 bzip2.x86_64 bzip2-devel.x86_64</span><br><span class="line">yum install libssh2.x86_64 libssh2-devel.x86_64</span><br><span class="line">yum install python-devel.x86_64</span><br><span class="line">yum install -y python-pip.noarch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着执行：</span></span><br><span class="line">pip install lockfile</span><br><span class="line">pip install paramiko</span><br><span class="line">pip install setuptools</span><br><span class="line">pip install epydoc</span><br><span class="line">pip install psi</span><br><span class="line"><span class="comment"># 或者执行：</span></span><br><span class="line">yum install python-lockfile.noarch</span><br><span class="line">yum install python-PSI.x86_64</span><br><span class="line">yum install python-paramiko.noarch</span><br><span class="line">yum install python-setuptools.noarch</span><br><span class="line">yum install epydoc.noarch</span><br></pre></td></tr></table></figure><h1 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> postgres-x2</span><br><span class="line">$ ./configure --prefix=/home/wslu/pgsql --enable-debug <span class="comment">#其中--prefix指定编绎完成后将要安装的路径，必须使用全路径，wslu为使用者。</span></span><br><span class="line">$ make <span class="comment">#执行编绎</span></span><br><span class="line">$ make install <span class="comment">#执行安装</span></span><br></pre></td></tr></table></figure><h1 id="4-初始化、启动"><a href="#4-初始化、启动" class="headerlink" title="4. 初始化、启动"></a>4. 初始化、启动</h1><h2 id="4-1-初始化-GTM"><a href="#4-1-初始化-GTM" class="headerlink" title="4.1. 初始化 GTM"></a>4.1. 初始化 GTM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/wslu/pgsql</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置PTAH变量</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=/home/user/pgsql/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment">#使用初始化gtm命令initgtm</span></span><br><span class="line">$ ./bin/initgtm -Z gtm -D data/gtm/</span><br></pre></td></tr></table></figure><h2 id="4-2-初始化数据库节点"><a href="#4-2-初始化数据库节点" class="headerlink" title="4.2. 初始化数据库节点"></a>4.2. 初始化数据库节点</h2><p>初始化所有数据库节点（CO、DN）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用初始化db命令initdb</span></span><br><span class="line">$ ./bin/initdb -U wslu -A trust --locale=C -D data/co1   <span class="comment"># -U 使用者 -D 数据目录/节点</span></span><br><span class="line">$ ./bin/initdb -U wslu -A trust --locale=C -D data/co2</span><br><span class="line">$ ./bin/initdb -U wslu -A trust --locale=C -D data/dn1</span><br><span class="line">$ ./bin/initdb -U wslu -A trust --locale=C -D data/dn2</span><br><span class="line">$ ./bin/initdb -U wslu -A trust --locale=C -D data/dn3</span><br></pre></td></tr></table></figure><h2 id="4-3-编辑配置文件"><a href="#4-3-编辑配置文件" class="headerlink" title="4.3. 编辑配置文件"></a>4.3. 编辑配置文件</h2><p>编辑 data/co1/postgresql.conf：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认值</span></span><br><span class="line"><span class="attr">gtm_port</span> = <span class="number">6666</span></span><br><span class="line"><span class="comment"># pgxc_node_name 不能重复</span></span><br><span class="line"><span class="attr">pgxc_node_name</span> = co1</span><br></pre></td></tr></table></figure><p>编辑 data/co2/postgresql.conf：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gtm_port</span> = <span class="number">6666</span></span><br><span class="line"><span class="attr">pgxc_node_name</span> = co2</span><br></pre></td></tr></table></figure><p>编辑 data/dn1/postgresql.conf：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gtm_port</span> = <span class="number">6666</span></span><br><span class="line"><span class="attr">pgxc_node_name</span> = dn1</span><br></pre></td></tr></table></figure><p>编辑 data/dn2/postgresql.conf：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gtm_port</span> = <span class="number">6666</span></span><br><span class="line"><span class="attr">pgxc_node_name</span> = dn2</span><br></pre></td></tr></table></figure><p>编辑 data/dn2/postgresql.conf：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gtm_port</span> = <span class="number">6666</span></span><br><span class="line"><span class="attr">pgxc_node_name</span> = dn3</span><br></pre></td></tr></table></figure><h2 id="4-4-启动服务"><a href="#4-4-启动服务" class="headerlink" title="4.4. 启动服务"></a>4.4. 启动服务</h2><p>依次启动 gtm、datanode、coordinator：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./bin/gtm_ctl start -S gtm -D data/gtm -l data/gtm/gtm.log  //启动gtm（由于切换为相对路径后找不到对应的文件夹，所以创建日志会失败）</span></span><br><span class="line">$ ./bin/gtm_ctl start -Z gtm -D data/gtm -l gtm.log  //启动gtm</span><br><span class="line"><span class="comment"># vim data/gtm/gtm.log # 使用日志查看gtm是否启动</span></span><br><span class="line"></span><br><span class="line">$ ./bin/pg_ctl start -Z datanode -D data/dn1 -l data/dn1/postgresql.log  -o <span class="string">&quot;-p 24071&quot;</span>   //启动datanode dn1， DN1_PORT=24071   根据需要自由设置</span><br><span class="line"><span class="comment"># vim data/dn1/postgresql.log # 同样使用日志查看是否启动</span></span><br><span class="line"></span><br><span class="line">$ ./bin/pg_ctl start -Z datanode -D data/dn2 -l data/dn2/postgresql.log  -o <span class="string">&quot;-p 24072&quot;</span>  //启动 dn2， DN2_PORT=24072</span><br><span class="line">$ ./bin/pg_ctl start -Z datanode -D data/dn3 -l data/dn3/postgresql.log  -o <span class="string">&quot;-p 24073&quot;</span>  //启动 dn3， DN3_PORT=24073</span><br><span class="line"></span><br><span class="line">$ ./bin/pg_ctl start -Z coordinator -D data/co1 -l data/co1/postgresql.log  -o <span class="string">&quot;-p 24076&quot;</span>   //启动 coordinator co1， CO1_PORT=24076</span><br><span class="line">$ ./bin/pg_ctl start -Z coordinator -D data/co2 -l data/co2/postgresql.log  -o <span class="string">&quot;-p 24077&quot;</span>   //启动 co2， CO2_PORT= 24077</span><br></pre></td></tr></table></figure><h1 id="5-配置集群节点"><a href="#5-配置集群节点" class="headerlink" title="5. 配置集群节点"></a>5. 配置集群节点</h1><p>指定动态库位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> LD_LIBRARY_PATH=/home/wslu/pgsql/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>配置集群节点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 进入co1创建节点，co1_port<span class="operator">=</span><span class="number">24076</span></span><br><span class="line">$ .<span class="operator">/</span>bin<span class="operator">/</span>psql <span class="operator">-</span>p <span class="number">24076</span> postgres postgres</span><br><span class="line"></span><br><span class="line"> <span class="keyword">CREATE</span> NODE dn1 <span class="keyword">WITH</span> (HOST <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>, type <span class="operator">=</span> <span class="string">&#x27;datanode&#x27;</span>, PORT <span class="operator">=</span> <span class="number">24071</span>, id <span class="operator">=</span> <span class="number">1</span>, content <span class="operator">=</span> <span class="number">1</span>); <span class="operator">/</span><span class="operator">/</span>在协调器上注册节点，各端口号与上面一致</span><br><span class="line"> <span class="keyword">CREATE</span> NODE dn2 <span class="keyword">WITH</span> (HOST <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>, type <span class="operator">=</span> <span class="string">&#x27;datanode&#x27;</span>, PORT <span class="operator">=</span> <span class="number">24072</span>, id <span class="operator">=</span> <span class="number">2</span>, content <span class="operator">=</span> <span class="number">2</span>);</span><br><span class="line"> <span class="keyword">CREATE</span> NODE dn3 <span class="keyword">WITH</span> (HOST <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>, type <span class="operator">=</span> <span class="string">&#x27;datanode&#x27;</span>, PORT <span class="operator">=</span> <span class="number">24073</span>, id <span class="operator">=</span> <span class="number">3</span>, content <span class="operator">=</span> <span class="number">3</span>);</span><br><span class="line"> <span class="keyword">CREATE</span> NODE co1 <span class="keyword">WITH</span> (HOST <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>, type <span class="operator">=</span> <span class="string">&#x27;coordinator&#x27;</span>, PORT <span class="operator">=</span> <span class="number">24076</span>, id <span class="operator">=</span> <span class="number">4</span>, content <span class="operator">=</span> <span class="number">4</span>);</span><br><span class="line"> <span class="keyword">CREATE</span> NODE co2 <span class="keyword">WITH</span> (HOST <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>, type <span class="operator">=</span> <span class="string">&#x27;coordinator&#x27;</span>, PORT <span class="operator">=</span> <span class="number">24077</span>, id <span class="operator">=</span> <span class="number">5</span>, content <span class="operator">=</span> <span class="number">5</span>);</span><br><span class="line"> <span class="keyword">SELECT</span> pgxc_pool_reload();</span><br></pre></td></tr></table></figure><p>至此，集群配置完成。</p><h1 id="6-常见操作"><a href="#6-常见操作" class="headerlink" title="6. 常见操作"></a>6. 常见操作</h1><h2 id="6-1-停止集群"><a href="#6-1-停止集群" class="headerlink" title="6.1. 停止集群"></a>6.1. 停止集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/pg_ctl stop -D data/co1 -m immediate</span><br><span class="line">$ ./bin/pg_ctl stop -D data/co2 -m immediate</span><br><span class="line">$ ./bin/pg_ctl stop -D data/dn1 -m immediate</span><br><span class="line">$ ./bin/pg_ctl stop -D data/dn2 -m immediate</span><br><span class="line">$ ./bin/pg_ctl stop -D data/dn3 -m immediate</span><br><span class="line">$ ./bin/gtm_ctl stop -Z gtm -D data/gtm</span><br><span class="line">$ rm -f data/gtm/register.node</span><br></pre></td></tr></table></figure><h2 id="6-2-启动集群"><a href="#6-2-启动集群" class="headerlink" title="6.2. 启动集群"></a>6.2. 启动集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/gtm_ctl start -Z gtm -D data/gtm -p ./bin -l data/gtm/gtm.log</span><br><span class="line">$ ./bin/pg_ctl start -l data/dn1/postgresql.log -Z datanode -D data/dn1 -o <span class="string">&quot;-p 24071&quot;</span></span><br><span class="line">$ ./bin/pg_ctl start -l data/dn2/postgresql.log -Z datanode -D data/dn2 -o <span class="string">&quot;-p 24072&quot;</span></span><br><span class="line">$ ./bin/pg_ctl start -l data/dn3/postgresql.log -Z datanode -D data/dn3 -o <span class="string">&quot;-p 24073&quot;</span></span><br><span class="line">$ ./bin/pg_ctl start -l data/co1/postgresql.log -Z coordinator -D data/co1 -o <span class="string">&quot;-p 24076&quot;</span></span><br><span class="line">$ ./bin/pg_ctl start -l data/co2/postgresql.log -Z coordinator -D data/co2 -o <span class="string">&quot;-p 24077&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-3-清理数据"><a href="#6-3-清理数据" class="headerlink" title="6.3. 清理数据"></a>6.3. 清理数据</h2><p>如需清除数据，请先停止服务器集群，然后清除数据存储目录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/pg_ctl stop -D data/co1 -m immediate</span><br><span class="line">$ ./bin/pg_ctl stop -D data/co2 -m immediate</span><br><span class="line">$ ./bin/pg_ctl stop -D data/dn1 -m immediate</span><br><span class="line">$ ./bin/pg_ctl stop -D data/dn2 -m immediate</span><br><span class="line">$ ./bin/pg_ctl stop -D data/dn3 -m immediate</span><br><span class="line">$ ./bin/gtm_ctl stop -Z gtm -D data/gtm</span><br><span class="line">$ rm -f data/gtm/register.node</span><br><span class="line">$ rm -rf data</span><br></pre></td></tr></table></figure><h1 id="7-配置-Datanode-热备"><a href="#7-配置-Datanode-热备" class="headerlink" title="7. 配置 Datanode 热备"></a>7. 配置 Datanode 热备</h1><h2 id="7-1-修改所有-CO-和-DN-的-pg-hba-conf"><a href="#7-1-修改所有-CO-和-DN-的-pg-hba-conf" class="headerlink" title="7.1. 修改所有 CO 和 DN 的 pg_hba.conf"></a>7.1. 修改所有 CO 和 DN 的 pg_hba.conf</h2><p>将下面两行的注释去掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ vi data/co1/pg_hba.conf</span><br><span class="line">host    replication     wslu        127.0.0.1/32            trust</span><br><span class="line">host    replication     wslu        ::1/128                 trust</span><br><span class="line"></span><br><span class="line">$ vi data/co2/pg_hba.conf</span><br><span class="line">host    replication     wslu        127.0.0.1/32            trust</span><br><span class="line">host    replication     wslu        ::1/128                 trust</span><br><span class="line"></span><br><span class="line">$ vi data/dn1/pg_hba.conf</span><br><span class="line">host    replication     wslu        127.0.0.1/32            trust</span><br><span class="line">host    replication     wslu        ::1/128                 trust</span><br><span class="line"></span><br><span class="line">$ vi data/dn2/pg_hba.conf</span><br><span class="line">host    replication     wslu        127.0.0.1/32            trust</span><br><span class="line">host    replication     wslu        ::1/128                 trust</span><br><span class="line"></span><br><span class="line">$ vi data/dn3/pg_hba.conf</span><br><span class="line">host    replication     wslu        127.0.0.1/32            trust</span><br><span class="line">host    replication     wslu        ::1/128                 trust</span><br></pre></td></tr></table></figure><p>此处为了测试方便，将校验方式设为 trust；实际生产中要改为 md5，即根据账户密码验证。</p><h2 id="7-2-修改所有-CO-和-DN-的-postgresql-conf"><a href="#7-2-修改所有-CO-和-DN-的-postgresql-conf" class="headerlink" title="7.2. 修改所有 CO 和 DN 的 postgresql.conf"></a>7.2. 修改所有 CO 和 DN 的 postgresql.conf</h2><p>添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ vi data/co1/postgresql.conf</span><br><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">log_line_prefix = <span class="string">&#x27;%t:%r:%u@%d:[%p]: &#x27;</span></span><br><span class="line"><span class="comment">#logging_collector = on</span></span><br><span class="line">port = 24076</span><br><span class="line">wal_level = archive</span><br><span class="line"></span><br><span class="line">$ vi data/co2/postgresql.conf</span><br><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">log_line_prefix = <span class="string">&#x27;%t:%r:%u@%d:[%p]: &#x27;</span></span><br><span class="line"><span class="comment">#logging_collector = on</span></span><br><span class="line">port = 24077</span><br><span class="line">wal_level = archive</span><br><span class="line"></span><br><span class="line">$ vi data/dn1/postgresql.conf</span><br><span class="line">hot_standby = on</span><br><span class="line"><span class="comment">#logging_collector = on</span></span><br><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">log_line_prefix = <span class="string">&#x27;%t:%r:%u@%d:[%p]: &#x27;</span></span><br><span class="line">wal_keep_segments = 10</span><br><span class="line">wal_level = hot_standby</span><br><span class="line">max_wal_senders = 5</span><br><span class="line">include_if_exists = <span class="string">&#x27;synchronous_standby_names.conf&#x27;</span></span><br><span class="line">port = 24071</span><br><span class="line"></span><br><span class="line">$ vi data/dn2/postgresql.conf</span><br><span class="line">hot_standby = on</span><br><span class="line"><span class="comment">#logging_collector = on</span></span><br><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">log_line_prefix = <span class="string">&#x27;%t:%r:%u@%d:[%p]: &#x27;</span></span><br><span class="line">wal_keep_segments = 10</span><br><span class="line">wal_level = hot_standby</span><br><span class="line">max_wal_senders = 5</span><br><span class="line">include_if_exists = <span class="string">&#x27;synchronous_standby_names.conf&#x27;</span></span><br><span class="line">port = 24072</span><br><span class="line"></span><br><span class="line">$ vi data/dn3/postgresql.conf</span><br><span class="line">hot_standby = on</span><br><span class="line"><span class="comment">#logging_collector = on</span></span><br><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">log_line_prefix = <span class="string">&#x27;%t:%r:%u@%d:[%p]: &#x27;</span></span><br><span class="line">wal_keep_segments = 10</span><br><span class="line">wal_level = hot_standby</span><br><span class="line">max_wal_senders = 5</span><br><span class="line">include_if_exists = <span class="string">&#x27;synchronous_standby_names.conf&#x27;</span></span><br><span class="line">port = 24073</span><br></pre></td></tr></table></figure><h2 id="7-3-创建备-DN"><a href="#7-3-创建备-DN" class="headerlink" title="7.3. 创建备 DN"></a>7.3. 创建备 DN</h2><p>在数据库集群开启的前提下执行下列指令，以创建备 Datanode 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pg_basebackup -D data/dn1s -Fp -Xs -v -P -h localhost -p 24071 -U wslu</span><br><span class="line">$ pg_basebackup -D data/dn2s -Fp -Xs -v -P -h localhost -p 24072 -U wslu</span><br><span class="line">$ pg_basebackup -D data/dn3s -Fp -Xs -v -P -h localhost -p 24073 -U wslu</span><br></pre></td></tr></table></figure><h2 id="7-4-在所有备-DN-新建-recovery-conf"><a href="#7-4-在所有备-DN-新建-recovery-conf" class="headerlink" title="7.4. 在所有备 DN 新建 recovery.conf"></a>7.4. 在所有备 DN 新建 recovery.conf</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ vi dn1s/recovery.conf</span><br><span class="line">standby_mode = <span class="string">&#x27;on&#x27;</span></span><br><span class="line">primary_conninfo = <span class="string">&#x27;user=wslu host=localhost port=24071 sslmode=disable sslcompression=1&#x27;</span></span><br><span class="line"></span><br><span class="line">$ vi dn2s/recovery.conf</span><br><span class="line">standby_mode = <span class="string">&#x27;on&#x27;</span></span><br><span class="line">primary_conninfo = <span class="string">&#x27;user=wslu host=localhost port=24072 sslmode=disable sslcompression=1&#x27;</span></span><br><span class="line"></span><br><span class="line">$ vi dn3s/recovery.conf</span><br><span class="line">standby_mode = <span class="string">&#x27;on&#x27;</span></span><br><span class="line">primary_conninfo = <span class="string">&#x27;user=wslu host=localhost port=24073 sslmode=disable sslcompression=1&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="7-5-在所有主-DN-新建-synchronous-standby-names-conf"><a href="#7-5-在所有主-DN-新建-synchronous-standby-names-conf" class="headerlink" title="7.5. 在所有主 DN 新建 synchronous_standby_names.conf"></a>7.5. 在所有主 DN 新建 synchronous_standby_names.conf</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi data/dn1/synchronous_standby_names.conf</span><br><span class="line">synchronous_standby_names=<span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="7-6-在所有-CO-添加备-DN-节点"><a href="#7-6-在所有-CO-添加备-DN-节点" class="headerlink" title="7.6. 在所有 CO 添加备 DN 节点"></a>7.6. 在所有 CO 添加备 DN 节点</h2><p>这里以 co1 为例，co2 也要执行同样操作（ 对于支持热备的其他 pg 商用数据库，类型不是 datanode 而是 standby）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ .<span class="operator">/</span>bin<span class="operator">/</span>psql <span class="operator">-</span>p <span class="number">24076</span> postgres postgres    <span class="operator">/</span><span class="operator">/</span>进入co1创建节点，co1_port<span class="operator">=</span><span class="number">24076</span></span><br><span class="line"> <span class="keyword">CREATE</span> NODE dn1s <span class="keyword">WITH</span> (HOST <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>, type <span class="operator">=</span> <span class="string">&#x27;datanode&#x27;</span>, PORT <span class="operator">=</span> <span class="number">34071</span>, id <span class="operator">=</span> <span class="number">6</span>, content <span class="operator">=</span> <span class="number">1</span>); <span class="operator">/</span><span class="operator">/</span>在协调器上注册节点，各端口号与上面一致</span><br><span class="line"> <span class="keyword">CREATE</span> NODE dn2s <span class="keyword">WITH</span> (HOST <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>, type <span class="operator">=</span> <span class="string">&#x27;datanode&#x27;</span>, PORT <span class="operator">=</span> <span class="number">34072</span>, id <span class="operator">=</span> <span class="number">7</span>, content <span class="operator">=</span> <span class="number">2</span>);</span><br><span class="line"> <span class="keyword">CREATE</span> NODE dn3s <span class="keyword">WITH</span> (HOST <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>, type <span class="operator">=</span> <span class="string">&#x27;datanode&#x27;</span>, PORT <span class="operator">=</span> <span class="number">34073</span>, id <span class="operator">=</span> <span class="number">8</span>, content <span class="operator">=</span> <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="7-7-启动所有备-DN-服务"><a href="#7-7-启动所有备-DN-服务" class="headerlink" title="7.7. 启动所有备 DN 服务"></a>7.7. 启动所有备 DN 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/pg_ctl start -D data/dn1s -l data/dn1s/postgresql.log  -o <span class="string">&quot;-p 34071&quot;</span></span><br><span class="line">./bin/pg_ctl start -D data/dn2s -l data/dn2s/postgresql.log  -o <span class="string">&quot;-p 34072&quot;</span></span><br><span class="line">./bin/pg_ctl start -D data/dn3s -l data/dn3s/postgresql.log  -o <span class="string">&quot;-p 34073&quot;</span></span><br></pre></td></tr></table></figure><p>相应的，停止所有备 DN 节点服务的指令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/pg_ctl stop -D data/dn1s -m immediate</span><br><span class="line">./bin/pg_ctl stop -D data/dn2s -m immediate</span><br><span class="line">./bin/pg_ctl stop -D data/dn3s -m immediate</span><br></pre></td></tr></table></figure><h1 id="8-Q-amp-A"><a href="#8-Q-amp-A" class="headerlink" title="8. Q&amp;A"></a>8. Q&amp;A</h1><h2 id="8-1-如何提升备-DN-为主-DN"><a href="#8-1-如何提升备-DN-为主-DN" class="headerlink" title="8.1. 如何提升备 DN 为主 DN"></a>8.1. 如何提升备 DN 为主 DN</h2><p>我并未实现成功，但参照其他 PostgreSQL 的分布式数据库，步骤如下：</p><ol><li>杀掉主 DN 进程，在备 DN 的目录下创建一个触发文件（例如：promote）文件。</li><li>通过 <code>kill -SIGUSR1 备DN进程号</code> 指令给备 DN 的 postmaster 进程发送一个 SIGUSR1 信号。</li><li>在主 CO 执行类似 <code>alter node dn1s with(promote);</code> 的指令。</li><li>退出 psql，再重新连入 psql。</li><li>此时，备 DN 就作为主 DN 运行了，可执行 DDL、DML 等所有操作。</li></ol><h2 id="8-2-当备-DN-挂掉时，如何关闭主备-DN-之间的数据同步"><a href="#8-2-当备-DN-挂掉时，如何关闭主备-DN-之间的数据同步" class="headerlink" title="8.2. 当备 DN 挂掉时，如何关闭主备 DN 之间的数据同步"></a>8.2. 当备 DN 挂掉时，如何关闭主备 DN 之间的数据同步</h2><p>也就是关闭 walsender 和 walreciever。</p><p>这就涉及到源码级别了，一般做两步：</p><ol><li>将主 DN 状态改为 <code>OutSync</code>（别的数据库的做法）。</li><li>在代码中将 <code>SyncRepStandbyNames</code> 设为 <code>&quot;&quot;</code>。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>本教程关于配置备 DN 的描述只能对各个 DN 的数据做备份，并未成功实现某个 DN 挂掉了自动切换到备 DN。</p><p>另外，我并未在 Postgres-XC（现在 github 改名为了 Postgres-X2）源码的回归测试中看到如何在 pgxc_nodes 系统表创建备 DN 节点。</p><p>不过，GreenPlum（以 PostgreSQL 为基础开发的分布式数据库）有此功能，可做参考。</p><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2016-03-15 19:56:52&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：本篇文章成文时 Postgres-XC 还未改名为 Post</summary>
      
    
    
    
    <category term="Postgres-X2" scheme="http://dbkernel.github.io/categories/Postgres-X2/"/>
    
    
    <category term="Linux" scheme="http://dbkernel.github.io/tags/Linux/"/>
    
    <category term="PostgreSQL" scheme="http://dbkernel.github.io/tags/PostgreSQL/"/>
    
    <category term="Postgres-X2" scheme="http://dbkernel.github.io/tags/Postgres-X2/"/>
    
    <category term="Postgres-XC" scheme="http://dbkernel.github.io/tags/Postgres-XC/"/>
    
  </entry>
  
  <entry>
    <title>特性分析 | GreenPlum Primary/Mirror 同步机制</title>
    <link href="http://dbkernel.github.io/2016/01/21/greenplum-primary-mirror-sync-mechanism/"/>
    <id>http://dbkernel.github.io/2016/01/21/greenplum-primary-mirror-sync-mechanism/</id>
    <published>2016-01-21T12:02:26.000Z</published>
    <updated>2021-09-22T15:24:33.178Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><strong>本文首发于 2016-01-21 20:02:26</strong></p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>PostgreSQL 主备同步机制是通过流复制实现，其原理见 <a href="http://mysql.taobao.org/monthly/2015/10/04/">PG主备流复制机制</a>。</p><p>Greenplum 是基于 PostgreSQL 开发的，它的主备也是通过流复制实现，但是 <strong>Segment 节点中的 Primary 和 Mirror 之间的数据同步是基于文件级别的同步实现的</strong>。</p><p><code>为什么Primary和Mirror不能再使用流复制实现呢？</code></p><blockquote><p>主要有两个原因:</p><ol><li><code>Append Only</code> 表不写 WAL 日志，所以 Append Only 表的数据就不能通过 XLOG 发送到 Mirror 再 Apply 。</li><li><code>pg_control</code>等文件也是不写 WAL 日志，也只能通过文件方式同步到 Mirror 。</li></ol></blockquote><h2 id="GreenPlum-总体结构"><a href="#GreenPlum-总体结构" class="headerlink" title="GreenPlum 总体结构"></a>GreenPlum 总体结构</h2><p>Greenplum 的架构采用了 MPP 无共享体系。在 MPP 系统中，每个数据节点有自己的CPU、磁盘和内存(Share nothing)，每个节点内的 CPU 不能访问另一个节点的内存。节点之间的信息交互是通过节点互联网络实现的，这个过程一般称为<strong>数据重分配</strong>(Data Redistribution)。</p><p>Master 负责协调整个集群 ，一个数据节点可以配置多个节点实例(Segment Instances)，节点实例并行处理查询(SQL)。</p><p><img src="greenplum-architecture-overview.jpg" alt="GreenPlum 总体架构"></p><h2 id="Primary和Mirror同步机制"><a href="#Primary和Mirror同步机制" class="headerlink" title="Primary和Mirror同步机制"></a>Primary和Mirror同步机制</h2><p>Primary 和 Mirror 同步的内容主要有两部分，即<strong>文件</strong>和<strong>数据</strong>。之所以 Primary 和 Mirror 要同步文件，是 Primary 和 Mirror 之间可以自动 failover，只有两者保持同步才能相互替代。如果只把数据同步过去，<code>pg_control、pg_clog、pg_subtrans</code> 没有同步，那么从 Primary 切换到 Mirror 会出现问题。</p><p>Master 和 slave 却不用担心这些问题，Append Only 表的数据只会存在 Segment，所以 <strong>WAL 日志足够保持 Master 和 slave 同步</strong>(只要是流复制，pg_control、pg_clog、pg_subtrans 这些文件Slave会自动更新，无需从 Master 同步)。</p><h3 id="1-数据同步"><a href="#1-数据同步" class="headerlink" title="1. 数据同步"></a>1. 数据同步</h3><p>当 Master 向 Primary 下发执行计划后，Primary 开始执行，如果是 DML 操作，那么 Primary 会产生 XLOG 及更新 page。会在 <code>SlruPhysicalWritePage</code> 函数中(写数据页)产生<code>FileRepOperationOpen、FileRepOperationWrite、FileRepOperationFlush、FileRepOperationClose</code>等指令消息(消息中包含具体要更新的文件page及内容)，通过 <code>primary sender</code> 进程向 Mirror 发送 Message，然后 Mirror 的 <code>mirror consumer</code> 等进程解析消息，执行变更。XLOG 通过<code>XLogWrite</code>函数(写XLOG)执行同样的操作，把 XLOG 更新同步过去。</p><h3 id="2-文件同步"><a href="#2-文件同步" class="headerlink" title="2. 文件同步"></a>2. 文件同步</h3><p>Primary 会有个 <code>recovery</code> 进程，这个进程会循环把 Primary 的  <code>pg_control、pg_clog、pg_subtrans</code> 等文件覆盖到 Mirror。同时检查 XLOG 是否一致，如果不一致以 Primary 为主，对 Mirror 进行覆盖。除了把 Primary 部分文件同步到 Mirror 之外，<code>recovery</code> 进程还会将 Mirror 上面的临时文件删掉。</p><p><img src="greenplum-primary-mirror-sync.jpg" alt="GreenPlum 主从同步机制"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Primary 和 Mirror 同步数据的时候，Primary 对于每一次写 page 都会通过消息发送到 Mirror，如果 Primary 大量的更新 page，那么 Primary 和 Mirror 同步将有可能成为瓶颈。</p><blockquote><p>本文转自：<a href="http://mysql.taobao.org/monthly/2016/01/02/">http://mysql.taobao.org/monthly/2016/01/02/</a></p></blockquote><hr><p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于 2016-01-21 20:02:26&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="GreenPlum" scheme="http://dbkernel.github.io/categories/GreenPlum/"/>
    
    
    <category term="PostgreSQL" scheme="http://dbkernel.github.io/tags/PostgreSQL/"/>
    
    <category term="GreenPlum" scheme="http://dbkernel.github.io/tags/GreenPlum/"/>
    
    <category term="主从同步" scheme="http://dbkernel.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
</feed>
