<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="DBKernel" />



<meta name="description" content="本文首发于 2014-07-21 15:35:30  6. 附录6.1. 字节序与网络序6.1.1. 字节序字节序，顾名思义就是字节的高低位存放顺序。 对于单字节，大部分处理器以相同的顺序处理比特位，因此单字节的存放和传输方式一般相同。 对于多字节数据，如整型（32 位机中一般占 4 字节），在不同的处理器的存放方式主要有两种（以内存中 0x0A0B0C0D 的存放方式为例）。 6.1.1.">
<meta property="og:type" content="article">
<meta property="og:title" content="程序人生 | C语言字节对齐问题详解 - 对齐&#x2F;字节序&#x2F;位序&#x2F;网络序等（下）">
<meta property="og:url" content="http://dbkernel.github.io/2014/07/21/c-language-byte-alignment-problem-in-detail-part-2/index.html">
<meta property="og:site_name" content="DBKernel">
<meta property="og:description" content="本文首发于 2014-07-21 15:35:30  6. 附录6.1. 字节序与网络序6.1.1. 字节序字节序，顾名思义就是字节的高低位存放顺序。 对于单字节，大部分处理器以相同的顺序处理比特位，因此单字节的存放和传输方式一般相同。 对于多字节数据，如整型（32 位机中一般占 4 字节），在不同的处理器的存放方式主要有两种（以内存中 0x0A0B0C0D 的存放方式为例）。 6.1.1.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png">
<meta property="article:published_time" content="2014-07-21T07:35:30.000Z">
<meta property="article:modified_time" content="2022-07-07T02:09:06.253Z">
<meta property="article:author" content="DBKernel">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="字节对齐">
<meta property="article:tag" content="字节序">
<meta property="article:tag" content="网络序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="DBKernel" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">




<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（下） | DBKernel</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DBKernel</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>返回菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:wenshuang_lu@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" rel="noopener" href="https://github.com/dbkernel" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" target="_blank" rel="noopener" href="https://www.zhihu.com/people/dbkernel/posts" title="知乎"></a>
                            
                                <a class="fa SegmentFault" target="_blank" rel="noopener" href="https://segmentfault.com/u/dbkernel" title="SegmentFault"></a>
                            
                                <a class="fa 博客园" target="_blank" rel="noopener" href="https://www.cnblogs.com/dbkernel" title="博客园"></a>
                            
                                <a class="fa CSDN" target="_blank" rel="noopener" href="https://blog.csdn.net/dbkernel" title="CSDN"></a>
                            
                                <a class="fa 掘金" target="_blank" rel="noopener" href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts" title="掘金"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=2109792568" title="网易云音乐"></a>
                            
                                <a class="fa QQ" target="_blank" rel="noopener" href="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/qq/qq-mysql-group.jpeg" title="QQ"></a>
                            
                                <a class="fa 微信" href="https://dbkernel.github.io/images/wechat-gzh.jpeg" title="微信"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APUE/" rel="tag">APUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-Tree/" rel="tag">B-Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ClickHouse/" rel="tag">ClickHouse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/" rel="tag">ClickHouse和他的朋友们</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Count/" rel="tag">Count</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DAG-Scheduler/" rel="tag">DAG Scheduler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GreenPlum/" rel="tag">GreenPlum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HEAP%E5%BC%95%E6%93%8E/" rel="tag">HEAP引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LF-HASH/" rel="tag">LF_HASH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LICENCE/" rel="tag">LICENCE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LSM-Tree/" rel="tag">LSM-Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MEMORY%E5%BC%95%E6%93%8E/" rel="tag">MEMORY引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MTR/" rel="tag">MTR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Materialized-View/" rel="tag">Materialized View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MergeTree/" rel="tag">MergeTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Parser/" rel="tag">Parser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Percona/" rel="tag">Percona</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/" rel="tag">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgres-X2/" rel="tag">Postgres-X2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgres-XC/" rel="tag">Postgres-XC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RadonDB/" rel="tag">RadonDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReplicatedMergeTree/" rel="tag">ReplicatedMergeTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Select/" rel="tag">Select</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/StoneDB/" rel="tag">StoneDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNIX/" rel="tag">UNIX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WAL/" rel="tag">WAL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xenon/" rel="tag">Xenon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xtrabackup/" rel="tag">Xtrabackup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/auto-increment/" rel="tag">auto_increment</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crontab/" rel="tag">crontab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/daemon/" rel="tag">daemon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/df/" rel="tag">df</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/du/" rel="tag">du</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc/" rel="tag">gcc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcov/" rel="tag">gcov</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/getopt/" rel="tag">getopt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/group-by/" rel="tag">group by</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lcov/" rel="tag">lcov</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libpq/" rel="tag">libpq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pg-constraint/" rel="tag">pg_constraint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pg-depend/" rel="tag">pg_depend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pgbench/" rel="tag">pgbench</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipeline/" rel="tag">pipeline</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/processor/" rel="tag">processor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/" rel="tag">主从同步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96%E5%99%A8/" rel="tag">优化器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag">内存分配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95/" rel="tag">回归测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/" rel="tag">字节对齐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/" rel="tag">字节序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB/" rel="tag">存储计算分离</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E6%9F%A5%E8%AF%A2/" rel="tag">并行查询</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/" rel="tag">开源协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/" rel="tag">开源许可证</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1/" rel="tag">本地事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/" rel="tag">测试框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/" rel="tag">系统运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" rel="tag">编译器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BA%8F/" rel="tag">网络序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">网络编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/" rel="tag">问题定位</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://dbkernel.github.io/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">目前从事云数据库MySQL数据库内核研发工作，曾做过Postgres-XC、Greenplum等分布式数据库的内核开发。热衷于研究主流数据库架构、源码，对关系型数据库 MySQL/PostgreSQL及分布式数据库有深入研究。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DBKernel</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DBKernel</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:wenshuang_lu@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/dbkernel" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/dbkernel/posts" title="知乎"></a>
                            
                                <a class="fa SegmentFault" target="_blank" href="https://segmentfault.com/u/dbkernel" title="SegmentFault"></a>
                            
                                <a class="fa 博客园" target="_blank" href="https://www.cnblogs.com/dbkernel" title="博客园"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://blog.csdn.net/dbkernel" title="CSDN"></a>
                            
                                <a class="fa 掘金" target="_blank" href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts" title="掘金"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="https://music.163.com/#/user/home?id=2109792568" title="网易云音乐"></a>
                            
                                <a class="fa QQ" target="_blank" href="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/qq/qq-mysql-group.jpeg" title="QQ"></a>
                            
                                <a class="fa 微信" target="_blank" href="https://dbkernel.github.io/images/wechat-gzh.jpeg" title="微信"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-c-language-byte-alignment-problem-in-detail-part-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/21/c-language-byte-alignment-problem-in-detail-part-2/" class="article-date">
      <time datetime="2014-07-21T07:35:30.000Z" itemprop="datePublished">2014-07-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（下）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/" rel="tag">字节对齐</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/" rel="tag">字节序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BA%8F/" rel="tag">网络序</a></li></ul>
    </div>

        <br></br> <!--字数统计另起一行-->
        
	
		<span class="post-wordcount" itemprop="wordCount">
			字数统计: 5.6k(字) </a>
		</span>
	
	
		<span class="post-readcount" itemprop="timeRequired">
			阅读时长: 22(分)
		</span>
	

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <span id="more"></span>

<blockquote>
<p><strong>本文首发于 2014-07-21 15:35:30</strong></p>
</blockquote>
<h1 id="6-附录"><a href="#6-附录" class="headerlink" title="6. 附录"></a>6. 附录</h1><h2 id="6-1-字节序与网络序"><a href="#6-1-字节序与网络序" class="headerlink" title="6.1. 字节序与网络序"></a>6.1. 字节序与网络序</h2><h3 id="6-1-1-字节序"><a href="#6-1-1-字节序" class="headerlink" title="6.1.1. 字节序"></a>6.1.1. 字节序</h3><p><strong>字节序</strong>，顾名思义就是<strong>字节的高低位存放顺序</strong>。</p>
<p>对于单字节，大部分处理器以相同的顺序处理比特位，因此单字节的存放和传输方式一般相同。</p>
<p>对于多字节数据，如整型（32 位机中一般占 4 字节），在不同的处理器的存放方式主要有两种（以内存中 0x0A0B0C0D 的存放方式为例）。</p>
<h4 id="6-1-1-1-大字节序（Big-Endian，又称大端序或大尾序）"><a href="#6-1-1-1-大字节序（Big-Endian，又称大端序或大尾序）" class="headerlink" title="6.1.1.1. 大字节序（Big-Endian，又称大端序或大尾序）"></a>6.1.1.1. 大字节序（Big-Endian，又称大端序或大尾序）</h4><p>在计算机中，存储介质以下面方式存储整数 0x0A0B0C0D，则称为<strong>大字节序</strong>：</p>
<blockquote>
<p>数据以 8bit 为单位：<br>低地址方向 -&gt; 0x0A 0x0B 0x0C 0x0D -&gt; 高地址方向</p>
<p>数据以 16bit 为单位：<br>低地址方向 -&gt; 0x0A0B 0x0C0D -&gt; 高地址方向</p>
</blockquote>
<p>其中，最高有效位(MSB，Most Significant Byte)0x0A 存储在最低的内存地址处。下个字节 0x0B 存在后面的地址处。同时，最高的 16bit 单元 0x0A0B 存储在低位。</p>
<p>简而言之，大字节序就是<strong>高字节存入低地址，低字节存入高地址</strong>。</p>
<blockquote>
<p>这里讲个词源典故：“endian”一词来源于乔纳森·斯威夫特的小说《格列佛游记》。小说中，小人国为水煮蛋该从大的一端(Big-End)剥开还是小的一端(Little-End)剥开而争论，争论的双方分别被称为 Big-endians 和 Little-endians 。</p>
<p>1980 年，Danny Cohen 在其著名的论文”<em>On Holy Wars and a Plea for Peace</em>“中为平息一场关于字节该以什么样的顺序传送的争论而引用了该词。</p>
</blockquote>
<p>借用上面的典故，想象一下要把熟鸡蛋旋转着稳立起来，大头（高字节）肯定在下面（低地址）^_^</p>
<h4 id="6-1-1-2-小字节序（Little-Endian，又称小端序或小尾序）"><a href="#6-1-1-2-小字节序（Little-Endian，又称小端序或小尾序）" class="headerlink" title="6.1.1.2. 小字节序（Little-Endian，又称小端序或小尾序）"></a>6.1.1.2. 小字节序（Little-Endian，又称小端序或小尾序）</h4><p>在计算机中，存储介质以下面方式存储整数 0x0A0B0C0D 则称为<strong>小字节序</strong>：</p>
<blockquote>
<p>数据以 8bit 为单位：<br>高地址方向 -&gt; 0x0A 0x0B 0x0C 0x0D -&gt; 低地址方向</p>
<p>数据以 16bit 为单位：<br>高地址方向 -&gt; 0x0A0B 0x0C0D -&gt; 低地址方向</p>
</blockquote>
<p>其中，最低有效位(LSB，Least Significant Byte)0x0D 存储在最低的内存地址处。后面字节依次存在后面的地址处。同时，最低的 16bit 单元 0x0A0B 存储在低位。</p>
<p>可见，小字节序就<strong>高字节存入高地址，低字节存入低地址</strong>。</p>
<p>C 语言中的位域结构也要遵循<strong>比特序(类似字节序)</strong> 。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitfield</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a: <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b: <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该位域结构占 1 个字节，假设赋值 a=0x01 和 b=0x02，则大字节机器上该字节为(01)(000010)，小字节机器上该字节为(000010)(01)</strong> 。因此在编写可移植代码时，需要加条件编译。</p>
<p>注意，在包含位域的 C 结构中，<strong>若位域 A 在位域 B 之前定义，则位域 A 所占用的内存空间地址低于位域 B 所占用的内存空间</strong>。</p>
<p>另见以下联合体，在小字节机器上若 low=0x01，high=0x02，则 hex=0x21：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> hex;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> low  : <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> high : <span class="number">4</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;convert;</span><br><span class="line">    convert.low = <span class="number">0x01</span>;</span><br><span class="line">    convert.high = <span class="number">0x02</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hex = 0x%0x\n&quot;</span>, convert.hex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-1-3-注意事项"><a href="#6-1-1-3-注意事项" class="headerlink" title="6.1.1.3. 注意事项"></a>6.1.1.3. 注意事项</h4><p><strong>无论是大字节序，还是小字节序，变量的地址都等于变量所占字节中的低地址。</strong>例如，下述程序中，小字节序输出 0x0D，大字节序输出 0x0A 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> a = <span class="number">0x0A0B0C0D</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%0x\n&quot;</span>, *((<span class="keyword">int8_t</span>*)&amp;dwData));</span><br></pre></td></tr></table></figure>

<h3 id="6-1-2-网络序"><a href="#6-1-2-网络序" class="headerlink" title="6.1.2. 网络序"></a>6.1.2. 网络序</h3><p>网络传输一般采用<strong>大字节序</strong>，也称为<strong>网络字节序</strong>或<strong>网络序</strong>。IP 协议中定义大字节序为网络字节序。</p>
<p>对于可移植的代码来说，将接收的网络数据转换成主机的字节序是必须的，一般会有成对的函数用于把网络数据转换成相应的主机字节序或反之（若主机字节序与网络字节序相同，通常将函数定义为空宏）。</p>
<p>伯克利 socket API 定义了一组转换函数，用于 16 和 32 位整数在网络序和主机字节序之间的转换。<code>htonl、htons</code>用于<strong>主机序转换到网络序</strong>；<code>ntohl、ntohs</code>用于<strong>网络序转换到本机序</strong>。</p>
<p>注意：在大小字节序转换时，必须考虑待转换数据的长度(如 5.1.1 节的数据单元)。另外<strong>对于单字符或小于单字符的几个 bit 数据，是不必转换的</strong>，因为<strong>在机器存储和网络发送的一个字符内的 bit 位存储顺序是一致的</strong>。</p>
<h3 id="6-1-3-位序"><a href="#6-1-3-位序" class="headerlink" title="6.1.3. 位序"></a>6.1.3. 位序</h3><p>用于描述<strong>串行设备的传输顺序</strong>。<strong>一般硬件传输采用小字节序（先传低位），但 I2C 协议采用大字节序</strong>。网络协议中只有<strong>数据链路层</strong>的底端会涉及到。</p>
<h3 id="6-1-4-处理器字节序"><a href="#6-1-4-处理器字节序" class="headerlink" title="6.1.4. 处理器字节序"></a>6.1.4. 处理器字节序</h3><p>不同处理器体系的字节序如下所示：</p>
<ul>
<li>X86、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为 <strong>Little endian</strong>；</li>
<li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC(除 V9 外) 等处理器为 <strong>Big endian</strong>；</li>
<li>ARM、PowerPC (除 PowerPC 970 外)、DEC Alpha，SPARC V9，MIPS，PA-RISC and IA64 等的字节序是<strong>可配置的</strong>。</li>
</ul>
<h3 id="6-1-5-字节序编程"><a href="#6-1-5-字节序编程" class="headerlink" title="6.1.5. 字节序编程"></a>6.1.5. 字节序编程</h3><p>请看下面的语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *((<span class="keyword">short</span>*)<span class="string">&quot;AB&quot;</span>) &gt;&gt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>在大字节序下输出为’A’，小字节序下输出为’B’。</p>
<p>下面的代码可用来判断本地机器字节序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字节序枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    ENDIAN_LITTLE = (INT8U)<span class="number">0X00</span>,</span><br><span class="line">    ENDIAN_BIG    = (INT8U)<span class="number">0X01</span></span><br><span class="line">&#125;E_ENDIAN_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="function">E_ENDIAN_TYPE <span class="title">GetEndianType</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U dwData = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数都从低地址开始访问</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0x78</span> == *((INT8U*)&amp;dwData))</span><br><span class="line">        <span class="keyword">return</span> ENDIAN_LITTLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ENDIAN_BIG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Start of GetEndianTypeTest//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"><span class="function">VOID <span class="title">GetEndianTypeTest</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _BYTE_ORDER == _LITTLE_ENDIAN</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n&quot;</span>, __FUNCTION__,</span><br><span class="line">           (ENDIAN_LITTLE != <span class="built_in">GetEndianType</span>()) ? <span class="string">&quot;ERROR&quot;</span> : <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;Little&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> _BYTE_ORDER == _BIG_ENDIAN</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n&quot;</span>, __FUNCTION__,</span><br><span class="line">           (ENDIAN_BIG != <span class="built_in">GetEndianType</span>()) ? <span class="string">&quot;ERROR&quot;</span> : <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;Big&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//End of GetEndianTypeTest//</span></span><br></pre></td></tr></table></figure>

<p><strong>在字节序不同的平台间的交换数据时，必须进行转换</strong>。比如对于 int 类型，大字节序写入文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">write</span>(fd, &amp;i, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<p>小字节序读出后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">read</span>(fd, &amp;i, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">char</span> buf[<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)];</span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;i, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v = buf[<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) - i - <span class="number">1</span>];</span><br><span class="line">    buf[<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) - <span class="number">1</span>] =  buf[i];</span><br><span class="line">    buf[i] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;i, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<p>上面仅仅是个例子。在不同平台间即使不存在字节序的问题，也尽量不要直接传递二进制数据。作为可选的方式就是使用文本来交换数据，这样至少可以避免字节序的问题。</p>
<p>很多的加密算法为了追求速度，都会采取字符串和数字之间的转换，在计算完毕后，必须注意字节序的问题，在某些实现中可以见到使用预编译的方式来完成，这样很不方便，如果使用前面的语句来判断，就可以自动适应。</p>
<p>字节序问题不仅影响异种平台间传递数据，还影响诸如读写一些特殊格式文件之类程序的可移植性。此时使用预编译的方式来完成也是一个好办法。</p>
<h2 id="6-2-对齐时的填充字节"><a href="#6-2-对齐时的填充字节" class="headerlink" title="6.2. 对齐时的填充字节"></a>6.2. 对齐时的填充字节</h2><p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  c;</span><br><span class="line">    <span class="keyword">int</span>   i;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">    a.c = <span class="number">1</span>; a.i = <span class="number">2</span>; a.s = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(A)=%d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct A));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后输出为 sizeof(A)=12。</p>
<h2 id="6-3-pragma-pack-语法说明"><a href="#6-3-pragma-pack-语法说明" class="headerlink" title="6.3. pragma pack 语法说明"></a>6.3. pragma pack 语法说明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<p>1）<code>#pragma pack(n)</code></p>
<blockquote>
<p>该指令指定结构和联合成员的紧凑对齐。而一个完整的转换单元的结构和联合的紧凑对齐由<code>/Zp</code>选项设置。紧凑对齐用 pack 编译指示在数据说明层设置。该编译指示在其出现后的第一个结构或者联合声明处生效。该编译指示对定义无效。</p>
<p>当使用<code>#pragma pack (n)</code> 时，n 为 1、2、4、8 或 16。第一个结构成员后的每个结构成员都被存储在更小的成员类型或 n 字节界限内。如果使用无参量的<code>#pragma pack</code>，结构成员被紧凑为以<code>/Zp</code>指定的值。该缺省<code>/Zp</code>紧凑值为<code>/Zp 8</code>。</p>
</blockquote>
<p>2）编译器也支持以下增强型语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack( [ [ &#123; push | pop &#125; , ] [identifier, ] ] [ n] )</span></span><br></pre></td></tr></table></figure>

<p>若不同的组件使用 pack 编译指示 指定不同的紧凑对齐, 这个语法允许你把程序组件组合为一个单独的转换单元。</p>
<p>带 push 参量的 pack 编译指示 的每次出现将当前的紧凑对齐存储到一个内部编译器堆栈中。编译指示的参量表从左到右读取。如果使用 push，则当前紧凑值被存储起来；如果给出一个 n 值，该值将成为新的紧凑值。若指定一个标识符，即选定一个名称，则该标识符将和这个新的的紧凑值联系起来。</p>
<p>带一个 pop 参量的 pack 编译指示 的每次出现都会检索内部编译器堆栈顶的值，并使该值为新的紧凑对齐值。如果使用 pop 参量且内部编译器堆栈是空的，则紧凑值为命令行给定的值，并将产生一个警告信息。若使用 pop 且指定一个 n 值，该值将成为新的紧凑值。</p>
<p>若使用 pop 且指定一个标识符，所有存储在堆栈中的值将从栈中删除，直到找到一个匹配的标识符。这个与标识符相关的紧凑值也从栈中移出，并且这个仅在标识符入栈之前存在的紧凑值成为新的紧凑值。如果未找到匹配的标识符, 将使用命令行设置的紧凑值，并且将产生一个一级警告。缺省紧凑对齐为 8。</p>
<p><strong>pack 编译指示 的新的增强功能让你在编写头文件时，确保在遇到该头文件的前后的紧凑值是一样的</strong>。</p>
<h2 id="6-4-Intel-关于内存对齐的说明"><a href="#6-4-Intel-关于内存对齐的说明" class="headerlink" title="6.4. Intel 关于内存对齐的说明"></a>6.4. Intel 关于内存对齐的说明</h2><p>以下内容节选自《Intel Architecture 32 Manual》。</p>
<p>字、双字和四字在自然边界上不需要在内存中对齐。（对于字、双字和四字来说，自然边界分别是偶数地址，可以被 4 整除的地址，和可以被 8 整除的地址。）</p>
<p>无论如何，为了提高程序的性能，数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。</p>
<p>一个字或双字操作数跨越了 4 字节边界，或者一个四字操作数跨越了 8 字节边界，被认为是未对齐的，从而需要两次总线周期来访问内存。一个字起始地址是奇数但却没有跨越字边界被认为是对齐的，能够在一个总线周期中被访问。</p>
<p>某些操作双四字的指令需要内存操作数在自然边界上对齐。如果操作数没有对齐，这些指令将会产生一个通用保护异常(#GP)。双四字的自然边界是能够被 16 整除的地址。其他操作双四字的指令允许未对齐的访问(不会产生通用保护异常)，然而，需要额外的内存总线周期来访问内存中未对齐的数据。</p>
<h2 id="6-5-不同架构处理器的对齐要求"><a href="#6-5-不同架构处理器的对齐要求" class="headerlink" title="6.5. 不同架构处理器的对齐要求"></a>6.5. 不同架构处理器的对齐要求</h2><p><strong>RISC 指令集处理器（MIPS/ARM）</strong>：这种处理器的设计以效率为先，要求所访问的多字节数据（short/int/long）的地址必须是此数据大小的倍数，如 short 数据地址应为 2 的倍数，long 数据地址应为 4 的倍数，也就是说是对齐的。</p>
<p><strong>CISC 指令集处理器(X86)</strong> ：没有上述限制。</p>
<p><strong>对齐处理策略</strong></p>
<p>访问非对齐多字节数据时(pack 数据)，编译器会将指令拆成多条(因为非对齐多字节数据可能跨越地址对齐边界)，保证每条指令都从正确的起始地址上获取数据，但也因此效率比较低。</p>
<p>访问对齐数据时则只用一条指令获取数据，因此对齐数据必须确保其起始地址是在对齐边界上。如果不是在对齐的边界，对 X86 CPU 是安全的，但对 MIPS/ARM 这种 RISC CPU 会出现<code>总线访问异常</code>。</p>
<p>为什么 X86 是安全的呢？</p>
<blockquote>
<p>X86 CPU 是如何进行数据对齐的？</p>
<p>X86 CPU 的<code>EFLAGS寄存器</code>中包含一个特殊的位标志，称为<code>AC</code>(对齐检查的英文缩写)标志。</p>
<p>按照默认设置，当 CPU 首次加电时，该标志被设置为 0。</p>
<p>当该标志是 0 时，CPU 能够自动执行它应该执行的操作，以便成功地访问未对齐的数据值。</p>
<p>然而，如果该标志被设置为 1，每当系统试图访问未对齐的数据时，CPU 就会发出一个<code>INT 17H中断</code>。</p>
<p>X86 的 Windows 2000 和 Windows 98 版本从来不改变这个 CPU 标志位。因此，当应用程序在 X86 处理器上运行时，你根本看不到应用程序中出现数据未对齐的异常条件。</p>
</blockquote>
<p>为什么 MIPS/ARM 不安全呢？</p>
<blockquote>
<p><strong>因为 MIPS/ARM CPU 不能自动处理对未对齐数据的访问</strong>。当未对齐的数据访问发生时，CPU 就会将这一情况通知操作系统。这时，操作系统将会确定它是否应该引发一个数据未对齐异常条件，对 vxworks 是会触发这个异常的。</p>
</blockquote>
<h2 id="6-6-ARM-下的对齐处理"><a href="#6-6-ARM-下的对齐处理" class="headerlink" title="6.6. ARM 下的对齐处理"></a>6.6. ARM 下的对齐处理</h2><p>有部分摘自 ARM 编译器文档对齐部分。</p>
<p>对齐的使用：</p>
<ol>
<li><p><code>__align(num)</code> 用于修改最高级别对象的字节边界。</p>
<blockquote>
<ul>
<li>在汇编中使用 LDRD 或 STRD 时就要用到此命令<code>__align(8)</code>进行修饰限制。来保证数据对象是相应对齐。</li>
<li>这个修饰对象的命令最大是 8 个字节限制，可以让 2 字节的对象进行 4 字节对齐，但不能让 4 字节的对象 2 字节对齐。</li>
<li><code>__align</code>是存储类修改，只修饰最高级类型对象，不能用于结构或者函数对象。</li>
</ul>
</blockquote>
</li>
<li><p><code>__packed</code> 进行一字节对齐。需注意：</p>
<blockquote>
<ul>
<li>不能对 packed 的对象进行对齐；</li>
<li>所有对象的读写访问都进行非对齐访问；</li>
<li>float 及包含 float 的结构联合及未用__packed 的对象将不能字节对齐；</li>
<li>__packed 对局部整型变量无影响。</li>
<li>强制由 unpacked 对象向 packed 对象转化时未定义。整型指针可以合法定义为 packed，如**packed int* p(**packed int 则没有意义)</li>
</ul>
</blockquote>
</li>
</ol>
<p>对齐或非对齐读写访问可能存在的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义如下结构，b的起始地址不对齐。在栈中访问b可能有问题，因为栈上数据对齐访问</span></span><br><span class="line">__packed <span class="class"><span class="keyword">struct</span> <span class="title">STRUCT_TEST</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span>  b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下面的变量定义成全局静态(不在栈上)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">STRUCT_TEST</span> <span class="title">a</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __packed <span class="keyword">int</span> *q; <span class="comment">//定义成__packed来修饰当前q指向为非对齐的数据地址下面的访问则可以</span></span><br><span class="line">    p = (<span class="keyword">char</span>*)&amp;a;</span><br><span class="line">    q = (<span class="keyword">int</span>*)(p + <span class="number">1</span>);</span><br><span class="line">    *q = <span class="number">0x87654321</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 得到赋值的汇编指令很清楚</span></span><br><span class="line"><span class="comment">    ldr      r5,0x20001590 ; = #0x12345678</span></span><br><span class="line"><span class="comment">    [0xe1a00005]   mov     r0,r5</span></span><br><span class="line"><span class="comment">    [0xeb0000b0]   bl      __rt_uwrite4  //在此处调用一个写4字节的操作函数</span></span><br><span class="line"><span class="comment">    [0xe5c10000]   strb    r0,[r1,#0]    //函数进行4次strb操作然后返回，正确访问数据</span></span><br><span class="line"><span class="comment">    [0xe1a02420]   mov     r2,r0,lsr #8</span></span><br><span class="line"><span class="comment">    [0xe5c12001]   strb    r2,[r1,#1]</span></span><br><span class="line"><span class="comment">    [0xe1a02820]   mov     r2,r0,lsr #16</span></span><br><span class="line"><span class="comment">    [0xe5c12002]   strb    r2,[r1,#2]</span></span><br><span class="line"><span class="comment">    [0xe1a02c20]   mov     r2,r0,lsr #24</span></span><br><span class="line"><span class="comment">    [0xe5c12003]   strb    r2,[r1,#3]</span></span><br><span class="line"><span class="comment">    [0xe1a0f00e]   mov     pc,r14</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    若q未加__packed修饰则汇编出来指令如下(会导致奇地址处访问失败)：</span></span><br><span class="line"><span class="comment">    [0xe59f2018]   ldr      r2,0x20001594 ; = #0x87654321</span></span><br><span class="line"><span class="comment">    [0xe5812000]   str     r2,[r1,#0]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//这样很清楚地看到非对齐访问如何产生错误，以及如何消除非对齐访问带来的问题</span></span><br><span class="line">    <span class="comment">//也可看到非对齐访问和对齐访问的指令差异会导致效率问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-7-《The-C-Book》之位域篇"><a href="#6-7-《The-C-Book》之位域篇" class="headerlink" title="6.7. 《The C Book》之位域篇"></a>6.7. 《The C Book》之位域篇</h2><p>While we’re on the subject of structures, we might as well look at bitfields. They can only be declared inside a structure or a union, and allow you to specify some very small objects of a given number of bits in length. Their usefulness is limited and they aren’t seen in many programs, but we’ll deal with them anyway. This example should help to make things clear:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> field1 :<span class="number">4</span>; <span class="comment">//field 4 bits wide</span></span><br><span class="line">    <span class="keyword">unsigned</span>        :<span class="number">3</span>; <span class="comment">//unnamed 3 bit field(allow for padding)</span></span><br><span class="line">    <span class="keyword">signed</span> field2   :<span class="number">1</span>; <span class="comment">//one-bit field(can only be 0 or -1 in two&#x27;s complement)</span></span><br><span class="line">    <span class="keyword">unsigned</span>        :<span class="number">0</span>; <span class="comment">//align next field on a storage unit</span></span><br><span class="line">    <span class="keyword">unsigned</span> field3 :<span class="number">6</span>;</span><br><span class="line">&#125;full_of_fields;</span><br></pre></td></tr></table></figure>

<p>Each field is accessed and manipulated as if it were an ordinary member of a structure. The keywords signed and unsigned mean what you would expect, except that it is interesting to note that a 1-bit signed field on a two’s complement machine can only take the values 0 or -1. The declarations are permitted to include the const and volatile qualifiers.</p>
<p>The main use of bitfields is either to allow tight packing of data or to be able to specify the fields within some externally produced data files. C gives no guarantee of the ordering of fields within machine words, so if you do use them for the latter reason, you program will not only be non-portable, it will be compiler-dependent too. The Standard says that fields are packed into ‘storage units’, which are typically machine words. The packing order, and whether or not a bitfield may cross a storage unit boundary, are implementation defined. To force alignment to a storage unit boundary, a zero width field is used before the one that you want to have aligned.</p>
<p>Be careful using them. It can require a surprising amount of run-time code to manipulate these things and you can end up using more space than they save.</p>
<p>Bit fields do not have addresses—you can’t have pointers to them or arrays of them.</p>
<h2 id="6-8-C-语言字节相关面试题"><a href="#6-8-C-语言字节相关面试题" class="headerlink" title="6.8. C 语言字节相关面试题"></a>6.8. C 语言字节相关面试题</h2><h3 id="6-8-1-Intel-微软-C-语言面试题"><a href="#6-8-1-Intel-微软-C-语言面试题" class="headerlink" title="6.8.1. Intel/微软 C 语言面试题"></a>6.8.1. Intel/微软 C 语言面试题</h3><p>请看下面的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> a; <span class="comment">// 按 min(1,8) 对齐</span></span><br><span class="line">    <span class="keyword">long</span>  b; <span class="comment">// 按 min(4,8) 对齐</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    s1   d;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> e;  <span class="comment">//VC6.0下可能要用__int64代替双long</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ol>
<li>sizeof(s2) = ？</li>
<li>s2 的 s1 中的 a 后面空了几个字节接着是 b？</li>
</ol>
<p>分析：</p>
<blockquote>
<p>成员对齐有一个重要的条件，即<strong>每个成员分别按自己的方式对齐</strong>。</p>
<p>也就是说上面虽然指定了按 8 字节对齐，但并不是所有的成员都是以 8 字节对齐。其对齐的规则是：<strong>每个成员按 <code>其类型的对齐参数（通常是这个类型的大小）</code> 和 <code>指定对齐参数（这里是8字节）</code> 中较小的一个对齐，并且结构的长度必须为所用过的所有对齐参数的整数倍，不够就补空字节。</strong></p>
<p>s1 中成员 a 是 1 字节，默认按 1 字节对齐，而指定对齐参数为 8，两值中取 1，即 a 按 1 字节对齐；成员 b 是 4 个字节，默认按 4 字节对齐，这时就按 4 字节对齐，所以<code>sizeof(s1)应该为8</code>；</p>
<p>s2 中 c 和 s1 中 a 一样，按 1 字节对齐。而 d 是个 8 字节结构体，其默认对齐方式就是所有成员使用的对齐参数中最大的一个，s1 的就是 4。所以，成员 d 按 4 字节对齐。成员 e 是 8 个字节，默认按 8 字节对齐，和指定的一样，所以它对到 8 字节的边界上。这时，已经使用了 12 个字节，所以又添加 4 个字节的空，从第 16 个字节开始放置成员 e。此时长度为 24，并可被 8（成员 e 按 8 字节对齐）整除。这样，一共使用了 24 个字节。</p>
</blockquote>
<p>各个变量在内存中的布局为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c***aa**</span><br><span class="line">bbbb****</span><br><span class="line">dddddddd ——这种“矩阵写法”很方便看出结构体实际大小！</span><br></pre></td></tr></table></figure>

<p>因此，<code>sizeof(S2)结果为24，a后面空了2个字节接着是b</code>。</p>
<p>这里有三点很重要：</p>
<ol>
<li>每个成员分别按自己的方式对齐，并能最小化长度；</li>
<li>复杂类型(如结构)的默认对齐方式是其最长的成员的对齐方式，这样在成员是复杂类型时可以最小化长度；</li>
<li>对齐后的长度必须是成员中最大对齐参数的整数倍，这样在处理数组时可保证每一项都边界对齐。</li>
</ol>
<p>还要注意，“空结构体”(不含数据成员)的大小为 1，而不是 0。试想如果不占空间的话，一个空结构体变量如何取地址、两个不同的空结构体变量又如何得以区分呢？</p>
<h3 id="6-8-2-上海网宿科技面试题"><a href="#6-8-2-上海网宿科技面试题" class="headerlink" title="6.8.2 上海网宿科技面试题"></a>6.8.2 上海网宿科技面试题</h3><p>假设硬件平台是 intel x86(little endian)，以下程序输出什么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设硬件平台是intel x86(little endian)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">uint32_t</span> in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>  b[<span class="number">18</span>];</span><br><span class="line">    <span class="keyword">register</span>  <span class="keyword">char</span>  *p;</span><br><span class="line">    p = (<span class="keyword">char</span> *)∈</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UC(b) (((int)b)&amp;0xff) <span class="comment">//byte转换为无符号int型</span></span></span><br><span class="line">    <span class="built_in">sprintf</span>(b, <span class="string">&quot;%d.%d.%d.%d\n&quot;</span>, <span class="built_in">UC</span>(p[<span class="number">0</span>]), <span class="built_in">UC</span>(p[<span class="number">1</span>]), <span class="built_in">UC</span>(p[<span class="number">2</span>]), <span class="built_in">UC</span>(p[<span class="number">3</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">inet_ntoa</span>(<span class="number">0x12345678</span>);</span><br><span class="line">    <span class="built_in">inet_ntoa</span>(<span class="number">0x87654321</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看如下程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;a;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%d.%d.%d.%d\n&quot;</span>, p[<span class="number">0</span>], p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>按照小字节序的规则，变量 a 在计算机中存储方式为：</strong></p>
<blockquote>
<p>高地址方向 ————–&gt; 低地址方向<br>0x12 0x34 0x56 0x78<br>p[3] p[2] p[1] p[0]</p>
</blockquote>
<p>注意：<strong>p 并不是指向 0x12345678 的开头 0x12，而是指向 0x78</strong>。p[0]到 p[1]的操作是&amp;p[0]+1，因此 p[1]地址比 p[0]地址大。输出结果为<code>120.86.52.18</code>。</p>
<p>反过来的话，令<code>int a = 0x87654321</code>，则输出结果为<code>33.67.101.-121</code>。</p>
<p>为什么有负值呢？</p>
<blockquote>
<p>因为系统默认的 char 是有符号的，本来是 0x87 也就是 135，大于 127 因此就减去 256 得到-121。</p>
</blockquote>
<p>想要得到正值的话只需将<code>char *p = (char *)&amp;a</code>改为<code>unsigned char *p = (unsigned char *)&amp;a</code>即可。</p>
<p>综上不难得出，网宿面试题的答案为<code>120.86.52.18</code>和<code>33.67.101.135</code>。</p>
<blockquote>
<p><strong>说明：</strong><br>本文转载自 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/clover-toeic/p/3853132.html">https://www.cnblogs.com/clover-toeic/p/3853132.html</a></p>
</blockquote>
<hr>
<p>欢迎关注我的微信公众号【数据库内核】：分享主流开源数据库和存储引擎相关技术。</p>
<img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="欢迎关注公众号数据库内核" align="center"/>

<table>
<thead>
<tr>
<th>标题</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>GitHub</td>
<td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td>
</tr>
<tr>
<td>知乎</td>
<td><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td>
</tr>
<tr>
<td>思否（SegmentFault）</td>
<td><a target="_blank" rel="noopener" href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td>
</tr>
<tr>
<td>掘金</td>
<td><a target="_blank" rel="noopener" href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td>
</tr>
<tr>
<td>CSDN</td>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/dbkernel">https://blog.csdn.net/dbkernel</a></td>
</tr>
<tr>
<td>博客园（cnblogs）</td>
<td><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td>
</tr>
</tbody></table>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2014/07/21/c-language-byte-alignment-problem-in-detail-part-2/">程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（下）</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">DBKernel</a></p>
        <p><span>发布时间:</span>2014-07-21, 15:35:30</p>
        <p><span>最后更新:</span>2022-07-07, 10:09:06</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2014/07/21/c-language-byte-alignment-problem-in-detail-part-2/" title="程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（下）">http://dbkernel.github.io/2014/07/21/c-language-byte-alignment-problem-in-detail-part-2/</a>
            <span class="copy-path" data-clipboard-text="原文: http://dbkernel.github.io/2014/07/21/c-language-byte-alignment-problem-in-detail-part-2/　　作者: DBKernel" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2014/08/04/c-traps-and-pitfalls-reading-notes/">
                    程序人生 | 我的《C陷阱与缺陷》读书笔记
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2014/07/21/c-language-byte-alignment-problem-in-detail-part-1/">
                    程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（上）
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E9%99%84%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">6. 附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">6.1. 字节序与网络序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">6.1.1. 字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-1-%E5%A4%A7%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%88Big-Endian%EF%BC%8C%E5%8F%88%E7%A7%B0%E5%A4%A7%E7%AB%AF%E5%BA%8F%E6%88%96%E5%A4%A7%E5%B0%BE%E5%BA%8F%EF%BC%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">6.1.1.1. 大字节序（Big-Endian，又称大端序或大尾序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-2-%E5%B0%8F%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%88Little-Endian%EF%BC%8C%E5%8F%88%E7%A7%B0%E5%B0%8F%E7%AB%AF%E5%BA%8F%E6%88%96%E5%B0%8F%E5%B0%BE%E5%BA%8F%EF%BC%89"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">6.1.1.2. 小字节序（Little-Endian，又称小端序或小尾序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">6.1.1.3. 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E7%BD%91%E7%BB%9C%E5%BA%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">6.1.2. 网络序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E4%BD%8D%E5%BA%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">6.1.3. 位序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">6.1.4. 处理器字节序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-%E5%AD%97%E8%8A%82%E5%BA%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">6.1.5. 字节序编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%AF%B9%E9%BD%90%E6%97%B6%E7%9A%84%E5%A1%AB%E5%85%85%E5%AD%97%E8%8A%82"><span class="toc-number">1.2.</span> <span class="toc-text">6.2. 对齐时的填充字节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-pragma-pack-%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">6.3. pragma pack 语法说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-Intel-%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">1.4.</span> <span class="toc-text">6.4. Intel 关于内存对齐的说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E4%B8%8D%E5%90%8C%E6%9E%B6%E6%9E%84%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AF%B9%E9%BD%90%E8%A6%81%E6%B1%82"><span class="toc-number">1.5.</span> <span class="toc-text">6.5. 不同架构处理器的对齐要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-ARM-%E4%B8%8B%E7%9A%84%E5%AF%B9%E9%BD%90%E5%A4%84%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">6.6. ARM 下的对齐处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E3%80%8AThe-C-Book%E3%80%8B%E4%B9%8B%E4%BD%8D%E5%9F%9F%E7%AF%87"><span class="toc-number">1.7.</span> <span class="toc-text">6.7. 《The C Book》之位域篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-C-%E8%AF%AD%E8%A8%80%E5%AD%97%E8%8A%82%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">6.8. C 语言字节相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-1-Intel-%E5%BE%AE%E8%BD%AF-C-%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.8.1.</span> <span class="toc-text">6.8.1. Intel&#x2F;微软 C 语言面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-2-%E4%B8%8A%E6%B5%B7%E7%BD%91%E5%AE%BF%E7%A7%91%E6%8A%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.8.2.</span> <span class="toc-text">6.8.2 上海网宿科技面试题</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-4 i,
        .toc-level-4 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"true"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（下）　| DBKernel　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2014/08/04/c-traps-and-pitfalls-reading-notes/" title="上一篇: 程序人生 | 我的《C陷阱与缺陷》读书笔记">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2014/07/21/c-language-byte-alignment-problem-in-detail-part-1/" title="下一篇: 程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（上）">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/07/05/mysql-mtr-04-syntax/">特性介绍 | MySQL测试框架 MTR 系列教程（四）：语法篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/06/05/mysql-mtr-03-source-code/">源码分析 | MySQL测试框架 MTR 系列教程（三）：源码篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/04/mysql-threadpool-main-solutions-details/">业内 MySQL 线程池主流方案详解 - MariaDB/Percona/华为/AliSQL/TXSQL/MySQL企业版</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/01/mysql-mtr-02-advanced/">特性介绍 | MySQL 测试框架 MTR 系列教程（二）：进阶篇 - 内存/线程/代码覆盖率/单元/压力测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/18/mysql-mtr-01-introduction/">特性介绍 | MySQL 测试框架 MTR 系列教程（一）：入门篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/06/StoneDB-an-integrated-real-time-HTAP-database/">推荐 | 一体化实时 HTAP 数据库 StoneDB，如何替换 MySQL 并实现近百倍性能提升</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/19/how-to-choose-open-source-licence/">技术分享 | 如何为你的代码选择一个合适的开源协议？</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/26/clickhouse-and-friends-15-groupby/">源码分析 | ClickHouse和他的朋友们（15）Group By 为什么这么快</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/21/clickhouse-and-friends-14-compute-storage/">源码分析 | ClickHouse和他的朋友们（14）存储计算分离方案与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/clickhouse-and-friends-13-replicated-merge-tree/">源码分析 | ClickHouse和他的朋友们（13）ReplicatedMergeTree表引擎及同步机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/clickhouse-and-friends-12-materialized-view/">源码分析 | ClickHouse和他的朋友们（12）神奇的物化视图(Materialized View)与原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/28/clickhouse-and-friends-11-mysql-gtid-replication/">源码分析 | ClickHouse和他的朋友们（11）MySQL实时复制之GTID模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/27/percona-xtrabackup-2.4-vs-8.0/">问题定位 | Peronca Xtrabackup 8.0近日踩坑总结 - xtrabackup 2.4和8.0区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/20/clickhouse-and-friends-10-merge-tree-wal/">源码分析 | ClickHouse和他的朋友们（10）MergeTree Write-Ahead Log</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/28/clickhouse-and-friends-09-mysql-replication/">源码分析 | ClickHouse和他的朋友们（9）MySQL实时复制与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/clickhouse-and-friends-08-parser/">源码分析 | ClickHouse和他的朋友们 (８) 纯手工打造的SQL解析器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/30/clickhouse-and-friends-06-merge-tree-disk-layout/">源码分析 | ClickHouse和他的朋友们（6）MergeTree存储结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/22/clickhouse-and-friends-05-merge-tree-algo/">源码分析 | ClickHouse和他的朋友们（5）存储引擎技术进化与MergeTree</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/clickhouse-and-friends-04-processor/">源码分析 | ClickHouse和他的朋友们（4）Pipeline处理器和调度器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/08/clickhouse-and-friends-03-mysql-protocol-write-stack/">源码分析 | ClickHouse和他的朋友们（3）MySQL Protocol和Write调用栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/07/clickhouse-and-friends-02-mysql-protocol-read-stack/">源码分析 | ClickHouse和他的朋友们（2）MySQL Protocol和Read调用栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/clickhouse-and-friends-01-development/">源码分析 | ClickHouse和他的朋友们（1）编译、开发、测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/mysql-select-count-functions-01-concepts-and-differences/">特性介绍 | MySQL select count(*) 、count(1)、count(列) 详解（1）：概念及区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/mysql-try_acquire_lock_impl-crash-in-5720/">捉虫日记 | MySQL 5.7.20 try_acquire_lock_impl 异常导致mysql crash</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/09/mysql-auto_increment-details-01-concepts-and-usage/">特性介绍 | MySQL 自增列详解（1）：自增列概念及使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/22/mysql-memory-engine-slave-has-local-transactions/">引擎特性 | MySQL MEMORY(HEAP) 存储引擎导致 Slave 节点有本地事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/process-for-starting-the-linux-os/">特性介绍 | Linux 操作系统启动流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/23/description-of-the-crontab-command/">实用工具 | Linux 定时任务 crontab 命令详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/greenplum-parallel-query-optimization-strategy/">特性分析 | GreenPlum 的并行查询优化策略详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/25/postgresql-error-wal-segment-has-already-been-removed/">问题定位 | PostgreSQL 报错 requested WAL segment has already been removed</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/30/test-postgresql-code-coverage-using-gcov-and-lcov/">源码分析 | 使用 gcov 和 lcov 测试 PostgreSQL 代码覆盖率</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/30/postgresql-regression-test-details/">源码分析 | PostgreSQL 回归测试详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/15/how-to-install-postgres-xc-on-linux/">最佳实践 | 源码编译安装配置 Postgres-XC 集群并用 pg_basebackup 配置 Datanode 热备</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/21/greenplum-primary-mirror-sync-mechanism/">特性分析 | GreenPlum Primary/Mirror 同步机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/how-to-install-greenplum-on-linux/">最佳实践 | CentOS 和 Ubuntu 下安装配置 GreenPlum 数据库集群 - 源码 & 安装包</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/23/example-of-postgresql-pgbench/">实用工具 | PostgreSQL 数据库压力测试工具 pgbench 使用示例</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/21/postgresql-primary-standby-streaming-replication/">特性分析 | PostgreSQL Primary/Standby 主备流复制机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/12/example-of-postgresql-libpq/">应用案例 | PostgreSQL libpq 网络库接口操作数据库示例</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/04/postgresql-dependency-constraint-details/">特性介绍 | PostgreSQL 的依赖约束详解 - 系统表 pg_depend & pg_constraint</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/04/c-compiler-memory-allocation-principles/">程序人生 | C 语言编译器对内存空间的分配原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/03/unix-getaddrinfo-function-detailed-usage/">程序人生 | unix 网络编程之 getaddrinfo 函数详解及使用举例</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/08/example-of-linux-daemon-program-design/">程序人生 | Linux Daemon 程序设计示例</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/05/how-to-install-configure-samba-service-in-ubuntu/">系统运维 | Ubuntu 下安装配置samba 服务的详细过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/04/c-traps-and-pitfalls-reading-notes/">程序人生 | 我的《C陷阱与缺陷》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/07/21/c-language-byte-alignment-problem-in-detail-part-2/">程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/07/21/c-language-byte-alignment-problem-in-detail-part-1/">程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/07/10/makefile-common-templates/">程序人生 | Makefile 常用模板 - 静态链接库/动态链接库/可执行文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/07/10/advanced-programming-in-the-unix-environment-du/">程序人生 | UNIX环境高级编程技巧之 du 指令实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/07/10/advanced-programming-in-the-unix-environment-df/">程序人生 | UNIX环境高级编程技巧之 df 指令实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/12/linux-memory-management-parsing/">特性介绍 | Linux 内存管理机制解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/01/10/advanced-programming-in-the-unix-environment-getopt/">程序人生 | UNIX 环境高级编程技巧之 getopt & getopt_long 使用示例</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i>
                2014-2023 DBKernel
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <script src="/js/busuanzi.js"></script>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv">
                        <!--%= __('visit_counter.site_pv') %-->
                        <span id="site-visit" title="本站访问量">
                            <i class="fa fa-eye" aria-hidden="true"></i>
                            <span id="busuanzi_value_site_pv"></span>
                        </span>
                    </span>
                    <span id="busuanzi_container_site_uv">
                        <!--%= __('visit_counter.site_uv') %-->
                        <span id="site-visit" title="本站访客数">
                            <i class="fa fa-user" aria-hidden="true"></i>
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv">
                        <!--%= __('visit_counter.page_pv') %-->
                        <span id="page-visit"  title="本页阅读量">
                            <i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                    <!--span id="busuanzi_container_page_uv">
                        <span id="page-visit"  title="本页访客数">
                            <i class="fa fa-user animated infinite pulse" aria-hidden="true"></i>
                            <span id="busuanzi_value_page_uv"></span>
                        </span>
                    </span-->
                
            </div>
        
    </div>
</footer>
    </div>
    
    
<script src="/js/GithubRepoWidget.js"></script>


<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
             post: ".article-entry a[href], .copyright a[href]", 
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>