<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DBKernel</title>
  
  
  <link href="http://dbkernel.github.io/atom.xml" rel="self"/>
  
  <link href="http://dbkernel.github.io/"/>
  <updated>2021-08-22T05:58:30.795Z</updated>
  <id>http://dbkernel.github.io/</id>
  
  <author>
    <name>DBKernel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术分享 | 如何为你的代码选择一个合适的开源协议？</title>
    <link href="http://dbkernel.github.io/2021/08/19/how-to-choose-open-source-licence/"/>
    <id>http://dbkernel.github.io/2021/08/19/how-to-choose-open-source-licence/</id>
    <published>2021-08-18T16:37:15.000Z</published>
    <updated>2021-08-22T05:58:30.795Z</updated>
    
    <content type="html"><![CDATA[<p>近期公司全面拥抱开源，在选择开源协议方面遇到了一些问题，查阅了很多资料，特此总结~~</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于很多刚踏入开源软件这个行业的小伙伴来说，在编码过程中难免会用到其他人的成果，如果你足够细心，很容易注意到即使是一小段代码，优秀的作者都在文件开头附上一段关于版权的声明，比如 <code>Licensed under the MIT license</code>。同时，一些博客也会标明”此文章采用 <code>CC BY 4.0 CN</code> 协议“。</p><p>如果我们拷贝了别人的代码或文章却没注意版权问题，在国外法律意识特别强的环境下（国内版权意识也在逐步加强），那么我们的作品会因触犯别人的权益而违法。即使是最开放的开源协议，最低要求也是保留原作者对代码的声明，所以<code>开源不等于免费，也不等于没有约束</code>。</p><p><strong>何为 LICENCE？</strong></p><blockquote><p>LICENCE 是软件的授权许可，详细说明了获得代码后拥有的权利，哪些操作是允许的，哪些操作是禁止的。软件的版权许可证可有很多方式，本文仅限于讨论开源软件协议 Open Source License。</p></blockquote><p>对于大多数人来说，没必要花大把时间去写许可协议，选择一种比较流行的开源协议就足够了，省时省力，更便于自己作品的传播，于人于己都有利。</p><p><strong>PS：</strong></p><blockquote><p>说句题外话，很多国外开发者在尊重他人劳动成果方面做得很好，如果A的作品是因为B的作品的启发而来，A甚至都没有使用B任何一句代码，但A会在他的作品里面指明是受到了B的启发：<code>Inspired by XXX link: http://www.xxxx.com</code>。</p></blockquote><h2 id="快速选择开源协议"><a href="#快速选择开源协议" class="headerlink" title="快速选择开源协议"></a>快速选择开源协议</h2><p>如果你不想了解太多，只是想要一个简直直接的答案，下面给出的建议或许适合你。本小节关于协议地址来自于 GitHub <a href="http://choosealicense.com/">choosealicence</a> 。</p><p><strong>简单宽松的协议：</strong></p><blockquote><p>如果你只想要一个简单点的协议不想太麻烦的话。</p><p><a href="http://choosealicense.com/licenses/mit">MIT协议</a>相对宽松，此协议允许别人以任何方式使用你的代码同时署名原作者，但原作者不承担代码使用后的风险，当然也没有技术支持的义务。</p></blockquote><p><strong>考虑有专利的情况：</strong></p><blockquote><p>如果你的作品中涉及到专利相关。</p><p><a href="http://choosealicense.com/licenses/apache/">Apache协议</a>也是个相对宽松的协议，与MIT类似，但它指明了作者对用户专利上的一些授权（我的理解是软件作品中含有专利，但它授权你可以免费使用）。</p></blockquote><p><strong>促进代码分享：</strong></p><blockquote><p>如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。</p><p>GPL（<a href="http://choosealicense.com/licenses/gpl-v2">V2</a>或<a href="http://choosealicense.com/licenses/gpl-v3">V3</a>）协议要求代码分发者或者以此代码为基础开发出来的衍生作品需要以同样的协议来发布，也必须开源，因此，该协议具有”传染性“。</p></blockquote><p>乌克兰程序员<a href="http://pbagwl.com/post/5078147450/description-of-popular-software-licenses">Paul Bagwell</a>，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种开源协议之间的最大区别。<br><img src="paul-bagwell-licence.jpeg" alt="Paul Bagwell的LICENCE分析图"></p><p>国内大神阮一峰的汉化版本：<br><img src="ruan-yi-feng-licence.jpeg" alt="阮一峰的LICENCE分析图"></p><h2 id="主流开源许可协议（Open-Source-License）"><a href="#主流开源许可协议（Open-Source-License）" class="headerlink" title="主流开源许可协议（Open Source License）"></a>主流开源许可协议（Open Source License）</h2><p>世界上的开源许可协议（Open Source License）大概有<a href="https://www.gnu.org/licenses/license-list.html">上百种</a>，常用的开源软件协议大致有：</p><ul><li><a href="https://www.gnu.org/licenses/gpl-3.0.html">GPL</a></li><li><a href="https://www.gnu.org/licenses/lgpl-3.0.html">LGPL</a></li><li><a href="https://opensource.org/licenses/BSD-3-Clause">BSD</a></li><li><a href="https://opensource.org/licenses/mit-license.php">MIT</a></li><li><a href="https://opensource.org/licenses/MPL-2.0">Mozilla</a></li><li><a href="http://www.apache.org/licenses/LICENSE-2.0">Apache</a></li></ul><p>由宽松到严紧排序，常用的开源协议有：</p><ol><li>MIT</li><li>BSD</li><li>Apache</li><li>LGPL</li><li>GPL</li></ol><p>主要区别：</p><ul><li>MIT、BSD 开源协议都源自大学，体现了简单、开放和包容的特点。</li><li>MIT、BSD、Apache 三者都支持闭源的后续开发。</li><li>GPL、LGPL 传染性开源，编译的代码里用了这里的代码，都必须开源。</li></ul><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>来源于大学，MIT 开源协议是史上最为简洁、慷慨的开源协议之一。作者只想保留版权，而无任何其他了限制。也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。</p><p><strong>特点：</strong></p><ul><li>用户可以拿你的代码做任何想做的事情。</li><li>用户在项目副本中要包含版权声明和许可声明。</li><li>你无需承担任何责任。</li></ul><p><strong>代表作品：</strong></p><ul><li><a href="https://github.com/jquery/jquery">jQuery</a></li><li><a href="https://github.com/rails/rails">Rails</a> 等。</li></ul><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><ul><li><a href="https://opensource.org/licenses/BSD-2-Clause">BSD-2-Clause</a></li><li><a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a></li></ul><p>BSD可证也来源于大学，与MIT差不多，也非常简单、慷慨。</p><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用、修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。前提是当你发布使用了BSD协议的代码，或者以BSD协议代码为基础开发自己的产品时，需要满足三个条件：</p><ol><li>如果再发布的产品中包含源代码，则在源代码中必须带有原代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ol><p>BSD 开源协议鼓励代码共享，但需要尊重代码作者的著作权。BSD 开源协议允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布、销售，是对商业集成很友好的协议。因此，很多公司在选用开源产品的时候都首选BSD协议。</p><h3 id="Apache-Licence"><a href="#Apache-Licence" class="headerlink" title="Apache Licence"></a>Apache Licence</h3><ul><li><a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a></li><li><a href="https://www.apache.org/licenses/LICENSE-1.1">Apache License, Version 1.1</a></li><li><a href="https://www.apache.org/licenses/LICENSE-1.0">Apache License, Version 1.0</a></li></ul><p>来自 Apache，类似 MIT 开源协议，但它重视专利权。</p><p>Apache Licence 是著名的非盈利开源组织 Apache 采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许修改代码、再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p><ol><li>需要为使用代码的用户提供一份 Apache Licence 。</li><li>如果你修改了代码，需要在被修改的文件中说明。</li><li>在延伸的代码中（修改和由源代码衍生的代码中）需要带有原来代码中的协议、商标、专利声明和其他原作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个<code>Notice</code>文件，则在Notice文件中需要带有 Apache Licence 。你可以在<code>Notice</code>中增加自己的许可，但不可对 Apache Licence 构成更改。</li></ol><p>Apache Licence 也是对商业应用友好的许可，使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p><p><strong>代表作品：</strong></p><ul><li><a href="https://github.com/apache/echarts">echarts</a></li><li><a href="https://github.com/apache/superset">superset</a></li><li><a href="https://github.com/apache/dubbo">dubbo</a></li><li><a href="https://github.com/apache/spark">spark</a></li></ul><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>LGPL（GNU LESSER GENERAL PUBLIC LICENSE）来自于自由软件联盟GNU，可以翻译为更宽松的GPL协议，也属于传染性开源协议。</p><p>LGPL是GPL的一个主要为类库使用设计的开源协议。和<code>GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议</code>不同，LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议，因此，LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL（GNU GENERAL PUBLIC LICENSE）来源于自由软件联盟GNU，GPL/LGPL侧重于代码及衍生代码的开源与免费使用。</p><p>GPL协议的主要内容是只要在一个软件中使用（”使用”指类库引用，修改后的代码或者衍生代码）GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。<strong>这就是所谓的”传染性”</strong>。</p><p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p><p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是<code>代码的开源/免费使用/引用/修改</code>和<code>衍生代码的开源/免费使用</code>，但<code>不允许</code>修改后和衍生的代码做为<code>闭源</code>的商业软件发布和销售。</p><p>其它细节和BSD/Apache等协议类似。</p><p><strong>代表作品：</strong></p><ul><li><a href="https://github.com/torvalds/linux">Linux</a></li></ul><h2 id="更多开源协议对比"><a href="#更多开源协议对比" class="headerlink" title="更多开源协议对比"></a>更多开源协议对比</h2><p>下方表格中出现的用词的解释：</p><ul><li><strong>协议和版权信息</strong>(License and copyright notice)：在代码中保留作者提供的协议和版权信息。</li><li><strong>声明变更</strong>(State Changes)：在代码中声明对原来代码的重大修改及变更。</li><li><strong>公开源码</strong>(Disclose Source)：代码必需公开。</li><li><strong>库引用</strong>(Library usage)：该库可以用于商业软件中。</li><li><strong>责任承担</strong>(Hold Liable)：代码的作者承担代码使用后的风险及产生的后果。如果禁止，那么作者将不会承担责任，可以理解为免责条款。</li><li><strong>商标使用</strong>(Use Trademark)：可以使用作者的姓名，作品的Logo，或商标。</li><li><strong>附加协议</strong>(Sublicensing)：允许在软件分发传播过程中附加上原来没有的协议条款等。</li></ul><table><thead><tr><th>协议</th><th>描述</th><th>要求</th><th>允许</th><th>禁止</th></tr></thead><tbody><tr><td><a href="http://choosealicense.com/licenses/apache/">Apache</a></td><td>一个比较宽松且简明地指出了专利授权的协议。</td><td>1. <font color=#0000FF>协议和版权信息</font><br/>2. <font color=#0000FF>声明变更</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font><br/>6. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font>（作者免责）<br/>2. <font color=#FF3030>商标使用</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/gpl-v2/">GPL</a></td><td>应用最广泛的开源协议，拥有较强的版权自由（copyleft）要求。<br/>衍生代码的分发需开源并且也要遵守此协议。<br/>此协议有许多变种，不同变种的要求略有不同。</td><td>1. <font color=#0000FF>公开源码</font><br/>2. <font color=#0000FF>协议和版权信息</font><br/>3. <font color=#0000FF>声明变更</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font></td><td>1. <font color=#FF3030>责任承担</font><br/>2. <font color=#FF3030>附加协议</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/mit/">MIT</a></td><td>此协议宽松简单。在适当标明来源及免责的情况下，<br/>它允许你对代码进行任何形式的使用。</td><td>1. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>私用</font><br/>5. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/artistic/">Artistic</a></td><td>Perl社区最钟爱此协议。<br/>要求更改后的软件不能影响原软件的使用。</td><td>1. <font color=#0000FF>协议和版权信息</font><br/>2. <font color=#0000FF>声明变更</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>私用</font><br/>5. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font><br/>2. <font color=#FF3030>商标使用</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/bsd/">BSD</a></td><td>较为宽松的协议，有两个变种<a href="http://choosealicense.com/licenses/bsd"><strong>BSD 2-Clause</strong></a> 和<a href="http://choosealicense.com/licenses/bsd-3-clause"><strong>BSD 3-Clause</strong></a>，<br/>两者都与MIT协议只存在细微差异。</td><td>1. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>私用</font><br/>5. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/eclipse/">Eclipse</a></td><td>对商用非常友好的协议，可以用于软件的商业授权。<br/>包含对专利的优雅授权，也可以对相关代码应用商业协议。</td><td>1. <font color=#0000FF>公开源码</font><br/>2. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font><br/>6. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/lgpl-v2.1/">LGPL</a></td><td>主要用于一些代码库。<br/>衍生代码可以以此协议发布（也可以用其他协议），<br/>但与此协议相关的代码必需遵循此协议。</td><td>1. <font color=#0000FF>公开源码</font><br/>2. <font color=#0000FF>库引用</font><br/>3. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font><br/>6. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/mozilla/">Mozilla</a></td><td>Mozilla Public License(MPL 2.0)是由Mozilla基金创建维护的，<br/>旨在较为宽松的BSD协议和更加互惠的GPL协议中找一个折衷点。</td><td>1. <font color=#0000FF>公开源码</font><br/>2. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>专利授权</font><br/>5. <font color=#00EE00>私用</font><br/>6. <font color=#00EE00>附加协议</font></td><td>1. <font color=#FF3030>责任承担</font><br/>2. <font color=#FF3030>商标使用</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/no-license/">No license</a></td><td>作者保留所有权利，不允许他人分发，复制或者创造衍生物。<br/>当你将代码发表在一些网站上时需要遵守该网站的协议，<br/>此协议可能包含了一些对你劳动成果的授权许可。<br/>比如将代码发布到GitHub，那么就必须同意别人查看和fork。</td><td>1. <font color=#0000FF>协议和版权信息</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>私用</font></td><td>1. <font color=#FF3030>分发</font><br/>2. <font color=#FF3030>修改</font><br/>3. <font color=#FF3030>附加协议</font></td></tr><tr><td><a href="http://choosealicense.com/licenses/unlicense/">Public domain dedication</a></td><td>在许多国家，默认版权归作者自动拥有，<br/>所以<a href="http://unlicense.org/">Unlicense</a>协议提供了一种通用的模板。<br/>此协议表明作者放弃版权，将劳动成果无私贡献出来，<br/>会丧失作品全部权利，包括在MIT/X11中定义的无担保权利。</td><td>1. <font color=#0000FF>N/A</font></td><td>1. <font color=#00EE00>商用</font><br/>2. <font color=#00EE00>分发</font><br/>3. <font color=#00EE00>修改</font><br/>4. <font color=#00EE00>私用</font></td><td>1. <font color=#FF3030>责任承担</font></td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/github/choosealicense.com">https://github.com/github/choosealicense.com</a></li><li><a href="https://opensource.org/licenses">https://opensource.org/licenses</a></li><li><a href="https://www.cnblogs.com/Wayou/p/how_to_choose_a_license.html">https://www.cnblogs.com/Wayou/p/how_to_choose_a_license.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/87855729">https://zhuanlan.zhihu.com/p/87855729</a></li></ul><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期公司全面拥抱开源，在选择开源协议方面遇到了一些问题，查阅了很多资料，特此总结~~&lt;/p&gt;</summary>
    
    
    
    <category term="开源" scheme="http://dbkernel.github.io/categories/%E5%BC%80%E6%BA%90/"/>
    
    
    <category term="开源协议" scheme="http://dbkernel.github.io/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="开源许可证" scheme="http://dbkernel.github.io/tags/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/"/>
    
    <category term="LICENCE" scheme="http://dbkernel.github.io/tags/LICENCE/"/>
    
    <category term="github" scheme="http://dbkernel.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（3）MySQL Protocol和Write调用栈</title>
    <link href="http://dbkernel.github.io/2020/06/08/clickhouse-and-friends-03-mysql-protocol-write-stack/"/>
    <id>http://dbkernel.github.io/2020/06/08/clickhouse-and-friends-03-mysql-protocol-write-stack/</id>
    <published>2020-06-08T11:57:10.000Z</published>
    <updated>2021-08-22T05:59:19.549Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/06/08/clickhouse-and-friends-mysql-protocol-write-stack/">https://bohutang.me/2020/06/08/clickhouse-and-friends-mysql-protocol-write-stack/</a><br>以下为正文。</p></blockquote><p>上篇的<a href="https://dbkernel.github.io/2020/06/07/clickhouse-and-friends-02-mysql-protocol-read-stack/">MySQL Protocol和Read调用</a>里介绍了 ClickHouse 一条查询语句的调用栈，本文继续介绍写的调用栈，开整。</p><h2 id="Write请求"><a href="#Write请求" class="headerlink" title="Write请求"></a><strong>Write请求</strong></h2><ol><li><p>建表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(a UInt8, b UInt8, c UInt8) ENGINE<span class="operator">=</span>MergeTree() <span class="keyword">PARTITION</span> <span class="keyword">BY</span> (a, b) <span class="keyword">ORDER</span> <span class="keyword">BY</span> c;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="调用栈分析"><a href="#调用栈分析" class="headerlink" title="调用栈分析"></a><strong>调用栈分析</strong></h2><h3 id="1-获取存储引擎-OutputStream"><a href="#1-获取存储引擎-OutputStream" class="headerlink" title="1. 获取存储引擎 OutputStream"></a>1. 获取存储引擎 OutputStream</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DB::StorageMergeTree::<span class="built_in">write</span>(std::__1::shared_ptr&lt;DB::IAST&gt; <span class="keyword">const</span>&amp;, DB::Context <span class="keyword">const</span>&amp;) StorageMergeTree.cpp:<span class="number">174</span></span><br><span class="line">DB::PushingToViewsBlockOutputStream::<span class="built_in">PushingToViewsBlockOutputStream</span>(std::__1::shared_ptr&lt;DB::IStorage&gt; <span class="keyword">const</span>&amp;, DB::Context <span class="keyword">const</span>&amp;, std::__1::shared_ptr&lt;DB::IAST&gt; <span class="keyword">const</span>&amp;, <span class="keyword">bool</span>) PushingToViewsBlockOutputStream.cpp:<span class="number">110</span></span><br><span class="line">DB::InterpreterInsertQuery::<span class="built_in">execute</span>() InterpreterInsertQuery.cpp:<span class="number">229</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, DB::Context &amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer *) executeQuery.cpp:<span class="number">364</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">696</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h3 id="2-从-SQL-组装-InputStream"><a href="#2-从-SQL-组装-InputStream" class="headerlink" title="2. 从 SQL 组装 InputStream"></a>2. 从 SQL 组装 InputStream</h3><p><code>(1,1,1), (2,2,2)</code> 如何组装成 inputstream 结构呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DB::InputStreamFromASTInsertQuery::<span class="built_in">InputStreamFromASTInsertQuery</span>(std::__1::shared_ptr&lt;DB::IAST&gt; <span class="keyword">const</span>&amp;, DB::ReadBuffer*,</span><br><span class="line">DB::InterpreterInsertQuery::<span class="built_in">execute</span>() InterpreterInsertQuery.cpp:<span class="number">300</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">char</span> <span class="keyword">const</span>*, DB::Context&amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer*) executeQuery.cpp:<span class="number">386</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">313</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">150</span></span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.in = std::make_shared&lt;InputStreamFromASTInsertQuery&gt;(query_ptr, <span class="literal">nullptr</span>, query_sample_block, context, <span class="literal">nullptr</span>);</span><br><span class="line">res.in = std::make_shared&lt;NullAndDoCopyBlockInputStream&gt;(res.in, out_streams.<span class="built_in">at</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>通过 NullAndDoCopyBlockInputStream的 copyData 方法构造出 Block：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DB::ValuesBlockInputFormat::<span class="built_in">readRow</span>(std::__1::vector&lt;COW&lt;DB::IColumn&gt;::mutable_ptr&lt;DB::IColumn&gt;, std::__1::allocator&lt;COW&lt;DB::IColumn&gt;::mutable_ptr&lt;DB::IColumn&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) ValuesBlockInputFormat.cpp:<span class="number">93</span></span><br><span class="line">DB::ValuesBlockInputFormat::<span class="built_in">generate</span>() ValuesBlockInputFormat.cpp:<span class="number">55</span></span><br><span class="line">DB::ISource::<span class="built_in">work</span>() ISource.cpp:<span class="number">48</span></span><br><span class="line">DB::InputStreamFromInputFormat::<span class="built_in">readImpl</span>() InputStreamFromInputFormat.h:<span class="number">48</span></span><br><span class="line">DB::IBlockInputStream::<span class="built_in">read</span>() IBlockInputStream.cpp:<span class="number">57</span></span><br><span class="line">DB::InputStreamFromASTInsertQuery::<span class="built_in">readImpl</span>() InputStreamFromASTInsertQuery.h:<span class="number">31</span></span><br><span class="line">DB::IBlockInputStream::<span class="built_in">read</span>() IBlockInputStream.cpp:<span class="number">57</span></span><br><span class="line"><span class="keyword">void</span> DB::copyDataImpl&lt;DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*)::$_0&amp;, <span class="built_in"><span class="keyword">void</span></span> (&amp;)(DB::Block <span class="keyword">const</span>&amp;)&gt;(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*)::$_0&amp;, <span class="built_in"><span class="keyword">void</span></span> (&amp;)(DB::Block <span class="keyword">const</span>&amp;)) copyData.cpp:<span class="number">26</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*) copyData.cpp:<span class="number">62</span></span><br><span class="line">DB::NullAndDoCopyBlockInputStream::<span class="built_in">readImpl</span>() NullAndDoCopyBlockInputStream.h:<span class="number">47</span></span><br><span class="line">DB::IBlockInputStream::<span class="built_in">read</span>() IBlockInputStream.cpp:<span class="number">57</span></span><br><span class="line"><span class="keyword">void</span> DB::copyDataImpl&lt;std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;&gt;(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">26</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">73</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">785</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">313</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">150</span></span><br></pre></td></tr></table></figure><h3 id="3-组装-OutputStream"><a href="#3-组装-OutputStream" class="headerlink" title="3. 组装 OutputStream"></a>3. 组装 OutputStream</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DB::InterpreterInsertQuery::<span class="built_in">execute</span>() InterpreterInsertQuery.cpp:<span class="number">107</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, DB::Context &amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer *) executeQuery.cpp:<span class="number">364</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">696</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><p>组装顺序:</p><ol><li>NullAndDoCopyBlockInputStream</li><li>CountingBlockOutputStream</li><li>AddingDefaultBlockOutputStream</li><li>SquashingBlockOutputStream</li><li>PushingToViewsBlockOutputStream</li><li>MergeTreeBlockOutputStream</li></ol><h3 id="4-写入OutputStream"><a href="#4-写入OutputStream" class="headerlink" title="4. 写入OutputStream"></a>4. 写入OutputStream</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DB::MergeTreeBlockOutputStream::<span class="built_in">write</span>(DB::Block <span class="keyword">const</span>&amp;) MergeTreeBlockOutputStream.cpp:<span class="number">17</span></span><br><span class="line">DB::PushingToViewsBlockOutputStream::<span class="built_in">write</span>(DB::Block <span class="keyword">const</span>&amp;) PushingToViewsBlockOutputStream.cpp:<span class="number">145</span></span><br><span class="line">DB::SquashingBlockOutputStream::<span class="built_in">finalize</span>() SquashingBlockOutputStream.cpp:<span class="number">30</span></span><br><span class="line">DB::SquashingBlockOutputStream::<span class="built_in">writeSuffix</span>() SquashingBlockOutputStream.cpp:<span class="number">50</span></span><br><span class="line">DB::AddingDefaultBlockOutputStream::<span class="built_in">writeSuffix</span>() AddingDefaultBlockOutputStream.cpp:<span class="number">25</span></span><br><span class="line">DB::CountingBlockOutputStream::<span class="built_in">writeSuffix</span>() CountingBlockOutputStream.h:<span class="number">37</span></span><br><span class="line">DB::copyDataImpl&lt;DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*)::&lt;<span class="built_in">lambda</span>()&gt;&amp;, <span class="built_in"><span class="keyword">void</span></span> (&amp;)(<span class="keyword">const</span> DB::Block&amp;)&gt;(DB::IBlockInputStream &amp;, DB::IBlockOutputStream &amp;, &lt;<span class="built_in">lambda</span>()&gt; &amp;, <span class="built_in"><span class="keyword">void</span></span> (&amp;)(<span class="keyword">const</span> DB::Block &amp;)) copyData.cpp:<span class="number">52</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*) copyData.cpp:<span class="number">138</span></span><br><span class="line">DB::NullAndDoCopyBlockInputStream::<span class="built_in">readImpl</span>() NullAndDoCopyBlockInputStream.h:<span class="number">57</span></span><br><span class="line">DB::IBlockInputStream::<span class="built_in">read</span>() IBlockInputStream.cpp:<span class="number">60</span></span><br><span class="line"><span class="keyword">void</span> DB::copyDataImpl&lt;std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;&gt;(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">29</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">154</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">748</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><p>通过 copyData 方法，让数据在 OutputStream 间层层透传，一直到 MergeTreeBlockOutputStream。</p><h3 id="5-返回-Client"><a href="#5-返回-Client" class="headerlink" title="5. 返回 Client"></a>5. 返回 Client</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DB::MySQLOutputFormat::<span class="built_in">finalize</span>() MySQLOutputFormat.cpp:<span class="number">62</span></span><br><span class="line">DB::IOutputFormat::<span class="built_in">doWriteSuffix</span>() IOutputFormat.h:<span class="number">78</span></span><br><span class="line">DB::OutputStreamToOutputFormat::<span class="built_in">writeSuffix</span>() OutputStreamToOutputFormat.cpp:<span class="number">18</span></span><br><span class="line">DB::MaterializingBlockOutputStream::<span class="built_in">writeSuffix</span>() MaterializingBlockOutputStream.h:<span class="number">22</span></span><br><span class="line"><span class="keyword">void</span> DB::copyDataImpl&lt;std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;&gt;(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">52</span></span><br><span class="line">DB::<span class="built_in">copyData</span>(DB::IBlockInputStream&amp;, DB::IBlockOutputStream&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">bool</span></span> ()&gt; <span class="keyword">const</span>&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (DB::Block <span class="keyword">const</span>&amp;)&gt; <span class="keyword">const</span>&amp;) copyData.cpp:<span class="number">154</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">748</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>首先内核解析 SQL 语句生成 AST，根据 AST 获取 Interpreter：InterpreterInsertQuery。<br>其次 Interpreter 依次添加相应的 OutputStream。<br>然后从 InputStream 读取数据，写入到 OutputStream，stream 会层层渗透，一直写到底层的存储引擎。<br>最后写入到 Socket Output，返回结果。</p><p>ClickHouse 的 OutputStream 编排还是比较复杂，缺少类似 Pipeline 的调度和编排，但是由于模式比较固化，目前看还算清晰。</p><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://bohutang.me/&quot;&gt;BohuTANG&lt;/a&gt; 的博客，原文链接：&lt;br&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（2）MySQL Protocol和Read调用栈</title>
    <link href="http://dbkernel.github.io/2020/06/07/clickhouse-and-friends-02-mysql-protocol-read-stack/"/>
    <id>http://dbkernel.github.io/2020/06/07/clickhouse-and-friends-02-mysql-protocol-read-stack/</id>
    <published>2020-06-07T09:17:10.000Z</published>
    <updated>2021-08-22T06:00:12.009Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/06/07/clickhouse-and-friends-mysql-protocol-read-stack/">https://bohutang.me/2020/06/07/clickhouse-and-friends-mysql-protocol-read-stack/</a><br>以下为正文。</p></blockquote><p>作为一个 OLAP 的 DBMS 来说，有2个端非常重要：</p><ul><li>用户如何方便的链进来，这是入口端<ul><li>ClickHouse 除了自己的 client 外，还提供了 MySQL/PG/GRPC/HTTP 等接入方式</li></ul></li><li>数据如何方便的挂上去，这是数据源端<ul><li>ClickHouse 除了自己的引擎外，还可以挂载 MySQL/Kafka 等外部数据源</li></ul></li></ul><p>这样内外互通，多条朋友多条路，以实现“数据”级的编排能力。</p><p>今天谈的是入口端的 MySQL 协议，也是本系列 ClickHouse 的第一个好朋友，用户可通过 MySQL 客户端或相关 Driver 直接链接到 ClickHouse，进行数据读写等操作。</p><p>本文通过 MySQL的 Query 请求，借用调用栈来了解下 ClickHouse 的数据读取全过程。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a><strong>如何实现？</strong></h2><p>入口文件在:<br><a href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Server/MySQLHandler.cpp">MySQLHandler.cpp</a></p><h3 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a><strong>握手协议</strong></h3><ol><li>MySQLClient 发送 Greeting 数据报文到 MySQLHandler</li><li>MySQLHandler 回复一个 Greeting-Response 报文</li><li>MySQLClient 发送认证报文</li><li>MySQLHandler 对认证报文进行鉴权，并返回鉴权结果</li></ol><p>MySQL Protocol 实现在: <a href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Core/MySQLProtocol.h">Core/MySQLProtocol.h</a></p><blockquote><p>最近的代码中调整为了 <a href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Core/MySQL/PacketsProtocolText.h">Core/MySQL/PacketsProtocolText.h</a></p></blockquote><h3 id="Query请求"><a href="#Query请求" class="headerlink" title="Query请求"></a><strong>Query请求</strong></h3><p>当认证通过后，就可以进行正常的数据交互了。</p><ol><li><p>当 MySQLClient 发送请求:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> system.numbers LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>MySQLHandler 的调用栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;MySQLHandler::comQuery -&gt; executeQuery -&gt; pipeline-&gt;execute -&gt; MySQLOutputFormat::consume</span><br></pre></td></tr></table></figure></li><li><p>MySQLClient 接收到结果</p></li></ol><p>在步骤2里，executeQuery(executeQuery.cpp)非常重要。<br>它是所有前端 Server 和 ClickHouse 内核的接入口，第一个参数是 SQL 文本(‘select 1’)，第二个参数是结果集要发送到哪里去(socket net)。</p><h2 id="调用栈分析"><a href="#调用栈分析" class="headerlink" title="调用栈分析"></a><strong>调用栈分析</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM system.numbers LIMIT 5</span><br></pre></td></tr></table></figure><h3 id="1-获取数据源"><a href="#1-获取数据源" class="headerlink" title="1. 获取数据源"></a>1. 获取数据源</h3><p>StorageSystemNumbers 数据源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DB::StorageSystemNumbers::<span class="built_in">read</span>(std::__1::vector&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; &gt; &gt; <span class="keyword">const</span>&amp;, std::__1::shared_ptr&lt;DB::StorageInMemoryMetadata <span class="keyword">const</span>&gt; <span class="keyword">const</span>&amp;, DB::SelectQueryInfo <span class="keyword">const</span>&amp;, DB::Context <span class="keyword">const</span>&amp;, DB::QueryProcessingStage::Enum, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>) StorageSystemNumbers.cpp:<span class="number">135</span></span><br><span class="line">DB::ReadFromStorageStep::<span class="built_in">ReadFromStorageStep</span>(std::__1::shared_ptr&lt;DB::RWLockImpl::LockHolderImpl&gt;, std::__1::shared_ptr&lt;DB::StorageInMemoryMetadata <span class="keyword">const</span>&gt;&amp;, DB::SelectQueryOptions,</span><br><span class="line">DB::InterpreterSelectQuery::<span class="built_in">executeFetchColumns</span>(DB::QueryProcessingStage::Enum, DB::QueryPlan&amp;, std::__1::shared_ptr&lt;DB::PrewhereInfo&gt; <span class="keyword">const</span>&amp;, std::__1::vector&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; &gt; &gt; <span class="keyword">const</span>&amp;) memory:<span class="number">3028</span></span><br><span class="line">DB::InterpreterSelectQuery::<span class="built_in">executeFetchColumns</span>(DB::QueryProcessingStage::Enum, DB::QueryPlan&amp;, std::__1::shared_ptr&lt;DB::PrewhereInfo&gt; <span class="keyword">const</span>&amp;, std::__1::vector&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; &gt; &gt; <span class="keyword">const</span>&amp;) InterpreterSelectQuery.cpp:<span class="number">1361</span></span><br><span class="line">DB::InterpreterSelectQuery::<span class="built_in">executeImpl</span>(DB::QueryPlan&amp;, std::__1::shared_ptr&lt;DB::IBlockInputStream&gt; <span class="keyword">const</span>&amp;, std::__1::optional&lt;DB::Pipe&gt;) InterpreterSelectQuery.cpp:<span class="number">791</span></span><br><span class="line">DB::InterpreterSelectQuery::<span class="built_in">buildQueryPlan</span>(DB::QueryPlan&amp;) InterpreterSelectQuery.cpp:<span class="number">472</span></span><br><span class="line">DB::InterpreterSelectWithUnionQuery::<span class="built_in">buildQueryPlan</span>(DB::QueryPlan&amp;) InterpreterSelectWithUnionQuery.cpp:<span class="number">183</span></span><br><span class="line">DB::InterpreterSelectWithUnionQuery::<span class="built_in">execute</span>() InterpreterSelectWithUnionQuery.cpp:<span class="number">198</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, DB::Context &amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer *) executeQuery.cpp:<span class="number">385</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;,</span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">307</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><p>这里最主要的是 ReadFromStorageStep 函数，从不同 storage 里获取数据源 pipe:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipes pipes = storage-&gt;<span class="built_in">read</span>(required_columns, metadata_snapshot, query_info, *context, processing_stage, max_block_size, max_streams);</span><br></pre></td></tr></table></figure><h3 id="2-Pipeline构造"><a href="#2-Pipeline构造" class="headerlink" title="2. Pipeline构造"></a>2. Pipeline构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DB::LimitTransform::<span class="built_in">LimitTransform</span>(DB::Block <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>, std::__1::vector&lt;DB::SortColumnDescription, std::__1::allocator&lt;DB::SortColumnDescription&gt; &gt;) LimitTransform.cpp:<span class="number">21</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) memory:<span class="number">2214</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) memory:<span class="number">2299</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) memory:<span class="number">3570</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) memory:<span class="number">4400</span></span><br><span class="line">DB::LimitStep::<span class="built_in">transformPipeline</span>(DB::QueryPipeline&amp;) LimitStep.cpp:<span class="number">33</span></span><br><span class="line">DB::ITransformingStep::<span class="built_in">updatePipeline</span>(std::__1::vector&lt;std::__1::unique_ptr&lt;DB::QueryPipeline, std::__1::default_delete&lt;DB::QueryPipeline&gt; &gt;, std::__1::allocator&lt;std::__1::unique_ptr&lt;DB::QueryPipeline, std::__1::default_delete&lt;DB::QueryPipeline&gt; &gt; &gt; &gt;) ITransformingStep.cpp:<span class="number">21</span></span><br><span class="line">DB::QueryPlan::<span class="built_in">buildQueryPipeline</span>() QueryPlan.cpp:<span class="number">154</span></span><br><span class="line">DB::InterpreterSelectWithUnionQuery::<span class="built_in">execute</span>() InterpreterSelectWithUnionQuery.cpp:<span class="number">200</span></span><br><span class="line">DB::<span class="built_in">executeQueryImpl</span>(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, DB::Context &amp;, <span class="keyword">bool</span>, DB::QueryProcessingStage::Enum, <span class="keyword">bool</span>, DB::ReadBuffer *) executeQuery.cpp:<span class="number">385</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">722</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">307</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h3 id="3-Pipeline执行"><a href="#3-Pipeline执行" class="headerlink" title="3. Pipeline执行"></a>3. Pipeline执行</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DB::LimitTransform::<span class="built_in">prepare</span>(std::__1::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::allocator&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::allocator&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; &gt; <span class="keyword">const</span>&amp;) LimitTransform.cpp:<span class="number">67</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">291</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">tryAddProcessorToStackIfUpdated</span>(DB::PipelineExecutor::Edge&amp;, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">264</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">prepareProcessor</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::queue&lt;DB::PipelineExecutor::ExecutionState*, std::__1::deque&lt;DB::PipelineExecutor::ExecutionState*, std::__1::allocator&lt;DB::PipelineExecutor::ExecutionState*&gt; &gt; &gt;&amp;, std::__1::unique_lock&lt;std::__1::mutex&gt;) PipelineExecutor.cpp:<span class="number">373</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">initializeExecution</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">747</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">executeImpl</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">764</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">execute</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">479</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">833</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">307</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h3 id="4-Output执行发送"><a href="#4-Output执行发送" class="headerlink" title="4. Output执行发送"></a>4. Output执行发送</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DB::MySQLOutputFormat::<span class="built_in">consume</span>(DB::Chunk) MySQLOutputFormat.cpp:<span class="number">53</span></span><br><span class="line">DB::IOutputFormat::<span class="built_in">work</span>() IOutputFormat.cpp:<span class="number">62</span></span><br><span class="line">DB::<span class="built_in">executeJob</span>(DB::IProcessor *) PipelineExecutor.cpp:<span class="number">155</span></span><br><span class="line"><span class="built_in"><span class="keyword">operator</span></span>() PipelineExecutor.cpp:<span class="number">172</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">executeStepImpl</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, std::__1::atomic&lt;<span class="keyword">bool</span>&gt;*) PipelineExecutor.cpp:<span class="number">630</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">executeSingleThread</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">546</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">executeImpl</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">812</span></span><br><span class="line">DB::PipelineExecutor::<span class="built_in">execute</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) PipelineExecutor.cpp:<span class="number">479</span></span><br><span class="line">DB::<span class="built_in">executeQuery</span>(DB::ReadBuffer&amp;, DB::WriteBuffer&amp;, <span class="keyword">bool</span>, DB::Context&amp;, std::__1::function&lt;<span class="built_in"><span class="keyword">void</span></span> (std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;, std::__1::basic_string&lt;<span class="keyword">char</span>, std::__1::char_traits&lt;<span class="keyword">char</span>&gt;, std::__1::allocator&lt;<span class="keyword">char</span>&gt; &gt; <span class="keyword">const</span>&amp;)&gt;) executeQuery.cpp:<span class="number">800</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">comQuery</span>(DB::ReadBuffer&amp;) MySQLHandler.cpp:<span class="number">311</span></span><br><span class="line">DB::MySQLHandler::<span class="built_in">run</span>() MySQLHandler.cpp:<span class="number">141</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>ClickHouse 的模块化比较清晰，像乐高积木一样可以组合拼装，当我们执行:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> system.numbers LIMIT <span class="number">5</span></span><br></pre></td></tr></table></figure><p>首先内核解析 SQL 语句生成 AST，然后根据 AST 获取数据源 Source，pipeline.Add(Source)。<br>其次根据 AST 信息生成 QueryPlan，根据 QueryPlan 再生成相应的 Transform，pipeline.Add(LimitTransform)。<br>然后添加 Output Sink 作为数据发送对象，pipeline.Add(OutputSink)。<br>执行 pipeline, 各个 Transformer 开始工作。</p><p>ClickHouse 的 Transformer 调度系统叫做 Processor，也是决定性能的重要模块，详情见 <a href="https://bohutang.me/2020/06/11/clickhouse-and-friends-processor/">Pipeline 处理器和调度器</a>。<br>ClickHouse 是一辆手动挡的豪华跑车，免费拥有，海啸们！</p><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://bohutang.me/&quot;&gt;BohuTANG&lt;/a&gt; 的博客，原文链接：&lt;br&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 | ClickHouse和他的朋友们（1）编译、开发、测试</title>
    <link href="http://dbkernel.github.io/2020/06/05/clickhouse-and-friends-01-development/"/>
    <id>http://dbkernel.github.io/2020/06/05/clickhouse-and-friends-01-development/</id>
    <published>2020-06-05T11:37:10.000Z</published>
    <updated>2021-08-22T05:58:57.049Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>《ClickHouse和他的朋友们》系列文章转载自圈内好友 <a href="https://bohutang.me/">BohuTANG</a> 的博客，原文链接：<br><a href="https://bohutang.me/2020/06/05/clickhouse-and-friends-development/">https://bohutang.me/2020/06/05/clickhouse-and-friends-development/</a><br>以下为正文。</p></blockquote><p>一次偶然的机会，和ClickHouse团队做了一次线下沟通，Alexey提到ClickHouse的设计哲学:</p><ol><li>The product must solve actual problem</li><li>And do it better than others</li></ol><p>用工程思维解决商业问题的典范啊！</p><p>对用户来说，他们关心的不是什么天花乱坠、上天入地的高科技，只是需要一个能很好解决自己问题的方案，这在开源社区是非常难得的，靠实力“野蛮式”生长。</p><p>于是，我对这个散发着伏特加味道的利器充满了好奇，并参与到ClickHouse的社区中一探究竟，第一感觉是开放、友好、战斗力强(AK47 vs CK16, ClickHouse 2016年开源)。</p><p>本文先从编译和测试入手，再到如何为社区贡献Patch，希望对那些想参与CK社区的同学有所帮助。</p><h2 id="如何本地编译和测试ClickHouse？"><a href="#如何本地编译和测试ClickHouse？" class="headerlink" title="如何本地编译和测试ClickHouse？"></a><strong>如何本地编译和测试ClickHouse？</strong></h2><h3 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a><strong>源码获取</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/ClickHouse/ClickHouse</span><br></pre></td></tr></table></figure><h3 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a><strong>编译准备</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo apt-add-repository ppa:ubuntu-toolchain-r/<span class="built_in">test</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install gcc-9 g++-9 git python ninja-build</span><br><span class="line">sudo snap install cmake</span><br></pre></td></tr></table></figure><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a><strong>开始编译</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ClickHouse</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="built_in">export</span> CC=gcc-9</span><br><span class="line"><span class="built_in">export</span> CXX=g++-9</span><br><span class="line">cmake ..</span><br><span class="line">ninja</span><br></pre></td></tr></table></figure><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a><strong>测试方法</strong></h3><p>ClickHouse的测试在官方<a href="https://github.com/ClickHouse/ClickHouse/blob/master/docs/en/development/tests.md">development/tests</a>文档里有详细的介绍，这里列举3个常用的测试模式：</p><h4 id="1-Functional-Tests"><a href="#1-Functional-Tests" class="headerlink" title="1. Functional Tests"></a>1. Functional Tests</h4><p>功能测试，主要用于ClickHouse内部功能测试，方式：输入一个sql文件，输出一个result，类似MySQL里的mtr，<a href="https://github.com/ClickHouse/ClickHouse/tree/master/tests/queries">测试集合</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tests</span><br><span class="line">./clickhouse-test -c <span class="string">&quot;../build/programs/clickhouse-client&quot;</span> 00001_select_1</span><br></pre></td></tr></table></figure><h4 id="2-Integration-Tests"><a href="#2-Integration-Tests" class="headerlink" title="2. Integration Tests"></a>2. Integration Tests</h4><p>集成测试，主要用于涉及第三方服务的测试，比如MySQL/Postgres/MongoDB等，以容器化方式编排调度(pytest)运行，<a href="https://github.com/ClickHouse/ClickHouse/tree/master/tests/integration">测试集合</a></p><p>由于涉及模块较多，集成测试环境的搭建有一定的难度，建议使用官方的docker镜像。比如要跑test_mysql_protocol下的集成测试集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tests/integration</span><br><span class="line">docker pull yandex/clickhouse-integration-tests-runner</span><br><span class="line">./runner --binary /your/ClickHouse/build/programs/clickhouse  --bridge-binary /your/ClickHouse/build/programs/clickhouse-odbc-bridge --configs-dir /your/ClickHouse/programs/server/ <span class="string">&#x27;test_mysql_protocol/test.py::test_java_client -ss -vv&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-Unit-Tests"><a href="#3-Unit-Tests" class="headerlink" title="3. Unit Tests"></a>3. Unit Tests</h4><p>单元测试，主要用于代码模块的测试，测试集在各个模块的tests目录，比如: <a href="https://github.com/ClickHouse/ClickHouse/tree/master/src/Core/tests">Core/tests</a></p><p>如果大家想了解某个模块是如何工作的，强烈建议去翻翻该模块的tests目录，比如想了解processor的工作机制，跟踪调试 <a href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Processors/tests/processors_test.cpp">Processors/tests/</a> 即可。</p><h2 id="如何给ClickHouse社区提Patch？"><a href="#如何给ClickHouse社区提Patch？" class="headerlink" title="如何给ClickHouse社区提Patch？"></a><strong>如何给ClickHouse社区提Patch？</strong></h2><h4 id="1-fork"><a href="#1-fork" class="headerlink" title="1. fork"></a>1. fork</h4><p>首先在自己的github上fork一份ClickHouse代码，比如 <a href="https://github.com/BohuTANG/ClickHouse">https://github.com/BohuTANG/ClickHouse</a></p><h4 id="2-clone到本地"><a href="#2-clone到本地" class="headerlink" title="2. clone到本地"></a>2. clone到本地</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/BohuTANG/ClickHouse</span><br><span class="line">git checkout -B mysql_replica(branch名字)</span><br></pre></td></tr></table></figure><h4 id="3-创建新的分支"><a href="#3-创建新的分支" class="headerlink" title="3. 创建新的分支"></a>3. 创建新的分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -B mysql_replica(branch名字)</span><br></pre></td></tr></table></figure><h4 id="4-功能开发"><a href="#4-功能开发" class="headerlink" title="4. 功能开发"></a>4. 功能开发</h4><p>开发者可以提交一个Draft Pull Request到官方，github会显示这个Pull Request处于Draft状态，官方是无法Merge的</p><h4 id="5-can-be-testd标签"><a href="#5-can-be-testd标签" class="headerlink" title="5. can be testd标签"></a>5. can be testd标签</h4><p>等待Upstream打[can be tested]标签，一旦被标记CI狂魔们就强势开跑，跑一轮大概需要几十个小时。<br>协助开发者发现一些代码Style、编译以及测试等错误，这样开发者就可以在自己的分支不停的迭代、修正。<br><img src="github-ck-ci.jpeg" alt="img"></p><p>如果只是修改typo，这个标签Upstream通常不会添加。</p><h4 id="6-开发完毕"><a href="#6-开发完毕" class="headerlink" title="6. 开发完毕"></a>6. 开发完毕</h4><p>开发完成，测试OK，把Draft提升为正式Pull Request，等待Upstraem Review。</p><h4 id="7-Merge到Master"><a href="#7-Merge到Master" class="headerlink" title="7. Merge到Master"></a>7. Merge到Master</h4><p>如果Upstream通过，你的代码会被Merge到Master，恭喜你成为ClickHouse贡献者</p><h4 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8. 注意事项"></a>8. 注意事项</h4><p>ClickHouse Upstream迭代非常快，一定要多关注master分支进度，尽量保持自己的分支代码与master同步。否则Upstream Docker更新，自己的test可能就过不了。</p><p>建议把<a href="https://github.com/ClickHouse/ClickHouse/tree/master/docs/en/development">doc/development</a>读一遍。</p><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;《ClickHouse和他的朋友们》系列文章转载自圈内好友 &lt;a href=&quot;https://bohutang.me/&quot;&gt;BohuTANG&lt;/a&gt; 的博客，原文链接：&lt;br&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/categories/ClickHouse/"/>
    
    
    <category term="ClickHouse和他的朋友们" scheme="http://dbkernel.github.io/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
    
    <category term="ClickHouse" scheme="http://dbkernel.github.io/tags/ClickHouse/"/>
    
    <category term="源码分析" scheme="http://dbkernel.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>引擎特性 | MySQL select count(*) 、count(1)、count(列) 详解（1）：概念及区别</title>
    <link href="http://dbkernel.github.io/2020/05/06/mysql-select-count-functions-01-concepts-and-differences/"/>
    <id>http://dbkernel.github.io/2020/05/06/mysql-select-count-functions-01-concepts-and-differences/</id>
    <published>2020-05-06T07:55:15.000Z</published>
    <updated>2021-08-22T05:59:50.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>从接触MySQL开始断断续续的看过一些文章，对<code>count()</code>操作众说纷纭，其中分歧点主要在于<code>count(1)</code>和<code>count(*)</code>哪个效率高，有说<code>count(1)</code>比<code>count(*)</code>快的（<code>这种说法更普遍</code>），有说二者一样快的。个人理解这两种行为可能适用于的是不同的版本，我只关心较新的MySQL版本是什么行为，详见下文。</p><h3 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a>二、含义</h3><p>首先，先说明一下常见<code>count()</code>操作及含义：</p><blockquote><p><code>count(*)</code>：计算包括NULL值在内的行数，SQL92定义的标准统计行数的语法。</p><p><code>count(1)</code>：计算包括NULL值在内的行数，其中的1是恒真表达式。</p><p><code>count(列名)</code>：计算指定列的行数，但不包含NULL值。</p></blockquote><h3 id="三、具体区别"><a href="#三、具体区别" class="headerlink" title="三、具体区别"></a>三、具体区别</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-functions.html#function_count">MySQL手册</a>中相关描述如下：</p><blockquote><p>For transactional storage engines such as InnoDB, storing an exact row count is problematic. Multiple transactions may be occurring at the same time, each of which may affect the count.</p><p>InnoDB does not keep an internal count of rows in a table because concurrent transactions might “see” different numbers of rows at the same time. Consequently, <code>SELECT COUNT(*)</code> statements only count rows visible to the current transaction.</p><p>Prior to <code>MySQL 5.7.18</code>, InnoDB processes <code>SELECT COUNT(*)</code> statements by scanning the clustered index. As of <code>MySQL 5.7.18</code>, InnoDB processes <code>SELECT COUNT(*)</code> statements by traversing the smallest available secondary index unless an index or optimizer hint directs the optimizer to use a different index. If a secondary index is not present, the clustered index is scanned.</p><p>Processing <code>SELECT COUNT(*)</code> statements takes some time if index records are not entirely in the buffer pool. For a faster count, create a counter table and let your application update it according to the inserts and deletes it does. However, this method may not scale well in situations where thousands of concurrent transactions are initiating updates to the same counter table. If an approximate row count is sufficient, use <code>SHOW TABLE STATUS</code>.</p><p>InnoDB handles <code>SELECT COUNT(*)</code> and <code>SELECT COUNT(1)</code> operations in the same way. There is no performance difference.</p><p>For <code>MyISAM</code> tables, <code>COUNT(*)</code> is optimized to return very quickly if the SELECT retrieves from one table, no other columns are retrieved, and there is no WHERE clause. For example:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span>mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><p>This optimization only applies to MyISAM tables, because an exact row count is stored for this storage engine and can be accessed very quickly.COUNT(1) is only subject to the same optimization if the first column is defined as NOT NULL.</p></blockquote><p><strong>官方这段描述要点如下：</strong></p><blockquote><ol><li>InnoDB是事务引擎，支持MVCC，并发事务可能同时“看到”不同的行数，所以，<strong>InnoDB不保留表中的行数</strong>，<code>SELECT COUNT(*)</code>语句只计算当前事务可见的行数。</li><li>在MySQL 5.7.18之前，InnoDB通过<strong>扫描聚集索引</strong>处理<code>SELECT COUNT(*)</code>语句。从MySQL 5.7.18开始，<code>InnoDB</code>通过<strong>遍历最小的可用二级索引</strong>来处理<code>SELECT COUNT(*)</code>语句，除非索引或优化器明确指示使用不同的索引。<strong>如果不存在二级索引，则扫描聚集索引</strong>。这样的设计单从 IO 的角度就节省了很多开销。</li><li><strong>InnoDB以同样的方式处理<code>SELECT COUNT(*)</code>和<code>SELECT COUNT(1)</code>操作，没有性能差异。</strong> 因此，建议使用符合SQL标准的<code>count(*)</code>。</li><li>对于<code>MyISAM</code>表，由于MyISAM引擎存储了精确的行数，因此，如果<code>SELECT COUNT(*)</code>语句不包含WHERE子句，则会很快返回。这个很好理解，如果带了where条件，就需要扫表了。</li><li>如果索引记录不完全在缓冲池中，则处理<code>SELECT(*)</code>语句需要一些时间。为了更快的计数，您可以创建一个计数器表，并让您的应用程序按插入和删除操作更新它。然而，这种方法在同一计数器表中启动成千上万个并发事务的情况下，可能无法很好地扩展。如果一个近似的行数足够，可以使用<code>SHOW TABLE STATUS</code>查询行数。</li></ol></blockquote><p>到这里我们明白了 <code>count(*)</code> 和 <code>count(1)</code> 本质上面其实是一样的，那么 <code>count(column)</code> 又是怎么回事呢？</p><blockquote><p><code>count(column)</code> 也是会遍历整张表，但是不同的是它会<strong>拿到 column 的值以后判断是否为空，然后再进行累加</strong>，那么如果<strong>针对主键需要解析内容</strong>，如果是<strong>二级索引需要再次根据主键获取内容，则要多一次 IO 操作</strong>，所以 <code>count(column)</code> 的性能肯定不如前两者，如果按照效率比较的话：*<em>count(</em>)=count(1)&gt;count(primary key)&gt;count(非主键column)**。</p></blockquote><h3 id="四、建议"><a href="#四、建议" class="headerlink" title="四、建议"></a>四、建议</h3><p>基于以上描述，如果要查询innodb存储引擎的表的总行数，有如下建议：</p><ol><li>若仅仅是想获取大概的行数，建议使用<code>show table status</code>或查询<code>information_schema.tables</code>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use db6;</span><br><span class="line">Reading <span class="keyword">table</span> information <span class="keyword">for</span> completion <span class="keyword">of</span> <span class="keyword">table</span> <span class="keyword">and</span> <span class="keyword">column</span> names</span><br><span class="line">You can turn off this feature <span class="keyword">to</span> <span class="keyword">get</span> a quicker startup <span class="keyword">with</span> <span class="operator">-</span>A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_db6 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span> t1            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">table</span> status\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: <span class="number">10</span></span><br><span class="line">     Row_format: <span class="keyword">Dynamic</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">2</span></span><br><span class="line"> Avg_row_length: <span class="number">8192</span></span><br><span class="line">    Data_length: <span class="number">16384</span></span><br><span class="line">Max_data_length: <span class="number">0</span></span><br><span class="line">   Index_length: <span class="number">0</span></span><br><span class="line">      Data_free: <span class="number">0</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="number">2020</span><span class="number">-04</span><span class="number">-21</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">44</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: utf8mb4_general_ci</span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_name <span class="operator">=</span> <span class="string">&#x27;t1&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  TABLE_CATALOG: def</span><br><span class="line">   TABLE_SCHEMA: db6</span><br><span class="line">     TABLE_NAME: t1</span><br><span class="line">     TABLE_TYPE: BASE <span class="keyword">TABLE</span></span><br><span class="line">         ENGINE: InnoDB</span><br><span class="line">        VERSION: <span class="number">10</span></span><br><span class="line">     ROW_FORMAT: <span class="keyword">Dynamic</span></span><br><span class="line">     TABLE_ROWS: <span class="number">2</span></span><br><span class="line"> AVG_ROW_LENGTH: <span class="number">8192</span></span><br><span class="line">    DATA_LENGTH: <span class="number">16384</span></span><br><span class="line">MAX_DATA_LENGTH: <span class="number">0</span></span><br><span class="line">   INDEX_LENGTH: <span class="number">0</span></span><br><span class="line">      DATA_FREE: <span class="number">0</span></span><br><span class="line"> AUTO_INCREMENT: <span class="keyword">NULL</span></span><br><span class="line">    CREATE_TIME: <span class="number">2020</span><span class="number">-04</span><span class="number">-21</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">44</span></span><br><span class="line">    UPDATE_TIME: <span class="keyword">NULL</span></span><br><span class="line">     CHECK_TIME: <span class="keyword">NULL</span></span><br><span class="line">TABLE_COLLATION: utf8mb4_general_ci</span><br><span class="line">       CHECKSUM: <span class="keyword">NULL</span></span><br><span class="line"> CREATE_OPTIONS:</span><br><span class="line">  TABLE_COMMENT:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li>反之，如果必须要获取准确的总行数，建议：<blockquote><ol><li>创建一个计数器表，并让您的应用程序按插入和删除操作更新它。</li><li>若业务插入和删除相对较少，也可以考虑缓存到 redis。</li></ol></blockquote></li></ol><p>篇幅有限，深入验证、源码分析将在下一篇文章中介绍。</p><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;从接触MySQL开始断断续续的看过一些文章，对&lt;code&gt;count()&lt;/code&gt;操作众说纷纭，其中分歧点主要在于&lt;co</summary>
      
    
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/tags/MySQL/"/>
    
    <category term="Select" scheme="http://dbkernel.github.io/tags/Select/"/>
    
    <category term="Count" scheme="http://dbkernel.github.io/tags/Count/"/>
    
  </entry>
  
  <entry>
    <title>引擎特性 | MySQL-自增列详解（1）：自增列概念及使用</title>
    <link href="http://dbkernel.github.io/2019/12/09/mysql-auto_increment-details-01-concepts-and-usage/"/>
    <id>http://dbkernel.github.io/2019/12/09/mysql-auto_increment-details-01-concepts-and-usage/</id>
    <published>2019-12-09T11:37:10.000Z</published>
    <updated>2021-08-22T05:59:32.101Z</updated>
    
    <content type="html"><![CDATA[<p>一直想写一些关于自增列的文章，今天下班比较早，Let’s do this.</p><span id="more"></span><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>自增列，即 AUTO_INCREMENT，可用于为新的记录生成唯一标识。</p><p><strong>要求：</strong></p><ol><li>AUTO_INCREMENT 是数据列的一种属性，只适用于整数类型数据列。</li><li>AUTO_INCREMENT 数据列必须具备 NOT NULL 属性。</li></ol><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h3><h4 id="2-1-创建含自增列的表"><a href="#2-1-创建含自增列的表" class="headerlink" title="2.1. 创建含自增列的表"></a>2.1. 创建含自增列的表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不指定 AUTO_INCREMENT 的值，则从1开始</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t1(a <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,b <span class="type">int</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 手动指定 AUTO_INCREMENT 的值</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t2(a <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,b <span class="type">int</span>) AUTO_INCREMENT<span class="operator">=</span><span class="number">100</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><h4 id="2-2-插入数据"><a href="#2-2-插入数据" class="headerlink" title="2.2. 插入数据"></a>2.2. 插入数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不指定自增列</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(b) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="operator">|</span> a <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定自增列</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="2-3-如何查看表的-AUTO-INCREMENT-涨到了多少？"><a href="#2-3-如何查看表的-AUTO-INCREMENT-涨到了多少？" class="headerlink" title="2.3. 如何查看表的 AUTO_INCREMENT 涨到了多少？"></a>2.3. 如何查看表的 AUTO_INCREMENT 涨到了多少？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="2-4-插入数据时能否有空洞？"><a href="#2-4-插入数据时能否有空洞？" class="headerlink" title="2.4. 插入数据时能否有空洞？"></a>2.4. 插入数据时能否有空洞？</h4><p>可以的，但要注意 <code>AUTO_INCREMENT 的值一定比自增列当前最大的记录值大</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创造空洞</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="operator">|</span> a <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">6</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="2-5-能否插入重复记录"><a href="#2-5-能否插入重复记录" class="headerlink" title="2.5. 能否插入重复记录"></a>2.5. 能否插入重复记录</h4><p>既然自增列是唯一记录，那么肯定不能插入重复记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 尝试插入重复记录</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;5&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-6-怎么修改-AUTO-INCREMENT-的值？"><a href="#2-6-怎么修改-AUTO-INCREMENT-的值？" class="headerlink" title="2.6. 怎么修改 AUTO_INCREMENT 的值？"></a>2.6. 怎么修改 AUTO_INCREMENT 的值？</h4><p><strong>注意</strong>：AUTO_INCREMENT 不能小于当前自增列记录的最大值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 尝试将 AUTO_INCREMENT 设为10</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 AUTO_INCREMENT<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">10</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试将 AUTO_INCREMENT 设为4</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于自增列最大记录值是5，那么 AUTO_INCREMENT 不能小于5，因此该值为6</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">6</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h3><h4 id="3-1-自增列是否有上限？"><a href="#3-1-自增列是否有上限？" class="headerlink" title="3.1. 自增列是否有上限？"></a>3.1. 自增列是否有上限？</h4><p><strong>由上文可见，自增列会一直增加，那是否有上限呢？</strong></p><p>上文中表 t1 的自增列是 int 类型，由下表（MySQL 5.7）可见取值范围是 -2147483648 到 2147483647（ -2<sup>31</sup> ~ 2<sup>31</sup> - 1 ）。</p><table><thead><tr><th>Type</th><th>Storage (Bytes)</th><th>Minimum Value Signed</th><th>Minimum Value Unsigned</th><th>Maximum Value Signed</th><th>Maximum Value Unsigned</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1</td><td>-128</td><td>0</td><td>127</td><td>255</td></tr><tr><td><code>SMALLINT</code></td><td>2</td><td>-32768</td><td>0</td><td>32767</td><td>65535</td></tr><tr><td><code>MEDIUMINT</code></td><td>3</td><td>-8388608</td><td>0</td><td>8388607</td><td>16777215</td></tr><tr><td><code>INT</code></td><td>4</td><td>-2147483648</td><td>0</td><td>2147483647</td><td>4294967295</td></tr><tr><td><code>BIGINT</code></td><td>8</td><td>-2<sup>63</sup></td><td>0</td><td>2<sup>63</sup>-1</td><td>2<sup>64</sup>-1</td></tr></tbody></table><p>验证如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2147483644</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(b) <span class="keyword">values</span>(<span class="number">0</span>),(<span class="number">0</span>),(<span class="number">0</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1(b) <span class="keyword">values</span>(<span class="number">0</span>);</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;2147483647&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2147483647</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>这里需要补充说明下 <code>int(11)</code> 中的数字的含义：</p><blockquote><p>MySQL中整数数据类型后面的(N)指定<strong>显示宽度</strong>。<br>显示宽度不影响查询出来的结果。<br>显示宽度限制了小数点的位置(只要实际数字不超过显示宽度，这种情况下，数字显示为原样)。<br>显示宽度也是一个有用的工具，可以让开发人员知道应该将值填充到哪个长度。</p></blockquote><h4 id="3-2-如何避免自增列超过最大值？"><a href="#3-2-如何避免自增列超过最大值？" class="headerlink" title="3.2. 如何避免自增列超过最大值？"></a>3.2. 如何避免自增列超过最大值？</h4><p>可以采用<code>无符号的 BIGINT 类型</code>（也可根据业务产生自增列的速度采用合适的类型），能极大提升自增列的范围。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t2(a <span class="type">bigint</span> unsigned <span class="keyword">primary</span> key auto_increment,b <span class="type">int</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t2 auto_increment<span class="operator">=</span><span class="number">18446744073709551613</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t2;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t2    <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `a` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">18446744073709551613</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t2(b) <span class="keyword">values</span>(<span class="number">0</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t2(b) <span class="keyword">values</span>(<span class="number">0</span>);</span><br><span class="line">ERROR <span class="number">1467</span> (HY000): Failed <span class="keyword">to</span> read auto<span class="operator">-</span>increment <span class="keyword">value</span> <span class="keyword">from</span> storage engine</span><br><span class="line">mysql<span class="operator">&gt;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+------+</span></span><br><span class="line"><span class="operator">|</span> a                    <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">18446744073709551613</span> <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong><code>UNSIGNED BIGINT</code> 类型的范围究竟有多大呢？</strong></p><blockquote><p>假如每秒自增100万次，想要消耗完需要 <code>18446744073709551613/1000000/3600/24/365</code>=584942年。</p></blockquote><p><strong>有的朋友会问如果自增列不是采用BIGINT类型，那么达到最大值后该表就无法写入，此时该怎么办呢？</strong></p><blockquote><p>一般达到最大值后再次插入数据会报错<code>ERROR 1467 (HY000): Failed to read auto-increment value from storage engine</code>，可以通过alter table 将自增列的类型设为数值范围更大的类型（比如BIGINT）。</p></blockquote><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol><li>AUTO_INCREMENT 列必定唯一，且仅用于整型类型。</li><li>AUTO_INCREMENT 列会持续增长，不会因 delete 自增列最大的记录而变小。</li><li>当 AUTO_INCREMENT 列达到当前类型的最大值后将无法插入数据，会报错<code>ERROR 1467 (HY000): Failed to read auto-increment value from storage engine</code>，此时将自增列改为 BIGINT 类型可解决问题。</li><li>为了避免自增列达到最大值，可将其设为BIGINT类型。</li><li>使用 alter table 修改 AUTO_INCREMENT 列时，其值会取<code>自增列当前最大记录值+1</code>与<code>将要设置的值</code>的最大值。</li><li>在MySQL 5.7 中，将列设置成 AUTO_INCREMENT 之后，必须将其设置成主键/或者是主键的一部分，否则会报错<code>ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key</code>。</li></ol><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直想写一些关于自增列的文章，今天下班比较早，Let’s do this.&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://dbkernel.github.io/tags/MySQL/"/>
    
    <category term="auto_increment" scheme="http://dbkernel.github.io/tags/auto-increment/"/>
    
  </entry>
  
  <entry>
    <title>实用工具 | Linux定时任务crontab命令详解</title>
    <link href="http://dbkernel.github.io/2016/11/23/description-of-the-crontab-command/"/>
    <id>http://dbkernel.github.io/2016/11/23/description-of-the-crontab-command/</id>
    <published>2016-11-23T02:24:45.000Z</published>
    <updated>2021-09-04T15:04:50.473Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux 下的任务调度分为两类：<strong>系统任务调度</strong>和<strong>用户任务调度</strong>。Linux 系统任务是由 <code>cron (crond)</code> 这个系统服务来控制的，这个系统服务是默认启动的。用户自己设置的计划任务则使用 <code>crontab</code> 命令。</p><h2 id="cron-配置文件"><a href="#cron-配置文件" class="headerlink" title="cron 配置文件"></a>cron 配置文件</h2><p>在 Ubuntu/Debian 中，配置文件路径为 <code>/etc/crontab</code>（CentOS也类似），其内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="comment"># Unlike any other crontab you don&#x27;t have to run the `crontab&#x27;</span></span><br><span class="line"><span class="comment"># command to install the new version when you edit this file</span></span><br><span class="line"><span class="comment"># and files in /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="comment"># that none of the other crontabs do.</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br><span class="line">17 ** * *root    <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6* * *root<span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.daily )</span><br><span class="line">47 6* * 7root<span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.weekly )</span><br><span class="line">52 61 * *root<span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.monthly )</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li><code>SHELL</code> 环境变量用于指定系统要使用的shell，此处为<code>/bin/sh</code>。</li><li><code>PATH</code> 环境变量指定了系统执行命令的路径。</li><li>也可以添加<code>MAILTO</code>变量，如果指定，则表示 crond 的任务执行信息将通过电子邮件发送给指定的用户。</li><li>其他部分在后文详细讲述。</li></ul><p>用户定期要执行的工作，比如用户数据备份、定时邮件提醒等，都可以使用 crontab 工具来定制自己的计划任务。所有<code>非root用户</code>定义的 crontab 文件都被保存在 <code>/var/spool/cron</code> 目录中，其文件名与用户名一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /var/spool/cron/crontabs/admin</span><br></pre></td></tr></table></figure><p>除此之外，还有两个文件<code>/etc/cron.deny</code>和<code>/etc/cron.allow</code>，前者中可列出不允许哪些用户使用 crontab 命令，后者中可列出允许哪些用户使用 crontab 命令。</p><h2 id="crontab-文件含义"><a href="#crontab-文件含义" class="headerlink" title="crontab 文件含义"></a>crontab 文件含义</h2><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute hour day month week <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>各字段含义如下：</p><ul><li>minute：表示分钟，可以是从0到59之间的任何整数。</li><li>hour：表示小时，可以是从0到23之间的任何整数。</li><li>day：表示日期，可以是从1到31之间的任何整数。</li><li>month：表示月份，可以是从1到12之间的任何整数。</li><li>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</li><li>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</li></ul><p>在以上各个字段中，还可以使用以下特殊字符：</p><ul><li><code>星号(*)</code>：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</li><li><code>逗号(,)</code>：可以用逗号隔开的值指定一个列表范围，例如：<code>1,2,5,7,8,9</code> 。</li><li><code>中杠(-)</code>：可以用整数之间的中杠表示一个整数范围，例如：<code>2-6</code> 表示<code>2,3,4,5,6</code> 。</li><li><code>正斜线(/)</code>：可以用正斜线指定时间的间隔频率，例如：<code>0-23/2</code>表示每两小时执行一次。同时正斜线可以和星号一起使用，例如：<code>*/10</code>，如果用在minute字段，表示<strong>每十分钟执行一次</strong>。</li></ul><h2 id="crontab命令详解"><a href="#crontab命令详解" class="headerlink" title="crontab命令详解"></a>crontab命令详解</h2><p><strong>命令格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">usage:crontab [-u user] file</span><br><span class="line">crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125;</span><br><span class="line">(default operation is replace, per 1003.2)</span><br><span class="line">-e(edit user<span class="string">&#x27;s crontab)</span></span><br><span class="line"><span class="string">-l(list user&#x27;</span>s crontab)</span><br><span class="line">-r(delete user<span class="string">&#x27;s crontab)</span></span><br><span class="line"><span class="string">-i(prompt before deleting user&#x27;</span>s crontab)</span><br></pre></td></tr></table></figure><ul><li>-u user：用于设定某个用户的crontab服务。</li><li>file: file 为命令文件名，表示将 file 作为 crontab 的任务列表文件并载入 crontab ；如果在命令行中没有指定这个文件，crontab 命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab 。</li><li>-e：编辑某个用户的 crontab 文件内容，如不指定用户则表示当前用户。</li><li>-l：显示某个用户的 crontab 文件内容，如不指定用户则表示当前用户。</li><li>-r：从 /var/spool/cron 目录中删除某个用户的crontab文件，如不指定用户，则默认删除当前用户 crontab 文件。</li><li>-i：在删除用户的 crontab 文件时给确认提示。</li></ul><h2 id="crontab-注意事项"><a href="#crontab-注意事项" class="headerlink" title="crontab 注意事项"></a>crontab 注意事项</h2><ol><li>crontab有2种编辑方式：<strong>直接编辑/etc/crontab文件</strong>与<strong>crontab –e</strong>，其中<code>/etc/crontab</code>里的计划任务是<strong>系统的计划任务</strong>，而<strong>用户的计划任务</strong>需要通过<code>crontab –e</code>来编辑。</li><li>每次编辑完某个用户的 cron 设置后，cron 自动在 /var/spool/cron 下生成一个与此用户同名的文件，此用户的 cron 信息都记录在这个文件中，<code>这个文件是不可以直接编辑的，只可以用 crontab -e 来编辑</code>。</li><li>crontab 中的 command 尽量使用绝对路径，否则会经常因为路径错误导致任务无法执行。</li><li>新创建的 cron job 不会马上执行，至少要等2分钟才能执行，可重启 cron 来立即执行。</li><li><code>%</code> 在crontab文件中表示<code>换行</code>，因此假如脚本或命令含有<code>%</code>，需要使用<code>\%</code>来进行转义。</li><li><code>crontab -e</code>的默认编辑器是 nano ，如需使用 vim，可在<code>/etc/profile</code>或<code>~/.bashrc</code>中添加 <code>export EDITOR=vi</code> 来解决。</li></ol><h2 id="crontab-配置示例"><a href="#crontab-配置示例" class="headerlink" title="crontab 配置示例"></a>crontab 配置示例</h2><ul><li><p>每分钟执行1次 command（因cron默认每1分钟扫描一次，因此全为<code>*</code>即可）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每小时的第3和第15分钟执行 command ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 * * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每天上午8-11点的第3和15分钟执行 command ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每隔2天的上午8-11点的第3和15分钟执行 command ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 */2 * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每个星期一的上午8点到11点的第3和第15分钟执行 command ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每晚的21:30分重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每月1、10、22日的 4:45 重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每周六、周日的 1:10 重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每天 18:00 至 23:00 之间每隔30分钟重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每隔1小时重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>晚上23点到早上7点之间，每隔1小时重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 23-7/1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每月的4号与每周一到周三的11点重启 smb ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 11 4 * mon-wed /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></li><li><p>每小时执行<code>/etc/cron.hourly</code>目录内的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 * * * root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure></li></ul><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Linux 下的任务调度分为两类：&lt;strong&gt;系统任务调度&lt;/strong&gt;和&lt;st</summary>
      
    
    
    
    <category term="实用工具" scheme="http://dbkernel.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux" scheme="http://dbkernel.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/"/>
    
    
    <category term="Linux" scheme="http://dbkernel.github.io/tags/Linux/"/>
    
    <category term="crontab" scheme="http://dbkernel.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>系统运维 | Ubuntu下安装配置samba服务的详细过程</title>
    <link href="http://dbkernel.github.io/2014/08/05/how-to-install-configure-samba-service-in-ubuntu/"/>
    <id>http://dbkernel.github.io/2014/08/05/how-to-install-configure-samba-service-in-ubuntu/</id>
    <published>2014-08-05T02:14:48.000Z</published>
    <updated>2021-09-07T04:02:22.231Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-Samba作用"><a href="#1-Samba作用" class="headerlink" title="1. Samba作用"></a>1. Samba作用</h1><p>Samba的主要任务就是实现Linux系统和Windows系统之间的资源共享。我们现在是要在Linux下配置Samba，让Windows的用户可以访问你的PC。</p><p>当然，也可用于VMWare虚拟机与宿主机之间的资源共享。</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><p>我是在ubuntu上实现的，所以我只需在配置好ubuntu的更新源之后，在终端中使用一下两句命令，就可以安装Samba的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install smaba</span><br><span class="line">sudo apt-get install smbfs</span><br></pre></td></tr></table></figure><h1 id="3-Samba服务的构成"><a href="#3-Samba服务的构成" class="headerlink" title="3. Samba服务的构成"></a>3. Samba服务的构成</h1><p>Samba的核心是两个守护进程<code>smbd</code>和<code>nmbd</code> 。它们的配置信息都保存在<code>/etc/samba/smb.conf</code>里面。</p><p>其中<code>smbd</code>处理Samba软件与Linux协商，<code>nmbd</code>使其他主机能浏览Linux服务器。</p><h1 id="4-Samba配置文件"><a href="#4-Samba配置文件" class="headerlink" title="4. Samba配置文件"></a>4. Samba配置文件</h1><p>配置文件为<code>/etc/samba/smb.conf</code>，如果担心改了之后有问题，可以先备份一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/samba/smb.conf /etc/samba/smb_conf_backup</span><br></pre></td></tr></table></figure><p><strong>一个完整的Samba配置文件包含两部分：</strong></p><ul><li><p>Samba Global Settings 全局参数设置</p><blockquote><p>该部分由<code>[global]段</code>来完成配置，主要是设置整体的规则。其中参数<code>workgroup</code>比较特殊，用于提供<code>NT域名或者工作组名</code>，需要根据实际情况修改：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workgroup=mygroup</span><br></pre></td></tr></table></figure></li><li><p>Share Definitions 共享定义</p><blockquote><p>有很多段，都用<code>[]标志</code>开始的，需要根据实际情况修改。</p></blockquote></li></ul><p><strong>语法说明：</strong></p><ul><li>每个部分有消息头和参数构成，消息头用<code>[]</code>表示，如<code>[global]</code>就是一个消息头。</li><li>参数的结构形式是<code>parameter=value</code>。</li><li>注释用 <code>#</code> 表示，这个和shell脚本有点像。</li><li>有一些配置前面有 <code>;</code> ，这个表示这一行的配置可以更改，如需修改，则要去掉<code>;</code>，配置才可能生效。</li></ul><h1 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h1><h2 id="5-1-设置共享目录"><a href="#5-1-设置共享目录" class="headerlink" title="5.1. 设置共享目录"></a>5.1. 设置共享目录</h2><p>假定共享目录为<code>/home/share/samba</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /home/share/samba</span><br><span class="line">sudo chmod 777 /home/share/samba</span><br></pre></td></tr></table></figure><h2 id="5-2-修改配置文件"><a href="#5-2-修改配置文件" class="headerlink" title="5.2. 修改配置文件"></a>5.2. 修改配置文件</h2><p>修改 global 段：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line">    <span class="attr">workgroup</span> = WORKGROUP</span><br><span class="line">    display <span class="attr">charset</span> = UTF-<span class="number">8</span></span><br><span class="line">    unix <span class="attr">charset</span> = UTF-<span class="number">8</span></span><br><span class="line">    dos <span class="attr">charset</span> = cp936</span><br></pre></td></tr></table></figure><p>添加Share段：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Share]</span></span><br><span class="line">    <span class="attr">comment</span> = Shared Folder with username and password</span><br><span class="line">    <span class="attr">path</span> = /home/share/samba</span><br><span class="line">    <span class="attr">public</span> = <span class="literal">yes</span></span><br><span class="line">    <span class="attr">writable</span> = <span class="literal">no</span></span><br><span class="line">    valid <span class="attr">users</span> = user</span><br><span class="line">    create <span class="attr">mask</span> = <span class="number">0300</span></span><br><span class="line">    directory <span class="attr">mask</span> = <span class="number">0300</span></span><br><span class="line">    force <span class="attr">user</span> = nobody</span><br><span class="line">    force <span class="attr">group</span> = nogroup</span><br><span class="line">    <span class="attr">available</span> = <span class="literal">yes</span></span><br><span class="line">    <span class="attr">browseable</span> = <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>搜索到 security 配置项，修改为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security</span> = user</span><br><span class="line">username <span class="attr">map</span> = /etc/samba/smbusers</span><br></pre></td></tr></table></figure><p>保存并关闭配置文件。</p><h2 id="5-3-添加Samba用户"><a href="#5-3-添加Samba用户" class="headerlink" title="5.3. 添加Samba用户"></a>5.3. 添加Samba用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd user <span class="comment">#增加了一个叫做user的用户</span></span><br><span class="line">sudo smbpasswd user <span class="comment">#修改user的对samba服务的密码，系统会提示输入密码</span></span><br></pre></td></tr></table></figure><h2 id="5-4-重启服务"><a href="#5-4-重启服务" class="headerlink" title="5.4. 重启服务"></a>5.4. 重启服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/samba restart</span><br></pre></td></tr></table></figure><h2 id="5-5-使用"><a href="#5-5-使用" class="headerlink" title="5.5. 使用"></a>5.5. 使用</h2><ul><li><p>在windows系统下使用</p><ul><li>方法一：在IE地址栏中输入：<code>\\你的IP</code>，然后回车，可能要求你输入用户名和密码（第5.3小节设定的）。</li><li>方法二：在<code>网上邻居</code>中新建<code>邻居</code>，在路径中输入: <code>\\你的IP\Share</code>，然后点击下一步完成（可能会要求输入用户名和密码）。</li></ul></li><li><p>在Linux下访问：在终端中挂载文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t smbfs -o username=user,password=123456 //218.*.*.*/Share /mnt</span><br></pre></td></tr></table></figure><blockquote><p>其中，<code>-t参数</code>指示了文件系统的类型，<code>username</code>是用户名，<code>password</code>是密码，<code>218.*.*.*</code>是你的IP，<code>Share</code>是在配置文件中已经指明的段名，<code>/mnt</code>是要挂载到的文件夹。</p></blockquote></li></ul><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h1 id=&quot;1-Samba作用&quot;&gt;&lt;a href=&quot;#1-Samba作用&quot; class=&quot;headerlink&quot; title=&quot;1. Samba作用&quot;&gt;&lt;/a&gt;1. Samba作用&lt;/h1&gt;&lt;p&gt;Samba的主要任务就是实</summary>
      
    
    
    
    <category term="Linux" scheme="http://dbkernel.github.io/categories/Linux/"/>
    
    <category term="系统运维" scheme="http://dbkernel.github.io/categories/Linux/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Linux" scheme="http://dbkernel.github.io/tags/Linux/"/>
    
    <category term="系统运维" scheme="http://dbkernel.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>程序人生 | 我的《C陷阱与缺陷》读书笔记</title>
    <link href="http://dbkernel.github.io/2014/08/04/c-traps-and-pitfalls-reading-notes/"/>
    <id>http://dbkernel.github.io/2014/08/04/c-traps-and-pitfalls-reading-notes/</id>
    <published>2014-08-04T09:56:55.000Z</published>
    <updated>2021-09-06T15:47:46.651Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="第一章-词法“陷阱”"><a href="#第一章-词法“陷阱”" class="headerlink" title="第一章 词法“陷阱”"></a>第一章 词法“陷阱”</h1><h2 id="1-不同于"><a href="#1-不同于" class="headerlink" title="1. =不同于=="></a>1. =不同于==</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x = y)</span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>实际上是将y赋给x，再检查x是否为0。</p><p>如果真的是这样预期，那么应该改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((x = y) != <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="2-amp-和-不同于-amp-amp-和"><a href="#2-amp-和-不同于-amp-amp-和" class="headerlink" title="2. &amp;和| 不同于 &amp;&amp; 和 ||"></a>2. &amp;和| 不同于 &amp;&amp; 和 ||</h2><h2 id="3-词法分析中的“贪心法”"><a href="#3-词法分析中的“贪心法”" class="headerlink" title="3. 词法分析中的“贪心法”"></a>3. 词法分析中的“贪心法”</h2><p>编译器将程序分解成符号的方法是：从左到有一个一个字符的读入，如果该字符可能组成一个符号，那么再读入下一个字符，判断已经读入的两个字符组成的字符床是否可能是一个符号的组成部分；如果可能，继续读入下一个字符，重复上述判断，直到读入的字符组成的字符串已不再可能组成一个有意义的符号。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = x<span class="comment">/*p; 会被解析为：/* 注释符号</span></span><br></pre></td></tr></table></figure><h2 id="4-整型常量"><a href="#4-整型常量" class="headerlink" title="4. 整型常量"></a>4. 整型常量</h2><p>010(八进制数) 不同于 10（十进制）。</p><h2 id="5-字符与字符串"><a href="#5-字符与字符串" class="headerlink" title="5. 字符与字符串"></a>5. 字符与字符串</h2><p>首先是单引号与双引号的区别：</p><ul><li>用单引号括起来的一个字符表示一个整数（ASCII码），而双引号括起来表示一个指针。</li></ul><h1 id="第二章-语法“陷阱”"><a href="#第二章-语法“陷阱”" class="headerlink" title="第二章 语法“陷阱”"></a>第二章 语法“陷阱”</h1><h2 id="1-理解函数声明"><a href="#1-理解函数声明" class="headerlink" title="1. 理解函数声明"></a>1. 理解函数声明</h2><p>弄懂<code>(*(void(*)())0)();</code>  //首地址为0的函数。</p><p><code>float (*h)()</code>: h是一个指向返回值为浮点型的函数的指针</p><p>所以，<code>(float (*)())</code> 表示一个“指向返回值为浮点型的函数的指针”的类型转换符。</p><p><code>fp()</code>: 是<code>(*fp)( )</code>的简写。</p><p><code>*fp()</code>: 是 <code>*( (*fp) ( ) )</code>的简写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( *<span class="number">0</span> )( );</span><br></pre></td></tr></table></figure><p>虽然上式编译器不认，但可以把0转换为指向“返回值为void的”函数的指针，所以0可变为： <code>( void(*) ( ) ) 0</code> ，代入<code>(*0)()</code>，得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*( <span class="built_in"><span class="keyword">void</span></span>(*) ( ) ) <span class="number">0</span>) ( )</span><br></pre></td></tr></table></figure><p>该式子用等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span>  <span class="params">( *func )</span> <span class="params">( )</span></span>;</span><br><span class="line">( *( func ) <span class="number">0</span> ) ( );</span><br></pre></td></tr></table></figure><p>类似的，signal.h中对signal函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-运算符优先级的问题"><a href="#2-运算符优先级的问题" class="headerlink" title="2. 运算符优先级的问题"></a>2. 运算符优先级的问题</h2><table><thead><tr><th>优先级</th><th>运算符</th><th>名称或含义</th><th>使用形式</th><th>结合方向</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>[]</td><td>数组下标</td><td>数组名[常量表达式]</td><td>左到右</td><td></td></tr><tr><td>1</td><td>()</td><td>圆括号</td><td>(表达式) 函数名(形参表)</td><td>左到右</td><td></td></tr><tr><td>1</td><td>.</td><td>成员选择（对象）</td><td>对象.成员名</td><td>左到右</td><td></td></tr><tr><td>1</td><td>-&gt;</td><td>成员选择（指针）</td><td>对象指针-&gt;成员名</td><td>左到右</td><td></td></tr><tr><td>2</td><td>-</td><td>负号运算符</td><td>-表达式</td><td>右到左</td><td>单目运算符</td></tr><tr><td>2</td><td>(类型)</td><td>强制类型转换</td><td>(数据类型)表达式</td><td>右到左</td><td></td></tr><tr><td>2</td><td>++</td><td>自增运算符</td><td>++变量名 变量名++</td><td>右到左</td><td>单目运算符</td></tr><tr><td>2</td><td>–</td><td>自减运算符</td><td>–变量名 变量名–</td><td>右到左</td><td>单目运算符</td></tr><tr><td>2</td><td>*</td><td>取值运算符</td><td>*指针变量</td><td>右到左</td><td>单目运算符</td></tr><tr><td>2</td><td>&amp;</td><td>取地址运算符</td><td>&amp;变量名</td><td>右到左</td><td>单目运算符</td></tr><tr><td>2</td><td>!</td><td>逻辑非运算符</td><td>!表达式</td><td>右到左</td><td>单目运算符</td></tr><tr><td>2</td><td>~</td><td>按位取反运算符</td><td>~表达式</td><td>右到左</td><td>单目运算符</td></tr><tr><td>2</td><td>sizeof</td><td>长度运算符</td><td>sizeof(表达式)</td><td>右到左</td><td></td></tr><tr><td>3</td><td>/</td><td>除</td><td>表达式 / 表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>3</td><td>*</td><td>乘</td><td>表达式*表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>3</td><td>%</td><td>余数（取模）</td><td>整型表达式%整型表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>4</td><td>+</td><td>加</td><td>表达式+表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>4</td><td>-</td><td>减</td><td>表达式-表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>5</td><td>&lt;&lt;</td><td>左移</td><td>变量&lt;&lt;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>5</td><td>&gt;&gt;</td><td>右移</td><td>变量&gt;&gt;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>6</td><td>&gt;</td><td>大于</td><td>表达式&gt;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>6</td><td>&gt;=</td><td>大于等于</td><td>表达式&gt;=表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>6</td><td>&lt;</td><td>小于</td><td>表达式&lt;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>6</td><td>&lt;=</td><td>小于等于</td><td>表达式&lt;=表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>7</td><td>==</td><td>等于</td><td>表达式==表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>7</td><td>!=</td><td>不等于</td><td>表达式!= 表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>8</td><td>&amp;</td><td>按位与</td><td>表达式&amp;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>9</td><td>^</td><td>按位异或</td><td>表达式^表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>10</td><td>|</td><td>按位或</td><td>表达式|表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>逻辑与</td><td>表达式&amp;&amp;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>12</td><td>||</td><td>逻辑或</td><td>表达式||表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>13</td><td>?:</td><td>条件运算符</td><td>表达式1? 表达式2: 表达式3</td><td>右到左</td><td>三目运算符</td></tr><tr><td>14</td><td>=</td><td>赋值运算符</td><td>变量=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>/=</td><td>除后赋值</td><td>变量/=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>*=</td><td>乘后赋值</td><td>变量*=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>%=</td><td>取模后赋值</td><td>变量%=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>+=</td><td>加后赋值</td><td>变量+=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>-=</td><td>减后赋值</td><td>变量-=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>&lt;&lt;=</td><td>左移后赋值</td><td>变量&lt;&lt;=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>&gt;&gt;=</td><td>右移后赋值</td><td>变量&gt;&gt;=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>&amp;=</td><td>按位与后赋值</td><td>变量&amp;=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>^=</td><td>按位异或后赋值</td><td>变量^=表达式</td><td>右到左</td><td></td></tr><tr><td>14</td><td>|=</td><td>按位或后赋值</td><td>变量|=表达式</td><td>右到左</td><td></td></tr><tr><td>15</td><td>,</td><td>逗号运算符</td><td>表达式,表达式,…</td><td>左到右</td><td></td></tr></tbody></table><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h2><p>主要是别多写分号，switch别忘了break，别写空else分支。</p><h1 id="第三章-语义“陷阱”"><a href="#第三章-语义“陷阱”" class="headerlink" title="第三章 语义“陷阱”"></a>第三章 语义“陷阱”</h1><h2 id="1-指针与数组"><a href="#1-指针与数组" class="headerlink" title="1. 指针与数组"></a>1. 指针与数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Int p[<span class="number">4</span>];</span><br><span class="line">    Double x;</span><br><span class="line">&#125;b[<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> calendar[<span class="number">12</span>][<span class="number">31</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">31</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(calendar):<span class="number">12</span>*<span class="number">31</span>=<span class="number">372</span></span><br><span class="line"></span><br><span class="line">calendar[<span class="number">0</span>] <span class="comment">// 指向该一维数组，对应*p</span></span><br><span class="line">calendar[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">......</span><br><span class="line">calendar[<span class="number">0</span>][<span class="number">30</span>]</span><br><span class="line">calendar[<span class="number">1</span>] <span class="comment">// 指向该一维数组，对应*(p+1)</span></span><br><span class="line">calendar[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">......</span><br><span class="line">calendar[<span class="number">1</span>][<span class="number">30</span>]</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">calendar[<span class="number">11</span>] <span class="comment">// 指向该一维数组，对应*(p+11)</span></span><br><span class="line">calendar[<span class="number">11</span>][<span class="number">0</span>]</span><br><span class="line">......</span><br><span class="line">calendar[<span class="number">11</span>][<span class="number">30</span>]</span><br></pre></td></tr></table></figure><h2 id="2-内存分配"><a href="#2-内存分配" class="headerlink" title="2. 内存分配"></a>2. 内存分配</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(r);</span><br></pre></td></tr></table></figure><p>用malloc显式分配的空间，不会再退出本函数后自动释放掉，而是会等程序员显式释放后才消失。</p><p>注意检查，malloc分配的内存可能失败。</p><p>C语言中会自动地将作为函数参数的数组声明转换为对应的指针声明，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> s[ ])</span></span>&#123; &#125;等价于<span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123; &#125;</span><br><span class="line">但在其他情形下不会自动转换，也就是说不等价，如：</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> hello[ ];和<span class="keyword">extern</span> <span class="keyword">char</span> *hello;完全不同。</span><br></pre></td></tr></table></figure><p><strong>边界计算</strong><br>自己实现一个memcpy函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *source, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( --k &gt;= <span class="number">0</span> )</span><br><span class="line">        *dest++ = *source++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是：操作时一定要知道操作数据的长度。</p><p><strong>整数溢出</strong></p><ul><li>两个有符号整数相加会发生溢出。</li><li>两个无符号整数相加不会发生溢出。</li><li>一个有符号和一个无符号整数相加，因为有符号被自动转换成无符号，所以也不会溢出。</li></ul><h1 id="第四章-连接"><a href="#第四章-连接" class="headerlink" title="第四章 连接"></a>第四章 连接</h1><p>编译器一般每次只处理一个文件。编译器的责任是把C源程序翻译成对连接器有意义的形式。</p><p>许多系统中的连接器是独立于C语言实现的，因此如果链接时候错误原因是与C语言相关的，连接器无法判断错误原因。但连接器能够理解机器语言和内存布局。</p><p>典型的连接器把由汇编器或编译器生成的若干个目标模块，整合成一个被称为载入模块或可执行文件的实体。</p><p>连接器通常把目标模块看成是由一组外部对象组成的。每个外部对象代表着机器内存中的某个部分，并通过一个外部名称来识别。因此，程序中的每个函数和每个外部变量，如果没有被声明为static，就都是一个外部对象。static的不会与其它源程序文件中的同名函数或同名变量发生冲突。对于非satatic的函数或变量的名称冲突的解决办法将在后面讨论。</p><p><strong>除了外部对象外，目标模块中还可能包括了对其他模块中的外部对象的引用，当连接器读入一个目标模块时，它必须解析出这些引用，并作出标记说明这些外部对象不再是未定义的。</strong></p><p>连接器的输入是一组目标模块文件和库文件。输出是一个载入模块。</p><p><strong>避免外部变量的函数的冲突和不一致等问题的办法：</strong></p><blockquote><p><code>每个外部对象只在一个头文件里声明，需要用到该外部对象的所有模块都应该包括这个头文件。</code></p><p><code>定义该外部对象的模块也应该包括这个头文件。</code></p></blockquote><h1 id="第五章-库函数"><a href="#第五章-库函数" class="headerlink" title="第五章 库函数"></a>第五章 库函数</h1><p>没什么好说的，就是apue的一些函数而已。</p><h1 id="第六章-预处理器"><a href="#第六章-预处理器" class="headerlink" title="第六章 预处理器"></a>第六章 预处理器</h1><p>宏定义：主要是理解<strong>宏不是函数，而是直接替换</strong>。</p><ol><li>不能忽视宏定义中的空格：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f (x) ( (x)-1 )：因为f后面多了一个空格，所以f(x)代表(x) ( (x)-1 )</span></span><br></pre></td></tr></table></figure></li><li>宏并不是函数，所以注意那些括号：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> abs(x) ( ( (x) &gt;= 0)?(x):-(x) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ( (a)&gt;(b)?(a):(b) )</span></span><br></pre></td></tr></table></figure></li><li>宏并不是语句：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(e) <span class="meta-keyword">if</span> (!e) assert_error(__FILE__, __LINE__)</span></span><br></pre></td></tr></table></figure></li><li>宏不是类型定义</li></ol><ul><li>错误用法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int_8_ int*</span></span><br><span class="line">        int_8 a,b; <span class="comment">//则a是指针，b是int型</span></span><br></pre></td></tr></table></figure></li><li>正确用法：应该用typedef<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * int_8_;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第七章-可移植性缺陷"><a href="#第七章-可移植性缺陷" class="headerlink" title="第七章 可移植性缺陷"></a>第七章 可移植性缺陷</h1><p>主要是：</p><ol><li>应对C语言标准的变更；</li><li>标识符名称的限制；</li><li>整数的大小；</li><li>字符是有符号整数还是无符号整数；</li><li>移位运算符；<ol><li>在向右移位时，空出的位是由0填充还是1，还是由符号位的副本填充？如果被移位对象是无符号数，那么由0填充；如果是有符号数，那么是0或符号位的副本。</li><li>移位操作的位数允许的取值范围是什么？如果被移位对象的长度是n位，那么移位计数必须大于或等于0，而严格小于n。</li></ol></li><li>移植性需考虑的地方：<ol><li>机器的字符表不同。</li><li>有的机器是one’s complement，有的机器是two’s complement的。基于2的补码的计算机，所允许表示的附属取值范围要大于正数取值范围，所以有时取负值的运算会导致溢出。</li><li>各机器对取模运算的定义不同。</li></ol></li></ol><h1 id="第八章-惯用与答案"><a href="#第八章-惯用与答案" class="headerlink" title="第八章 惯用与答案"></a>第八章 惯用与答案</h1><p>将惯用的<code>c == &#39;\t&#39;</code>写作<code>&#39;\t&#39; == c</code>。</p><p>一旦写错成=号，编译器就能检查出来。</p><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h1 id=&quot;第一章-词法“陷阱”&quot;&gt;&lt;a href=&quot;#第一章-词法“陷阱”&quot; class=&quot;headerlink&quot; title=&quot;第一章 词法“陷阱”&quot;&gt;&lt;/a&gt;第一章 词法“陷阱”&lt;/h1&gt;&lt;h2 id=&quot;1-不同于&quot;</summary>
      
    
    
    
    <category term="程序人生" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="C语言" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://dbkernel.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（下）</title>
    <link href="http://dbkernel.github.io/2014/07/21/c-language-byte-alignment-problem-in-detail-part-2/"/>
    <id>http://dbkernel.github.io/2014/07/21/c-language-byte-alignment-problem-in-detail-part-2/</id>
    <published>2014-07-21T07:35:30.000Z</published>
    <updated>2021-09-06T15:46:02.227Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="6-附录"><a href="#6-附录" class="headerlink" title="6. 附录"></a>6. 附录</h1><h2 id="6-1-字节序与网络序"><a href="#6-1-字节序与网络序" class="headerlink" title="6.1. 字节序与网络序"></a>6.1. 字节序与网络序</h2><h3 id="6-1-1-字节序"><a href="#6-1-1-字节序" class="headerlink" title="6.1.1. 字节序"></a>6.1.1. 字节序</h3><p><strong>字节序</strong>，顾名思义就是<strong>字节的高低位存放顺序</strong>。</p><p>对于单字节，大部分处理器以相同的顺序处理比特位，因此单字节的存放和传输方式一般相同。</p><p>对于多字节数据，如整型（32位机中一般占4字节），在不同的处理器的存放方式主要有两种（以内存中 0x0A0B0C0D 的存放方式为例）。</p><h4 id="6-1-1-1-大字节序（Big-Endian，又称大端序或大尾序）"><a href="#6-1-1-1-大字节序（Big-Endian，又称大端序或大尾序）" class="headerlink" title="6.1.1.1. 大字节序（Big-Endian，又称大端序或大尾序）"></a>6.1.1.1. 大字节序（Big-Endian，又称大端序或大尾序）</h4><p>在计算机中，存储介质以下面方式存储整数 0x0A0B0C0D，则称为<strong>大字节序</strong>：</p><blockquote><p>数据以8bit为单位：<br>低地址方向 -&gt; 0x0A 0x0B    0x0C 0x0D -&gt; 高地址方向</p><p>数据以16bit为单位：<br>低地址方向 -&gt; 0x0A0B 0x0C0D -&gt; 高地址方向</p></blockquote><p>其中，最高有效位(MSB，Most Significant Byte)0x0A存储在最低的内存地址处。下个字节0x0B存在后面的地址处。同时，最高的16bit单元0x0A0B存储在低位。</p><p>简而言之，大字节序就是<strong>高字节存入低地址，低字节存入高地址</strong>。</p><blockquote><p>这里讲个词源典故：“endian”一词来源于乔纳森·斯威夫特的小说《格列佛游记》。小说中，小人国为水煮蛋该从大的一端(Big-End)剥开还是小的一端(Little-End)剥开而争论，争论的双方分别被称为 Big-endians 和 Little-endians 。</p><p>1980年，Danny Cohen在其著名的论文”<em>On Holy Wars and a Plea for Peace</em>“中为平息一场关于字节该以什么样的顺序传送的争论而引用了该词。</p></blockquote><p>借用上面的典故，想象一下要把熟鸡蛋旋转着稳立起来，大头（高字节）肯定在下面（低地址）^_^</p><h4 id="6-1-1-2-小字节序（Little-Endian，又称小端序或小尾序）"><a href="#6-1-1-2-小字节序（Little-Endian，又称小端序或小尾序）" class="headerlink" title="6.1.1.2. 小字节序（Little-Endian，又称小端序或小尾序）"></a>6.1.1.2. 小字节序（Little-Endian，又称小端序或小尾序）</h4><p>在计算机中，存储介质以下面方式存储整数 0x0A0B0C0D 则称为<strong>小字节序</strong>：</p><blockquote><p>数据以8bit为单位：<br>高地址方向 -&gt; 0x0A 0x0B    0x0C 0x0D -&gt; 低地址方向</p><p>数据以16bit为单位：<br>高地址方向 -&gt; 0x0A0B 0x0C0D -&gt; 低地址方向</p></blockquote><p>其中，最低有效位(LSB，Least Significant Byte)0x0D存储在最低的内存地址处。后面字节依次存在后面的地址处。同时，最低的16bit单元0x0A0B存储在低位。</p><p>可见，小字节序就<strong>高字节存入高地址，低字节存入低地址</strong>。</p><p>C语言中的位域结构也要遵循<strong>比特序(类似字节序)</strong> 。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitfield</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a: <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b: <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该位域结构占1个字节，假设赋值a=0x01和b=0x02，则大字节机器上该字节为(01)(000010)，小字节机器上该字节为(000010)(01)</strong> 。因此在编写可移植代码时，需要加条件编译。</p><p>注意，在包含位域的C结构中，<strong>若位域A在位域B之前定义，则位域A所占用的内存空间地址低于位域B所占用的内存空间</strong>。</p><p>另见以下联合体，在小字节机器上若low=0x01，high=0x02，则hex=0x21：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> hex;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> low  : <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> high : <span class="number">4</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;convert;</span><br><span class="line">    convert.low = <span class="number">0x01</span>;</span><br><span class="line">    convert.high = <span class="number">0x02</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hex = 0x%0x\n&quot;</span>, convert.hex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-1-3-注意事项"><a href="#6-1-1-3-注意事项" class="headerlink" title="6.1.1.3. 注意事项"></a>6.1.1.3. 注意事项</h4><p><strong>无论是大字节序，还是小字节序，变量的地址都等于变量所占字节中的低地址。</strong>例如，下述程序中，小字节序输出 0x0D，大字节序输出 0x0A 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> a = <span class="number">0x0A0B0C0D</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%0x\n&quot;</span>, *((<span class="keyword">int8_t</span>*)&amp;dwData));</span><br></pre></td></tr></table></figure><h3 id="6-1-2-网络序"><a href="#6-1-2-网络序" class="headerlink" title="6.1.2. 网络序"></a>6.1.2. 网络序</h3><p>网络传输一般采用<strong>大字节序</strong>，也称为<strong>网络字节序</strong>或<strong>网络序</strong>。IP协议中定义大字节序为网络字节序。</p><p>对于可移植的代码来说，将接收的网络数据转换成主机的字节序是必须的，一般会有成对的函数用于把网络数据转换成相应的主机字节序或反之（若主机字节序与网络字节序相同，通常将函数定义为空宏）。</p><p>伯克利socket API定义了一组转换函数，用于16和32位整数在网络序和主机字节序之间的转换。<code>htonl、htons</code>用于<strong>主机序转换到网络序</strong>；<code>ntohl、ntohs</code>用于<strong>网络序转换到本机序</strong>。</p><p>注意：在大小字节序转换时，必须考虑待转换数据的长度(如5.1.1节的数据单元)。另外<strong>对于单字符或小于单字符的几个bit数据，是不必转换的</strong>，因为<strong>在机器存储和网络发送的一个字符内的bit位存储顺序是一致的</strong>。</p><h3 id="6-1-3-位序"><a href="#6-1-3-位序" class="headerlink" title="6.1.3. 位序"></a>6.1.3. 位序</h3><p>用于描述<strong>串行设备的传输顺序</strong>。<strong>一般硬件传输采用小字节序（先传低位），但I2C协议采用大字节序</strong>。网络协议中只有<strong>数据链路层</strong>的底端会涉及到。</p><h3 id="6-1-4-处理器字节序"><a href="#6-1-4-处理器字节序" class="headerlink" title="6.1.4. 处理器字节序"></a>6.1.4. 处理器字节序</h3><p>不同处理器体系的字节序如下所示：</p><ul><li>X86、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为 <strong>Little endian</strong>；</li><li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC(除V9外) 等处理器为 <strong>Big endian</strong>；</li><li>ARM、PowerPC (除PowerPC 970外)、DEC Alpha，SPARC V9，MIPS，PA-RISC and IA64 等的字节序是<strong>可配置的</strong>。</li></ul><h3 id="6-1-5-字节序编程"><a href="#6-1-5-字节序编程" class="headerlink" title="6.1.5. 字节序编程"></a>6.1.5. 字节序编程</h3><p>请看下面的语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *((<span class="keyword">short</span>*)<span class="string">&quot;AB&quot;</span>) &gt;&gt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>在大字节序下输出为’A’，小字节序下输出为’B’。</p><p>下面的代码可用来判断本地机器字节序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字节序枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    ENDIAN_LITTLE = (INT8U)<span class="number">0X00</span>,</span><br><span class="line">    ENDIAN_BIG    = (INT8U)<span class="number">0X01</span></span><br><span class="line">&#125;E_ENDIAN_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="function">E_ENDIAN_TYPE <span class="title">GetEndianType</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U dwData = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数都从低地址开始访问</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0x78</span> == *((INT8U*)&amp;dwData))</span><br><span class="line">        <span class="keyword">return</span> ENDIAN_LITTLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ENDIAN_BIG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Start of GetEndianTypeTest//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"><span class="function">VOID <span class="title">GetEndianTypeTest</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _BYTE_ORDER == _LITTLE_ENDIAN</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n&quot;</span>, __FUNCTION__,</span><br><span class="line">           (ENDIAN_LITTLE != <span class="built_in">GetEndianType</span>()) ? <span class="string">&quot;ERROR&quot;</span> : <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;Little&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> _BYTE_ORDER == _BIG_ENDIAN</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n&quot;</span>, __FUNCTION__,</span><br><span class="line">           (ENDIAN_BIG != <span class="built_in">GetEndianType</span>()) ? <span class="string">&quot;ERROR&quot;</span> : <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;Big&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//End of GetEndianTypeTest//</span></span><br></pre></td></tr></table></figure><p><strong>在字节序不同的平台间的交换数据时，必须进行转换</strong>。比如对于int类型，大字节序写入文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">write</span>(fd, &amp;i, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>小字节序读出后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">read</span>(fd, &amp;i, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">char</span> buf[<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)];</span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;i, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v = buf[<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) - i - <span class="number">1</span>];</span><br><span class="line">    buf[<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) - <span class="number">1</span>] =  buf[i];</span><br><span class="line">    buf[i] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;i, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>上面仅仅是个例子。在不同平台间即使不存在字节序的问题，也尽量不要直接传递二进制数据。作为可选的方式就是使用文本来交换数据，这样至少可以避免字节序的问题。</p><p>很多的加密算法为了追求速度，都会采取字符串和数字之间的转换，在计算完毕后，必须注意字节序的问题，在某些实现中可以见到使用预编译的方式来完成，这样很不方便，如果使用前面的语句来判断，就可以自动适应。</p><p>字节序问题不仅影响异种平台间传递数据，还影响诸如读写一些特殊格式文件之类程序的可移植性。此时使用预编译的方式来完成也是一个好办法。</p><h2 id="6-2-对齐时的填充字节"><a href="#6-2-对齐时的填充字节" class="headerlink" title="6.2. 对齐时的填充字节"></a>6.2. 对齐时的填充字节</h2><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  c;</span><br><span class="line">    <span class="keyword">int</span>   i;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">    a.c = <span class="number">1</span>; a.i = <span class="number">2</span>; a.s = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(A)=%d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct A));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后输出为sizeof(A)=12。</p><h2 id="6-3-pragma-pack语法说明"><a href="#6-3-pragma-pack语法说明" class="headerlink" title="6.3. pragma pack语法说明"></a>6.3. pragma pack语法说明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure><p>1）<code>#pragma pack(n)</code></p><blockquote><p>该指令指定结构和联合成员的紧凑对齐。而一个完整的转换单元的结构和联合的紧凑对齐由<code>/Zp</code>选项设置。紧凑对齐用pack编译指示在数据说明层设置。该编译指示在其出现后的第一个结构或者联合声明处生效。该编译指示对定义无效。</p><p>当使用<code>#pragma pack (n)</code> 时，n 为1、2、4、8或16。第一个结构成员后的每个结构成员都被存储在更小的成员类型或n字节界限内。如果使用无参量的<code>#pragma pack</code>，结构成员被紧凑为以<code>/Zp</code>指定的值。该缺省<code>/Zp</code>紧凑值为<code>/Zp 8</code>。</p></blockquote><p>2）编译器也支持以下增强型语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack( [ [ &#123; push | pop &#125; , ] [identifier, ] ] [ n] )</span></span><br></pre></td></tr></table></figure><p>若不同的组件使用 pack编译指示 指定不同的紧凑对齐, 这个语法允许你把程序组件组合为一个单独的转换单元。</p><p>带push参量的 pack编译指示 的每次出现将当前的紧凑对齐存储到一个内部编译器堆栈中。编译指示的参量表从左到右读取。如果使用push，则当前紧凑值被存储起来；如果给出一个n值，该值将成为新的紧凑值。若指定一个标识符，即选定一个名称，则该标识符将和这个新的的紧凑值联系起来。</p><p>带一个pop参量的 pack编译指示 的每次出现都会检索内部编译器堆栈顶的值，并使该值为新的紧凑对齐值。如果使用pop参量且内部编译器堆栈是空的，则紧凑值为命令行给定的值，并将产生一个警告信息。若使用pop且指定一个n值，该值将成为新的紧凑值。</p><p>若使用pop且指定一个标识符，所有存储在堆栈中的值将从栈中删除，直到找到一个匹配的标识符。这个与标识符相关的紧凑值也从栈中移出，并且这个仅在标识符入栈之前存在的紧凑值成为新的紧凑值。如果未找到匹配的标识符, 将使用命令行设置的紧凑值，并且将产生一个一级警告。缺省紧凑对齐为8。</p><p><strong>pack编译指示 的新的增强功能让你在编写头文件时，确保在遇到该头文件的前后的紧凑值是一样的</strong>。</p><h2 id="6-4-Intel关于内存对齐的说明"><a href="#6-4-Intel关于内存对齐的说明" class="headerlink" title="6.4. Intel关于内存对齐的说明"></a>6.4. Intel关于内存对齐的说明</h2><p>以下内容节选自《Intel Architecture 32 Manual》。</p><p>字、双字和四字在自然边界上不需要在内存中对齐。（对于字、双字和四字来说，自然边界分别是偶数地址，可以被4整除的地址，和可以被8整除的地址。）</p><p>无论如何，为了提高程序的性能，数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。</p><p>一个字或双字操作数跨越了4字节边界，或者一个四字操作数跨越了8字节边界，被认为是未对齐的，从而需要两次总线周期来访问内存。一个字起始地址是奇数但却没有跨越字边界被认为是对齐的，能够在一个总线周期中被访问。</p><p>某些操作双四字的指令需要内存操作数在自然边界上对齐。如果操作数没有对齐，这些指令将会产生一个通用保护异常(#GP)。双四字的自然边界是能够被16整除的地址。其他操作双四字的指令允许未对齐的访问(不会产生通用保护异常)，然而，需要额外的内存总线周期来访问内存中未对齐的数据。</p><h2 id="6-5-不同架构处理器的对齐要求"><a href="#6-5-不同架构处理器的对齐要求" class="headerlink" title="6.5. 不同架构处理器的对齐要求"></a>6.5. 不同架构处理器的对齐要求</h2><p><strong>RISC指令集处理器（MIPS/ARM）</strong>：这种处理器的设计以效率为先，要求所访问的多字节数据（short/int/long）的地址必须是此数据大小的倍数，如short数据地址应为2的倍数，long数据地址应为4的倍数，也就是说是对齐的。</p><p><strong>CISC指令集处理器(X86)</strong> ：没有上述限制。</p><p><strong>对齐处理策略</strong></p><p>访问非对齐多字节数据时(pack数据)，编译器会将指令拆成多条(因为非对齐多字节数据可能跨越地址对齐边界)，保证每条指令都从正确的起始地址上获取数据，但也因此效率比较低。</p><p>访问对齐数据时则只用一条指令获取数据，因此对齐数据必须确保其起始地址是在对齐边界上。如果不是在对齐的边界，对X86 CPU是安全的，但对MIPS/ARM这种RISC CPU会出现<code>总线访问异常</code>。</p><p>为什么X86是安全的呢？</p><blockquote><p>X86 CPU是如何进行数据对齐的？</p><p>X86 CPU的<code>EFLAGS寄存器</code>中包含一个特殊的位标志，称为<code>AC</code>(对齐检查的英文缩写)标志。</p><p>按照默认设置，当CPU首次加电时，该标志被设置为0。</p><p>当该标志是0时，CPU能够自动执行它应该执行的操作，以便成功地访问未对齐的数据值。</p><p>然而，如果该标志被设置为1，每当系统试图访问未对齐的数据时，CPU就会发出一个<code>INT 17H中断</code>。</p><p>X86的Windows 2000和Windows 98版本从来不改变这个CPU标志位。因此，当应用程序在X86处理器上运行时，你根本看不到应用程序中出现数据未对齐的异常条件。</p></blockquote><p>为什么MIPS/ARM不安全呢？</p><blockquote><p><strong>因为MIPS/ARM CPU不能自动处理对未对齐数据的访问</strong>。当未对齐的数据访问发生时，CPU就会将这一情况通知操作系统。这时，操作系统将会确定它是否应该引发一个数据未对齐异常条件，对vxworks是会触发这个异常的。</p></blockquote><h2 id="6-6-ARM下的对齐处理"><a href="#6-6-ARM下的对齐处理" class="headerlink" title="6.6. ARM下的对齐处理"></a>6.6. ARM下的对齐处理</h2><p>有部分摘自ARM编译器文档对齐部分。</p><p>对齐的使用：</p><ol><li><p><code>__align(num)</code> 用于修改最高级别对象的字节边界。</p><blockquote><ul><li>在汇编中使用LDRD或STRD时就要用到此命令<code>__align(8)</code>进行修饰限制。来保证数据对象是相应对齐。</li><li>这个修饰对象的命令最大是8个字节限制，可以让2字节的对象进行4字节对齐，但不能让4字节的对象2字节对齐。</li><li><code>__align</code>是存储类修改，只修饰最高级类型对象，不能用于结构或者函数对象。</li></ul></blockquote></li><li><p><code>__packed</code> 进行一字节对齐。需注意：</p><blockquote><ul><li>不能对packed的对象进行对齐；</li><li>所有对象的读写访问都进行非对齐访问；</li><li>float及包含float的结构联合及未用__packed的对象将不能字节对齐；</li><li>__packed对局部整型变量无影响。</li><li>强制由unpacked对象向packed对象转化时未定义。整型指针可以合法定义为packed，如__packed int* p(__packed int 则没有意义)</li></ul></blockquote></li></ol><p>对齐或非对齐读写访问可能存在的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义如下结构，b的起始地址不对齐。在栈中访问b可能有问题，因为栈上数据对齐访问</span></span><br><span class="line">__packed <span class="class"><span class="keyword">struct</span> <span class="title">STRUCT_TEST</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span>  b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下面的变量定义成全局静态(不在栈上)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">STRUCT_TEST</span> <span class="title">a</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __packed <span class="keyword">int</span> *q; <span class="comment">//定义成__packed来修饰当前q指向为非对齐的数据地址下面的访问则可以</span></span><br><span class="line">    p = (<span class="keyword">char</span>*)&amp;a;</span><br><span class="line">    q = (<span class="keyword">int</span>*)(p + <span class="number">1</span>);</span><br><span class="line">    *q = <span class="number">0x87654321</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 得到赋值的汇编指令很清楚</span></span><br><span class="line"><span class="comment">    ldr      r5,0x20001590 ; = #0x12345678</span></span><br><span class="line"><span class="comment">    [0xe1a00005]   mov     r0,r5</span></span><br><span class="line"><span class="comment">    [0xeb0000b0]   bl      __rt_uwrite4  //在此处调用一个写4字节的操作函数</span></span><br><span class="line"><span class="comment">    [0xe5c10000]   strb    r0,[r1,#0]    //函数进行4次strb操作然后返回，正确访问数据</span></span><br><span class="line"><span class="comment">    [0xe1a02420]   mov     r2,r0,lsr #8</span></span><br><span class="line"><span class="comment">    [0xe5c12001]   strb    r2,[r1,#1]</span></span><br><span class="line"><span class="comment">    [0xe1a02820]   mov     r2,r0,lsr #16</span></span><br><span class="line"><span class="comment">    [0xe5c12002]   strb    r2,[r1,#2]</span></span><br><span class="line"><span class="comment">    [0xe1a02c20]   mov     r2,r0,lsr #24</span></span><br><span class="line"><span class="comment">    [0xe5c12003]   strb    r2,[r1,#3]</span></span><br><span class="line"><span class="comment">    [0xe1a0f00e]   mov     pc,r14</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    若q未加__packed修饰则汇编出来指令如下(会导致奇地址处访问失败)：</span></span><br><span class="line"><span class="comment">    [0xe59f2018]   ldr      r2,0x20001594 ; = #0x87654321</span></span><br><span class="line"><span class="comment">    [0xe5812000]   str     r2,[r1,#0]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//这样很清楚地看到非对齐访问如何产生错误，以及如何消除非对齐访问带来的问题</span></span><br><span class="line">    <span class="comment">//也可看到非对齐访问和对齐访问的指令差异会导致效率问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-7-《The-C-Book》之位域篇"><a href="#6-7-《The-C-Book》之位域篇" class="headerlink" title="6.7. 《The C Book》之位域篇"></a>6.7. 《The C Book》之位域篇</h2><p>While we’re on the subject of structures, we might as well look at bitfields. They can only be declared inside a structure or a union, and allow you to specify some very small objects of a given number of bits in length. Their usefulness is limited and they aren’t seen in many programs, but we’ll deal with them anyway. This example should help to make things clear:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> field1 :<span class="number">4</span>; <span class="comment">//field 4 bits wide</span></span><br><span class="line">    <span class="keyword">unsigned</span>        :<span class="number">3</span>; <span class="comment">//unnamed 3 bit field(allow for padding)</span></span><br><span class="line">    <span class="keyword">signed</span> field2   :<span class="number">1</span>; <span class="comment">//one-bit field(can only be 0 or -1 in two&#x27;s complement)</span></span><br><span class="line">    <span class="keyword">unsigned</span>        :<span class="number">0</span>; <span class="comment">//align next field on a storage unit</span></span><br><span class="line">    <span class="keyword">unsigned</span> field3 :<span class="number">6</span>;</span><br><span class="line">&#125;full_of_fields;</span><br></pre></td></tr></table></figure><p>Each field is accessed and manipulated as if it were an ordinary member of a structure. The keywords signed and unsigned mean what you would expect, except that it is interesting to note that a 1-bit signed field on a two’s complement machine can only take the values 0 or -1. The declarations are permitted to include the const and volatile qualifiers.</p><p>The main use of bitfields is either to allow tight packing of data or to be able to specify the fields within some externally produced data files. C gives no guarantee of the ordering of fields within machine words, so if you do use them for the latter reason, you program will not only be non-portable, it will be compiler-dependent too. The Standard says that fields are packed into ‘storage units’, which are typically machine words. The packing order, and whether or not a bitfield may cross a storage unit boundary, are implementation defined. To force alignment to a storage unit boundary, a zero width field is used before the one that you want to have aligned.</p><p>Be careful using them. It can require a surprising amount of run-time code to manipulate these things and you can end up using more space than they save.</p><p>Bit fields do not have addresses—you can’t have pointers to them or arrays of them.</p><h2 id="6-8-C语言字节相关面试题"><a href="#6-8-C语言字节相关面试题" class="headerlink" title="6.8. C语言字节相关面试题"></a>6.8. C语言字节相关面试题</h2><h3 id="6-8-1-Intel-微软C语言面试题"><a href="#6-8-1-Intel-微软C语言面试题" class="headerlink" title="6.8.1. Intel/微软C语言面试题"></a>6.8.1. Intel/微软C语言面试题</h3><p>请看下面的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> a; <span class="comment">// 按 min(1,8) 对齐</span></span><br><span class="line">    <span class="keyword">long</span>  b; <span class="comment">// 按 min(4,8) 对齐</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    s1   d;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> e;  <span class="comment">//VC6.0下可能要用__int64代替双long</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ol><li>sizeof(s2) = ？</li><li>s2的s1中的a后面空了几个字节接着是b？</li></ol><p>分析：</p><blockquote><p>成员对齐有一个重要的条件，即<strong>每个成员分别按自己的方式对齐</strong>。</p><p>也就是说上面虽然指定了按8字节对齐，但并不是所有的成员都是以8字节对齐。其对齐的规则是：<strong>每个成员按 <code>其类型的对齐参数（通常是这个类型的大小）</code> 和 <code>指定对齐参数（这里是8字节）</code> 中较小的一个对齐，并且结构的长度必须为所用过的所有对齐参数的整数倍，不够就补空字节。</strong></p><p>s1中成员a是1字节，默认按1字节对齐，而指定对齐参数为8，两值中取1，即a按1字节对齐；成员b是4个字节，默认按4字节对齐，这时就按4字节对齐，所以<code>sizeof(s1)应该为8</code>；</p><p>s2中c和s1中a一样，按1字节对齐。而d是个8字节结构体，其默认对齐方式就是所有成员使用的对齐参数中最大的一个，s1的就是4。所以，成员d按4字节对齐。成员e是8个字节，默认按8字节对齐，和指定的一样，所以它对到8字节的边界上。这时，已经使用了12个字节，所以又添加4个字节的空，从第16个字节开始放置成员e。此时长度为24，并可被8（成员e按8字节对齐）整除。这样，一共使用了24个字节。</p></blockquote><p>各个变量在内存中的布局为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c***aa**</span><br><span class="line">bbbb****</span><br><span class="line">dddddddd ——这种“矩阵写法”很方便看出结构体实际大小！</span><br></pre></td></tr></table></figure><p>因此，<code>sizeof(S2)结果为24，a后面空了2个字节接着是b</code>。</p><p>这里有三点很重要：</p><ol><li>每个成员分别按自己的方式对齐，并能最小化长度；</li><li>复杂类型(如结构)的默认对齐方式是其最长的成员的对齐方式，这样在成员是复杂类型时可以最小化长度；</li><li>对齐后的长度必须是成员中最大对齐参数的整数倍，这样在处理数组时可保证每一项都边界对齐。</li></ol><p>还要注意，“空结构体”(不含数据成员)的大小为1，而不是0。试想如果不占空间的话，一个空结构体变量如何取地址、两个不同的空结构体变量又如何得以区分呢？</p><h3 id="6-8-2-上海网宿科技面试题"><a href="#6-8-2-上海网宿科技面试题" class="headerlink" title="6.8.2 上海网宿科技面试题"></a>6.8.2 上海网宿科技面试题</h3><p>假设硬件平台是intel x86(little endian)，以下程序输出什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设硬件平台是intel x86(little endian)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">uint32_t</span> in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>  b[<span class="number">18</span>];</span><br><span class="line">    <span class="keyword">register</span>  <span class="keyword">char</span>  *p;</span><br><span class="line">    p = (<span class="keyword">char</span> *)∈</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UC(b) (((int)b)&amp;0xff) <span class="comment">//byte转换为无符号int型</span></span></span><br><span class="line">    <span class="built_in">sprintf</span>(b, <span class="string">&quot;%d.%d.%d.%d\n&quot;</span>, <span class="built_in">UC</span>(p[<span class="number">0</span>]), <span class="built_in">UC</span>(p[<span class="number">1</span>]), <span class="built_in">UC</span>(p[<span class="number">2</span>]), <span class="built_in">UC</span>(p[<span class="number">3</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">inet_ntoa</span>(<span class="number">0x12345678</span>);</span><br><span class="line">    <span class="built_in">inet_ntoa</span>(<span class="number">0x87654321</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;a;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%d.%d.%d.%d\n&quot;</span>, p[<span class="number">0</span>], p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按照小字节序的规则，变量a在计算机中存储方式为：</strong></p><blockquote><p>高地址方向 ————–&gt; 低地址方向<br>0x12 0x34 0x56 0x78<br>p[3] p[2] p[1] p[0]</p></blockquote><p>注意：<strong>p并不是指向0x12345678的开头0x12，而是指向0x78</strong>。p[0]到p[1]的操作是&amp;p[0]+1，因此p[1]地址比p[0]地址大。输出结果为<code>120.86.52.18</code>。</p><p>反过来的话，令<code>int a = 0x87654321</code>，则输出结果为<code>33.67.101.-121</code>。</p><p>为什么有负值呢？</p><blockquote><p>因为系统默认的char是有符号的，本来是0x87也就是135，大于127因此就减去256得到-121。</p></blockquote><p>想要得到正值的话只需将<code>char *p = (char *)&amp;a</code>改为<code>unsigned char *p = (unsigned char *)&amp;a</code>即可。</p><p>综上不难得出，网宿面试题的答案为<code>120.86.52.18</code>和<code>33.67.101.135</code>。</p><blockquote><p><strong>说明：</strong><br>本文转载自 <a href="https://www.cnblogs.com/clover-toeic/p/3853132.html">https://www.cnblogs.com/clover-toeic/p/3853132.html</a></p></blockquote><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;h1 id=&quot;6-附录&quot;&gt;&lt;a href=&quot;#6-附录&quot; class=&quot;headerlink&quot; title=&quot;6. 附录&quot;&gt;&lt;/a&gt;6. 附录&lt;/h1&gt;&lt;h2 id=&quot;6-1-字节序与网络序&quot;&gt;&lt;a href=&quot;#6-1-字节</summary>
      
    
    
    
    <category term="程序人生" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="C语言" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://dbkernel.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="字节对齐" scheme="http://dbkernel.github.io/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
    <category term="字节序" scheme="http://dbkernel.github.io/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    
    <category term="网络序" scheme="http://dbkernel.github.io/tags/%E7%BD%91%E7%BB%9C%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>程序人生 | C语言字节对齐问题详解 - 对齐/字节序/位序/网络序等（上）</title>
    <link href="http://dbkernel.github.io/2014/07/21/c-language-byte-alignment-problem-in-detail-part-1/"/>
    <id>http://dbkernel.github.io/2014/07/21/c-language-byte-alignment-problem-in-detail-part-1/</id>
    <published>2014-07-21T07:32:28.000Z</published>
    <updated>2021-09-06T03:36:20.927Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>考虑下面的结构体定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  c1;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">char</span>  c2;</span><br><span class="line">    <span class="keyword">int</span>   i;</span><br><span class="line">&#125;T_FOO;</span><br></pre></td></tr></table></figure><p>假设这个结构体的成员在内存中是紧凑排列的，且c1的起始地址是0，则s的地址就是1，c2的地址是3，i的地址是4。</p><p>现在，我们编写一个简单的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    T_FOO a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c1 -&gt; %d, s -&gt; %d, c2 -&gt; %d, i -&gt; %d\n&quot;</span>,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.c1 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.s  - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.c2 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.i  - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 -&gt; <span class="number">0</span>, s -&gt; <span class="number">2</span>, c2 -&gt; <span class="number">4</span>, i -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><p>为什么会这样？这就是字节对齐导致的问题。</p><p>本文在参考诸多资料的基础上，详细介绍常见的字节对齐问题。因成文较早，资料来源大多已不可考，敬请谅解。</p><h1 id="2-什么是字节对齐"><a href="#2-什么是字节对齐" class="headerlink" title="2. 什么是字节对齐"></a>2. 什么是字节对齐</h1><p>现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量，但实际上在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是一个接一个地顺序存放，这就是对齐。</p><h1 id="3-对齐的原因和作用"><a href="#3-对齐的原因和作用" class="headerlink" title="3. 对齐的原因和作用"></a>3. 对齐的原因和作用</h1><ol><li><strong>不同硬件平台对存储空间的处理上存在很大的不同</strong>。某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如 Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。</li><li><strong>如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失</strong>。比如32位的 Intel 处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。因此，<strong>通过合理的内存对齐可以提高访问效率。</strong> 为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。</li><li><strong>合理利用字节对齐还可以有效地节省存储空间</strong>。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度，因此，<strong>需要考虑处理器类型</strong>。同时，<strong>还应考虑编译器的类型</strong>，<code>在VC/C++和GNU GCC中都是默认是4字节对齐</code>。</li></ol><h1 id="4-对齐的分类和准则"><a href="#4-对齐的分类和准则" class="headerlink" title="4. 对齐的分类和准则"></a>4. 对齐的分类和准则</h1><p>本小节主要基于 Intel X86 架构介绍结构体对齐和栈内存对齐，<strong>位域</strong>本质上为结构体类型。</p><p><strong>对于 Intel X86 平台，每次分配内存应该是从4的整数倍地址开始分配，无论是对结构体变量还是简单类型的变量。</strong></p><h2 id="4-1-结构体对齐"><a href="#4-1-结构体对齐" class="headerlink" title="4.1. 结构体对齐"></a>4.1. 结构体对齐</h2><p>在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型（int、long、float等）的变量，也可以是一些复合数据类型（数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界（alignment）分配空间。各成员按照它们被声明的顺序在内存中顺序存储，<strong>第一个成员的地址和整个结构的地址相同。</strong></p><p>字节对齐的问题主要就是针对结构体。</p><h3 id="4-1-1-简单示例"><a href="#4-1-1-简单示例" class="headerlink" title="4.1.1. 简单示例"></a>4.1.1. 简单示例</h3><p>先看个简单的例子（32位，X86处理器，GCC编译器）：</p><p>【例1】假设结构体定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>    a;</span><br><span class="line">    <span class="keyword">char</span>   b;</span><br><span class="line">    <span class="keyword">short</span>  c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>   b;</span><br><span class="line">    <span class="keyword">int</span>    a;</span><br><span class="line">    <span class="keyword">short</span>  c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>已知32位机器上各数据类型的长度为：char为1字节、short为2字节、int为4字节、long为4字节、float为4字节、double为8字节。那么上面两个结构体大小如何呢？</p><p>结果是：<strong>sizeof(strcut A)值为8；sizeof(struct B)的值却是12</strong>。</p><p>结构体A和B中字段一样，包含一个4字节的int数据，一个1字节char数据和一个2字节short数据，只是顺序不同。按理说A和B大小应该都是7字节，之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。</p><h3 id="4-1-2-对齐准则"><a href="#4-1-2-对齐准则" class="headerlink" title="4.1.2. 对齐准则"></a>4.1.2. 对齐准则</h3><p>先来看四个重要的基本概念：</p><ol><li><p><strong>数据类型自身的对齐值</strong>：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。</p></li><li><p><strong>结构体或类的自身对齐值</strong>：<code>其成员中自身对齐值最大的那个值</code>。</p></li><li><p><strong>指定对齐值</strong>：<code>#pragma pack (value)</code> 指定对齐值 value。</p></li><li><p><strong>数据成员、结构体和类的有效对齐值</strong>：自身对齐值和指定对齐值中较小者，即<code>有效对齐值=min&#123;自身对齐值，当前指定的pack值&#125;</code>。</p></li></ol><p>基于上面这些原则，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。</p><p>其中，有效对齐值 N 是最终用来决定数据存放地址方式的值。有效对齐值 N 表示“对齐在N上”，即该数据的<code>存放起始地址 % N = 0</code>。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。<strong>结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整</strong>（即<code>结构体成员变量占用总长度为结构体有效对齐值的整数倍</code>）。</p><p>以此分析3.1.1节中的结构体B：</p><blockquote><p>假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。</p><p>成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。</p><p>变量c自身对齐值为2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。</p><p>所以从0x0000~0x0009存放的都是B内容。</p><p>再看数据结构B的自身对齐值为其变量中最大对齐值（这里是b），也就是4，所以结构体的有效对齐值也是4。<strong>根据结构体圆整的要求，0x0000~0x0009=10字节，(10＋2)％4＝0</strong>。</p><p>所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B，共有12个字节，sizeof(struct B)=12。</p></blockquote><p><strong>之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率</strong>。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？</p><p>按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。</p><p>其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。</p><p>上面的概念非常便于理解，不过个人还是更喜欢下面的对齐准则。</p><p><strong>结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则：</strong></p><ol><li><strong>结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</strong></li><li><strong>结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；</strong></li><li><strong>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。</strong></li></ol><p>对于以上规则的说明如下：</p><ul><li>第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。<code>将这个最宽的基本数据类型的大小作为上面介绍的对齐模数</code>。</li><li>第二条：为结构体的一个成员开辟空间之前，<code>编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍</code>，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</li><li>第三条：<code>结构体总大小是包括填充字节</code>，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。</li></ul><p>【例2】假设4字节对齐，以下程序的输出结果是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* OFFSET宏定义可取得指定结构体某成员在结构体内部的偏移 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET(st, field) (size_t)&amp;(((st*)0)-&gt;field)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">char</span>  c;</span><br><span class="line">    <span class="keyword">int</span>   d;</span><br><span class="line">    <span class="keyword">char</span>  e[<span class="number">3</span>];</span><br><span class="line">&#125;T_Test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size = %d\n  a-%d, b-%d, c-%d, d-%d\n  e[0]-%d, e[1]-%d, e[2]-%d\n&quot;</span>,</span><br><span class="line">           <span class="built_in"><span class="keyword">sizeof</span></span>(T_Test), <span class="built_in">OFFSET</span>(T_Test, a), <span class="built_in">OFFSET</span>(T_Test, b),</span><br><span class="line">           <span class="built_in">OFFSET</span>(T_Test, c), <span class="built_in">OFFSET</span>(T_Test, d), <span class="built_in">OFFSET</span>(T_Test, e[<span class="number">0</span>]),</span><br><span class="line">           <span class="built_in">OFFSET</span>(T_Test, e[<span class="number">1</span>]),<span class="built_in">OFFSET</span>(T_Test, e[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行后输出如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Size = 16</span><br><span class="line">a-0, b-2, c-4, d-8</span><br><span class="line">e[0]-12, e[1]-13, e[2]-14</span><br></pre></td></tr></table></figure><p><strong>下面来具体分析：</strong></p><blockquote><p>首先char a占用1个字节，没问题。</p><p>short b本身占用2个字节，根据上面准则2，需要在b和a之间填充1个字节。</p><p>char c占用1个字节，没问题。</p><p>int d本身占用4个字节，根据准则2，需要在d和c之间填充3个字节。</p><p>char e[3]；本身占用3个字节，根据原则3，需要在其后补充1个字节。</p><p>因此，sizeof(T_Test) = 1 + 1 + 2 + 1 + 3 + 4 + 3 + 1 = 16字节。</p></blockquote><h3 id="4-1-3-对齐的隐患"><a href="#4-1-3-对齐的隐患" class="headerlink" title="4.1.3. 对齐的隐患"></a>4.1.3. 对齐的隐患</h3><h4 id="4-1-3-1-数据类型转换"><a href="#4-1-3-1-数据类型转换" class="headerlink" title="4.1.3.1. 数据类型转换"></a>4.1.3.1. 数据类型转换</h4><p><strong>代码中关于对齐的隐患，很多是隐式的</strong>。例如，在强制类型转换的时候：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    *p = <span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *p1 = (<span class="keyword">unsigned</span> <span class="keyword">short</span> *)(p+<span class="number">1</span>);</span><br><span class="line">    *p1 = <span class="number">0x0000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后两句代码，<code>从奇数边界去访问 unsigned short 型变量，显然不符合对齐的规定。在X86上，类似的操作只会影响效率；但在MIPS或者SPARC上可能导致error，因为它们要求必须字节对齐</code>。</p><p>又如对于3.1.1节的结构体 struct B，定义如下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(struct B *p)</span></span>&#123;</span><br><span class="line">     <span class="comment">//Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数体内如果直接访问 p-&gt;a，则很可能会异常。因为MIPS认为a是int，其地址应该是4的倍数，但p-&gt;a的地址很可能不是4的倍数。</p><p><strong>如果p的地址不在对齐边界上就可能出问题</strong>，比如p来自一个跨CPU的数据包(多种数据类型的数据被按顺序放置在一个数据包中传输)，或p是经过指针移位算出来的。因此要特别注意跨CPU数据的接口函数对接口输入数据的处理，以及指针移位再强制转换为结构指针进行访问时的安全性。</p><p><strong>解决方式如下：</strong></p><ol><li>定义一个此结构的局部变量，用<code>memmove</code>方式将数据拷贝进来。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(struct B *p)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">tData</span>;</span></span><br><span class="line">    <span class="built_in">memmove</span>(&amp;tData, p, <span class="built_in"><span class="keyword">sizeof</span></span>(struct B));</span><br><span class="line">     <span class="comment">//此后可安全访问tData.a，因为编译器已将tData分配在正确的起始地址上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意：<strong>如果能确定p的起始地址没问题，则不需要这么处理；如果不能确定（比如跨CPU输入数据、或指针移位运算出来的数据），则需要这样处理。</strong></li><li>用<code>#pragma pack (1)</code>将 STRUCT_T 定义为1字节对齐方式。</li></ol><h4 id="4-1-3-2-处理器间数据通信"><a href="#4-1-3-2-处理器间数据通信" class="headerlink" title="4.1.3.2. 处理器间数据通信"></a>4.1.3.2. 处理器间数据通信</h4><p><strong>处理器间通过消息（对于C/C++而言就是结构体）进行通信时，需要注意字节对齐以及字节序的问题。</strong></p><p>大多数编译器提供一些内存选项供用户使用。这样用户可以根据处理器的情况选择不同的字节对齐方式。例如：C/C++编译器提供的<code>#pragma pack(n) n=1，2，4</code>等，让编译器在生成目标文件时，<code>使内存数据按照指定的方式排布在1，2，4等字节整除的内存地址处</code>。</p><p>然而在不同编译平台或处理器上，字节对齐会造成消息结构长度的变化。<strong>编译器为了使字节对齐可能会对消息结构体进行填充，不同编译平台可能填充为不同的形式，大大增加处理器间数据通信的风险。</strong></p><p>下面以32位处理器为例，提出一种内存对齐方法以解决上述问题。</p><p>对于本地使用的数据结构，为提高内存访问效率，采用4字节对齐方式；同时为了减少内存的开销，合理安排结构体成员的位置，减少4字节对齐导致的成员之间的空隙，降低内存开销。</p><p>对于处理器之间的数据结构，需要保证消息长度不会因不同编译平台或处理器而导致消息结构体长度发生变化，使用1字节对齐方式对消息结构进行紧缩；为保证处理器之间的消息数据结构的内存访问效率，采用字节填充的方式自己对消息中成员进行4字节对齐。</p><p>数据结构的成员位置要兼顾成员之间的关系、数据访问效率和空间利用率。<strong>顺序安排原则是：4字节的放在最前面，2字节的紧接最后一个4字节成员，1字节紧接最后一个2字节成员，填充字节放在最后。</strong></p><p>举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_T_MSG</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span>  ParaA;</span><br><span class="line">    <span class="keyword">long</span>  ParaB;</span><br><span class="line">    <span class="keyword">short</span> ParaC；</span><br><span class="line">    <span class="keyword">char</span>  ParaD;</span><br><span class="line">    <span class="keyword">char</span>  Pad;   <span class="comment">//填充字节</span></span><br><span class="line">&#125;T_MSG;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-3-排查对齐问题"><a href="#4-1-3-3-排查对齐问题" class="headerlink" title="4.1.3.3. 排查对齐问题"></a>4.1.3.3. 排查对齐问题</h4><p>如果出现对齐或者赋值问题，可查看：</p><ol><li>编译器的字节序大小端设置；</li><li>处理器架构本身是否支持非对齐访问；<blockquote><p>如果支持，则看是否设置对齐；</p><p>如果没有，则看访问时是否需要加某些特殊的修饰来标志其特殊访问操作。</p></blockquote></li></ol><h3 id="4-1-4-更改对齐方式"><a href="#4-1-4-更改对齐方式" class="headerlink" title="4.1.4. 更改对齐方式"></a>4.1.4. 更改对齐方式</h3><p>主要是<strong>更改C编译器的缺省字节对齐方式</strong>。</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><ul><li>使用<code>伪指令#pragma pack(n)</code>：C编译器将按照n个字节对齐；</li><li>使用<code>伪指令#pragma pack()</code>：取消自定义字节对齐方式。</li></ul><p>另外，还有如下的一种方式（GCC特有语法）：</p><ul><li><code>__attribute__((aligned (n)))</code>：让所作用的结构成员对齐在n字节自然边界上。如果结构体中有成员的长度大于n，则按照最大成员的长度来对齐。</li><li><code>__attribute__((packed))</code>：取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。</li></ul><blockquote><p><strong>注意：</strong></p><p><code>__attribute__</code>机制是GCC的一大特色，可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)和类型属性(Type Attribute)。</p></blockquote><p><strong>在编码时，可用<code>#pragma pack</code>动态修改对齐值</strong>。具体语法说明见附录5.3节。</p><p>自定义对齐值后要用<code>#pragma pack()</code>来还原，否则会对后面的结构造成影响。</p><p>【例3】分析如下结构体C：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)  <span class="comment">//指定按2字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  b;</span><br><span class="line">    <span class="keyword">int</span>   a;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()   <span class="comment">//取消指定对齐，恢复缺省对齐</span></span></span><br></pre></td></tr></table></figure><blockquote><p>变量b自身对齐值为1，指定对齐值为2，所以有效对齐值为1，假设C从0x0000开始，则b存放在0x0000，符合0x0000%1=0；</p><p>变量a自身对齐值为4，指定对齐值为2，所以有效对齐值为2，顺序存放在0x0002~0x0005四个连续字节中，符合0x0002%2=0。</p><p>变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006~0x0007中，符合0x0006%2=0。</p><p>所以从0x0000到0x00007共8字节存放的是C的变量。</p><p>C的自身对齐值为4，所以其有效对齐值为2。又8%2=0，C只占用0x0000~0x0007的八个字节。所以sizeof(struct C)=8。</p></blockquote><p>注意：<strong>结构体对齐到的字节数并非完全取决于当前指定的pack值</strong>，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  b;</span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">char</span>  c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>虽然<code>#pragma pack(8)</code>，但依然按照2字节对齐，所以 sizeof(struct D) 的值为6。所以，<strong>对齐到的字节数=min｛当前指定的pack值，最大成员大小｝</strong>。</p><p>另外，GNU GCC编译器中按1字节对齐可写为以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNUC_PACKED __attribute__((packed))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  b;</span><br><span class="line">    <span class="keyword">int</span>   a;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;GNUC_PACKED;</span><br></pre></td></tr></table></figure><p>此时 sizeof(struct C) 的值为7。</p><h2 id="4-2-栈内存对齐"><a href="#4-2-栈内存对齐" class="headerlink" title="4.2. 栈内存对齐"></a>4.2. 栈内存对齐</h2><p><strong>在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响，总是保持对齐在4字节边界上</strong>。</p><p>【例4】分析栈内存对齐方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)  <span class="comment">//后面可改为1, 2, 4, 8</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StrtE</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">long</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">double</span> d[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StrtE</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a    address:   %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b    address:   %p\n&quot;</span>, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c    address:   %p\n&quot;</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d[0] address:   %p\n&quot;</span>, &amp;(d[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d[1] address:   %p\n&quot;</span>, &amp;(d[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s    address:   %p\n&quot;</span>, &amp;s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s.m2 address:   %p\n&quot;</span>, &amp;(s.m2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a    address:   0xbfc4cfff</span><br><span class="line">b    address:   0xbfc4cffc</span><br><span class="line">c    address:   0xbfc4cff8</span><br><span class="line">d[0] address:   0xbfc4cfe8</span><br><span class="line">d[1] address:   0xbfc4cff0</span><br><span class="line">s    address:   0xbfc4cfe3</span><br><span class="line">s.m2 address:   0xbfc4cfe4</span><br></pre></td></tr></table></figure><p>可以看出都是对齐到4字节，并且前面的char和short并没有被凑在一起（成4字节），这和结构体内的处理是不同的。</p><p>至于为什么输出的地址值是变小的，这是因为该平台下的栈是倒着“生长”的。</p><h2 id="4-3-位域对齐"><a href="#4-3-位域对齐" class="headerlink" title="4.3. 位域对齐"></a>4.3. 位域对齐</h2><h3 id="4-3-1-位域定义"><a href="#4-3-1-位域定义" class="headerlink" title="4.3.1. 位域定义"></a>4.3.1. 位域定义</h3><p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。为了节省存储空间和处理简便，C语言提供了一种数据结构，称为<strong>位域</strong>或<strong>位段</strong>。</p><p>位域是一种特殊的结构成员或联合成员（即只能用在结构或联合中），用于指定该成员在内存存储时所占用的位数，从而在机器内更紧凑地表示数据。每个位域有一个域名，允许在程序中按域名操作对应的位，这样就可用一个字节的二进制位域来表示几个不同的对象。</p><p>位域定义与结构定义类似，其形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名</span></span><br><span class="line"><span class="class">       &#123;</span> 位域列表 &#125;;</span><br></pre></td></tr></table></figure><p>其中位域列表的形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明符位域名：位域长度</span><br></pre></td></tr></table></figure><p>位域的使用和结构成员的使用相同，其一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位域变量名.位域名</span><br></pre></td></tr></table></figure><p>位域允许用各种格式输出。</p><p><strong>位域在本质上就是一种结构类型，不过其成员是按二进位分配的</strong>。位域变量的说明与结构变量说明的方式相同，可先定义后说明、同时定义说明或直接说明。</p><p><strong>位域的使用主要为下面两种情况：</strong></p><ol><li>当机器可用内存空间较少而使用位域可大量节省内存时。例如：把结构作为大数组的元素时。</li><li>当需要把一结构体或联合映射成某预定的组织结构时。例如：需要访问字节内的特定位时。</li></ol><h3 id="4-3-2-对齐准则"><a href="#4-3-2-对齐准则" class="headerlink" title="4.3.2. 对齐准则"></a>4.3.2. 对齐准则</h3><p><code>位域成员不能单独被取sizeof值</code>。下面主要讨论含有位域的结构体的sizeof。</p><p>C99规定 int、unsigned int 和 bool 可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。</p><p><strong>其对齐规则大致为：</strong></p><ol><li>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</li><li>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</li><li><strong>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式</strong>；</li><li>如果位域字段之间穿插着非位域字段，则不进行压缩；</li><li><strong>整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐</strong>。</li></ol><p>【例5】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1  : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> element2  : <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位域类型为char，第1个字节仅能容纳下element1和element2，所以element1和element2被压缩到第1个字节中，而element3只能从下一个字节开始。因此 sizeof(BitField) 的结果为2。</p><p>【例6】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField1</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1   : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">short</span> element2  : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> element3   : <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于相邻位域类型不同，在VC6中其sizeof为6，在Dev-C++中为2。</p><p>【例7】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1  : <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> element2  ;</span><br><span class="line">    <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>非位域字段穿插在其中，不会产生压缩，在VC6和Dev-C++中得到的大小均为3。</p><p>【例8】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructBitField</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> element1   : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> element2   : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> element3   : <span class="number">29</span>;</span><br><span class="line">    <span class="keyword">int</span> element4   : <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">char</span> element5  :<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span> stelement;  <span class="comment">//在含位域的结构或联合中也可同时说明普通成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位域中最宽类型int的字节数为4，因此结构体按4字节对齐，在VC6中其sizeof为16。</p><h3 id="4-3-3-注意事项"><a href="#4-3-3-注意事项" class="headerlink" title="4.3.3. 注意事项"></a>4.3.3. 注意事项</h3><p>关于位域操作有几点需要注意：</p><p>1）<code>位域的地址不能访问，因此不允许将&amp;运算符用于位域</code>。不能使用指向位域的指针也不能使用位域的数组（数组是种特殊指针）。例如，scanf函数无法直接向位域中存储数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitField1</span> <span class="title">tBit</span>;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tBit.element2); <span class="comment">//error: cannot take address of bit-field &#x27;element2&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用scanf函数将输入读入到一个普通的整型变量中，然后再赋值给tBit.element2。</p><p>2）<code>位域不能作为函数返回的结果</code>。<br>3）<code>位域以定义的类型为单位，且位域的长度不能够超过所定义类型的长度</code>。例如：定义 int a:33 是不允许的。<br>4）<code>位域可以不指定位域名，但不能访问无名的位域</code>。</p><blockquote><p><strong>位域可以无位域名，只用作填充或调整位置，占位大小取决于该类型</strong>。例如，<code>char :0 表示整个位域向后推一个字节</code>，即该无名位域后的下一个位域从下一个字节开始存放，同理 <code>short :0</code> 和 <code>int :0</code> 分别表示整个位域向后推两个和四个字节。</p><p>当空位域的长度为具体数值N时(如 int :2)，该变量仅用来占位N位。</p></blockquote><p>【例9】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField3</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1  : <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span>  :<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体大小为3。因为element1占3位，后面要保留6位而char为8位，所以保留的6位只能放到第2个字节。同样element3只能放到第3字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField4</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1  : <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span>  :<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员element1分配3位，接着跳过余下的4位到下一个存储单元，然后给成员element3分配5位。所以，上面的结构体大小为2 。</p><p>5）<strong>位域的表示范围：</strong></p><ul><li>位域的赋值不能超过其可以表示的范围。</li><li>位域的类型决定该编码能表示的值的结果。</li></ul><p>对于第二点，若位域为unsigned类型，则直接转化为正数；若非unsigned类型，则先判断最高位是否为1，若为1，则表示补码，则对其除符号位外的所有位取反再加一得到最后的结果数据（原码）。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p:<span class="number">3</span> = <span class="number">111</span>;   <span class="comment">//p表示7</span></span><br><span class="line"><span class="keyword">int</span> p:<span class="number">3</span> = <span class="number">111</span>;            <span class="comment">//p 表示-1，对除符号位之外的所有位取反再加一</span></span><br></pre></td></tr></table></figure><p>6）<strong>带位域的结构在内存中各个位域的存储方式取决于编译器，既可从左到右也可从右到左存储。</strong></p><p>【例10】在VC6下执行下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">char</span> a : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> b : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> c : <span class="number">2</span>;</span><br><span class="line">        &#125;bits;</span><br><span class="line">    &#125;num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input an integer for i(0~15): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num.i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d, cba = %d %d %d\n&quot;</span>, num.i, num.bits.c, num.bits.b, num.bits.a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>输入i值为11，则输出为i = 11, cba = -2 -1 -1。</p><p>Intel x86 处理器按小字节序存储数据，所以bits中的位域在内存中放置顺序为ccba。当num.i置为11时，bits的最低有效位(即位域a)的值为1，a、b、c按低地址到高地址分别存储为10、1、1(二进制)。</p><p><code>但为什么最后的打印结果是a=-1而不是1？</code></p><p>因为位域a定义的类型signed char是有符号数，所以尽管a只有1位，仍要进行符号扩展。1做为补码存在，对应原码-1。</p><p>如果将a、b、c的类型定义为unsigned char，即可得到cba = 2 1 1。1011即为11的二进制数。</p><blockquote><p>注：C语言中，不同的成员使用共同的存储区域的数据构造类型称为联合(或共用体)。联合占用空间的大小取决于类型长度最大的成员。联合在定义、说明和使用形式上与结构体相似。</p></blockquote><p>7）<strong>位域的实现会因编译器的不同而不同，使用位域会影响程序可移植性</strong>。因此如无必要，最好不要使用位域。</p><p>8）<strong>尽管使用位域可以节省内存空间，但却增加了处理时间</strong>。当访问各个位域成员时，需要把位域从它所在的字中分解出来或反过来把一值压缩存到位域所在的字位中。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>让我们回到引言部分的问题。</p><p>缺省情况下，C/C++编译器默认将结构、栈中的成员数据进行内存对齐。因此，引言程序输出就变成”c1 -&gt; 0, s -&gt; 2, c2 -&gt; 4, i -&gt; 8”。</p><p>编译器将未对齐的成员向后移，将每一个都成员对齐到自然边界上，从而也导致整个结构的尺寸变大。尽管会牺牲一点空间(成员之间有空洞)，但提高了性能。</p><p>也正是这个原因，引言例子中sizeof(T_ FOO)为12，而不是8。</p><p>总结说来，就是：<strong>在结构体中，综合考虑变量本身和指定的对齐值；在栈上，不考虑变量本身的大小，统一对齐到4字节</strong>。</p><blockquote><p><strong>说明：</strong> 本文转载自 <a href="https://www.cnblogs.com/clover-toeic/p/3853132.html">https://www.cnblogs.com/clover-toeic/p/3853132.html</a></p></blockquote><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h1&gt;&lt;p&gt;考虑下面的结构体定义：&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="程序人生" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="C语言" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://dbkernel.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="字节对齐" scheme="http://dbkernel.github.io/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
    <category term="字节序" scheme="http://dbkernel.github.io/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    
    <category term="网络序" scheme="http://dbkernel.github.io/tags/%E7%BD%91%E7%BB%9C%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>程序人生 | Makefile常用模板 - 静态链接库/动态链接库/可执行文件</title>
    <link href="http://dbkernel.github.io/2014/07/10/makefile-common-templates/"/>
    <id>http://dbkernel.github.io/2014/07/10/makefile-common-templates/</id>
    <published>2014-07-10T03:51:10.000Z</published>
    <updated>2021-09-04T15:21:56.375Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文把 makefile 分成了三份：生成可执行文件的 makefile，生成静态链接库的 makefile，生成动态链接库的 makefile。</p><p>这些 makefile 都很简单，一般都是一看就会用，用法也很容易，只需要把它们拷贝到你的代码的同一目录下，然后就可以用 make 来生成目标文件了。</p><p>下面是三个makefile的源代码： </p><h2 id="生成可执行文件的-makefile"><a href="#生成可执行文件的-makefile" class="headerlink" title="生成可执行文件的 makefile"></a>生成可执行文件的 makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment">#source file</span></span><br><span class="line"><span class="comment">#源文件，自动找所有.c和.cpp文件，并将目标定义为同名.o文件</span></span><br><span class="line">SOURCE  := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">OBJS    := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">patsubst</span> %.cpp,%.o,<span class="variable">$(SOURCE)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#target you can change test to what you want</span></span><br><span class="line"><span class="comment">#目标文件名，输入任意你想要的执行文件名</span></span><br><span class="line">TARGET  := test</span><br><span class="line"></span><br><span class="line"><span class="comment">#compile and lib parameter</span></span><br><span class="line"><span class="comment">#编译参数</span></span><br><span class="line">CC      := gcc</span><br><span class="line">LIBS    :=</span><br><span class="line">LDFLAGS :=</span><br><span class="line">DEFINES :=</span><br><span class="line">INCLUDE := -I.</span><br><span class="line">CFLAGS  := -g -Wall -O3 <span class="variable">$(DEFINES)</span> <span class="variable">$(INCLUDE)</span></span><br><span class="line">CXXFLAGS:= <span class="variable">$(CFLAGS)</span> -DHAVE_CONFIG_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#i think you should do anything here</span></span><br><span class="line"><span class="comment">#下面的基本上不需要做任何改动了</span></span><br><span class="line">.PHONY : everything objs clean veryclean rebuild</span><br><span class="line"></span><br><span class="line">everything : <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">objs : <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">rebuild: veryclean everything</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    rm -fr *.so</span><br><span class="line">    rm -fr *.o</span><br><span class="line"></span><br><span class="line">veryclean : clean</span><br><span class="line">    rm -fr <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(LIBS)</span></span><br></pre></td></tr></table></figure><h2 id="生成静态链接库的-makefile"><a href="#生成静态链接库的-makefile" class="headerlink" title="生成静态链接库的 makefile"></a>生成静态链接库的 makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#target you can change test to what you want</span></span><br><span class="line"><span class="comment">#共享库文件名，lib*.a</span></span><br><span class="line">TARGET  := libtest.a</span><br><span class="line"></span><br><span class="line"><span class="comment">#compile and lib parameter</span></span><br><span class="line"><span class="comment">#编译参数</span></span><br><span class="line">CC      := gcc</span><br><span class="line">AR      = ar</span><br><span class="line">RANLIB  = ranlib</span><br><span class="line">LIBS    :=</span><br><span class="line">LDFLAGS :=</span><br><span class="line">DEFINES :=</span><br><span class="line">INCLUDE := -I.</span><br><span class="line">CFLAGS  := -g -Wall -O3 <span class="variable">$(DEFINES)</span> <span class="variable">$(INCLUDE)</span></span><br><span class="line">CXXFLAGS:= <span class="variable">$(CFLAGS)</span> -DHAVE_CONFIG_H</span><br><span class="line"></span><br><span class="line"><span class="comment">#i think you should do anything here</span></span><br><span class="line"><span class="comment">#下面的基本上不需要做任何改动了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#source file</span></span><br><span class="line"><span class="comment">#源文件，自动找所有.c和.cpp文件，并将目标定义为同名.o文件</span></span><br><span class="line">SOURCE  := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">OBJS    := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">patsubst</span> %.cpp,%.o,<span class="variable">$(SOURCE)</span>)</span>)</span><br><span class="line"></span><br><span class="line">.PHONY : everything objs clean veryclean rebuild</span><br><span class="line"></span><br><span class="line">everything : <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">objs : <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">rebuild: veryclean everything</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    rm -fr *.o</span><br><span class="line"></span><br><span class="line">veryclean : clean</span><br><span class="line">    rm -fr <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(AR)</span> cru <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(RANLIB)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><h2 id="生成动态链接库的-makefile"><a href="#生成动态链接库的-makefile" class="headerlink" title="生成动态链接库的 makefile"></a>生成动态链接库的 makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#target you can change test to what you want</span></span><br><span class="line"><span class="comment">#共享库文件名，lib*.so</span></span><br><span class="line">TARGET  := libtest.so</span><br><span class="line"></span><br><span class="line"><span class="comment">#compile and lib parameter</span></span><br><span class="line"><span class="comment">#编译参数</span></span><br><span class="line">CC      := gcc</span><br><span class="line">LIBS    :=</span><br><span class="line">LDFLAGS :=</span><br><span class="line">DEFINES :=</span><br><span class="line">INCLUDE := -I.</span><br><span class="line">CFLAGS  := -g -Wall -O3 <span class="variable">$(DEFINES)</span> <span class="variable">$(INCLUDE)</span></span><br><span class="line">CXXFLAGS:= <span class="variable">$(CFLAGS)</span> -DHAVE_CONFIG_H</span><br><span class="line">SHARE   := -fPIC -shared -o</span><br><span class="line"></span><br><span class="line"><span class="comment">#i think you should do anything here</span></span><br><span class="line"><span class="comment">#下面的基本上不需要做任何改动了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#source file</span></span><br><span class="line"><span class="comment">#源文件，自动找所有.c和.cpp文件，并将目标定义为同名.o文件</span></span><br><span class="line">SOURCE  := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">OBJS    := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">patsubst</span> %.cpp,%.o,<span class="variable">$(SOURCE)</span>)</span>)</span><br><span class="line"></span><br><span class="line">.PHONY : everything objs clean veryclean rebuild</span><br><span class="line"></span><br><span class="line">everything : <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">objs : <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">rebuild: veryclean everything</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    rm -fr *.o</span><br><span class="line"></span><br><span class="line">veryclean : clean</span><br><span class="line">    rm -fr <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(SHARE)</span> <span class="variable">$@</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(LIBS)</span></span><br></pre></td></tr></table></figure><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文把 makefile 分成了三份：生成可执行文件的 makefile，生成静态链接库的</summary>
      
    
    
    
    <category term="程序人生" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="Makefile" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Makefile/"/>
    
    
    <category term="Makefile" scheme="http://dbkernel.github.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>程序人生 | UNIX环境高级编程技巧之 du 指令实现</title>
    <link href="http://dbkernel.github.io/2014/07/10/advanced-programming-in-the-unix-environment-du/"/>
    <id>http://dbkernel.github.io/2014/07/10/advanced-programming-in-the-unix-environment-du/</id>
    <published>2014-07-10T02:00:41.000Z</published>
    <updated>2021-08-31T15:31:32.169Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">path_noloop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pos;</span><br><span class="line"></span><br><span class="line">    pos = <span class="built_in">strrchr</span>(path,<span class="string">&#x27;/&#x27;</span>);<span class="comment">//定位最右边的&#x27;/&#x27;的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pos+<span class="number">1</span>,<span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || (<span class="built_in">strcmp</span>(pos+<span class="number">1</span>,<span class="string">&quot;..&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int64_t</span> <span class="title">mydu</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">glob_t</span> globres;</span><br><span class="line">    <span class="keyword">int64_t</span> sum;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statres</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> nextpath[PATHSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lstat</span>(path, &amp;statres) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;lstat()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//exit(1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">S_ISDIR</span>(statres.st_mode))</span><br><span class="line">        <span class="keyword">return</span> statres.st_blocks;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(nextpath, path,PATHSIZE);</span><br><span class="line">    <span class="built_in">strncat</span>(nextpath, <span class="string">&quot;/*&quot;</span> , PATHSIZE);</span><br><span class="line">    <span class="built_in">glob</span>(nextpath,GLOB_NOSORT, <span class="literal">NULL</span>, &amp;globres);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(nextpath, path,PATHSIZE);</span><br><span class="line">    <span class="built_in">strncat</span>(nextpath, <span class="string">&quot;/.*&quot;</span> , PATHSIZE);</span><br><span class="line">    <span class="built_in">glob</span>(nextpath,GLOB_NOSORT|GLOB_APPEND, <span class="literal">NULL</span>, &amp;globres);</span><br><span class="line"></span><br><span class="line">    sum = statres.st_blocks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ;i &lt; globres.gl_pathc ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">path_noloop</span>(globres.gl_pathv[i]))</span><br><span class="line">            sum += <span class="built_in">mydu</span>(globres.gl_pathv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld 512B blocks\n&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>)<span class="built_in">mydu</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -Wall testdu.c -o testdu</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul><li><code>testdf</code>执行效果：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./testdu /usr/bin</span><br><span class="line">1766184 512B blocks</span><br></pre></td></tr></table></figure></li><li><code>原生df</code>执行效果：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ du -sh /usr/bin</span><br><span class="line">859M/usr/bin</span><br></pre></td></tr></table></figure></li></ul><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="程序人生" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="APUE" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/APUE/"/>
    
    
    <category term="APUE" scheme="http://dbkernel.github.io/tags/APUE/"/>
    
    <category term="UNIX" scheme="http://dbkernel.github.io/tags/UNIX/"/>
    
    <category term="du" scheme="http://dbkernel.github.io/tags/du/"/>
    
  </entry>
  
  <entry>
    <title>程序人生 | UNIX环境高级编程技巧之 df 指令实现</title>
    <link href="http://dbkernel.github.io/2014/07/10/advanced-programming-in-the-unix-environment-df/"/>
    <id>http://dbkernel.github.io/2014/07/10/advanced-programming-in-the-unix-environment-df/</id>
    <published>2014-07-10T01:48:48.000Z</published>
    <updated>2021-08-31T15:17:33.202Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mntent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/vfs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> G = <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024ull</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> M = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> K = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">kscale</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> b, <span class="keyword">unsigned</span> <span class="keyword">long</span> bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> size = b * (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)bs;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; G)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%0.2f GB&quot;</span>, size/(G*<span class="number">1.0</span>));</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%0.2f MB&quot;</span>, size/(<span class="number">1.0</span>*M));</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; K)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%0.2f K&quot;</span>, size/(<span class="number">1.0</span>*K));</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%0.2f B&quot;</span>, size*<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* mount_table;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mntent</span> *<span class="title">mount_entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> blocks_used;</span><br><span class="line">    <span class="keyword">unsigned</span> blocks_percent_used;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *disp_units_hdr = <span class="literal">NULL</span>;</span><br><span class="line">    mount_table = <span class="literal">NULL</span>;</span><br><span class="line">    mount_table = <span class="built_in">setmntent</span>(<span class="string">&quot;/etc/mtab&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mount_table)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;set mount entry error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    disp_units_hdr = <span class="string">&quot;     Size&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Filesystem           %-15sUsed Available %s Mounted on\n&quot;</span>,</span><br><span class="line">            disp_units_hdr, <span class="string">&quot;Use%&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *device;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mount_point;</span><br><span class="line">        <span class="keyword">if</span> (mount_table) &#123;</span><br><span class="line">            mount_entry = <span class="built_in">getmntent</span>(mount_table);</span><br><span class="line">            <span class="keyword">if</span> (!mount_entry) &#123;</span><br><span class="line">                <span class="built_in">endmntent</span>(mount_table);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        device = mount_entry-&gt;mnt_fsname;</span><br><span class="line">        mount_point = mount_entry-&gt;mnt_dir;</span><br><span class="line">        <span class="comment">//fprintf(stderr, &quot;mount info: device=%s mountpoint=%s\n&quot;, device, mount_point);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">statfs</span>(mount_point, &amp;s) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;statfs failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((s.f_blocks &gt; <span class="number">0</span>) || !mount_table )</span><br><span class="line">        &#123;</span><br><span class="line">            blocks_used = s.f_blocks - s.f_bfree;</span><br><span class="line">            blocks_percent_used = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (blocks_used + s.f_bavail)</span><br><span class="line">            &#123;</span><br><span class="line">                blocks_percent_used = (blocks_used * <span class="number">100ULL</span></span><br><span class="line">                        + (blocks_used + s.f_bavail)/<span class="number">2</span></span><br><span class="line">                        ) / (blocks_used + s.f_bavail);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* GNU coreutils 6.10 skips certain mounts, try to be compatible.  */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(device, <span class="string">&quot;rootfs&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">printf</span>(<span class="string">&quot;\n%-20s&quot;</span> + <span class="number">1</span>, device) &gt; <span class="number">20</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n%-20s&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">char</span> s1[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">char</span> s2[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">char</span> s3[<span class="number">20</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(s1, <span class="built_in">kscale</span>(s.f_blocks, s.f_bsize));</span><br><span class="line">            <span class="built_in">strcpy</span>(s2, <span class="built_in">kscale</span>(s.f_blocks - s.f_bfree, s.f_bsize));</span><br><span class="line">            <span class="built_in">strcpy</span>(s3, <span class="built_in">kscale</span>(s.f_bavail, s.f_bsize));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %9s %9s %9s %3u%% %s\n&quot;</span>,</span><br><span class="line">                    s1,</span><br><span class="line">                    s2,</span><br><span class="line">                    s3,</span><br><span class="line">                    blocks_percent_used, mount_point);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -Wall testdf.c -o testdf</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul><li><code>testdf</code>执行效果：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ./testdf</span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line">udev                   3.87 GB    0.00 B   3.87 GB   0% /dev</span><br><span class="line">tmpfs                796.17 MB  980.00 K 795.21 MB   0% /run</span><br><span class="line">/dev/vda1             96.75 GB  40.54 GB  56.19 GB  42% /</span><br><span class="line">tmpfs                  3.89 GB    0.00 B   3.89 GB   0% /dev/shm</span><br><span class="line">tmpfs                  5.00 MB    0.00 B   5.00 MB   0% /run/lock</span><br><span class="line">tmpfs                  3.89 GB    0.00 B   3.89 GB   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda15           104.35 MB   3.86 MB 100.50 MB   4% /boot/efi</span><br><span class="line">/dev/loop1            55.50 MB  55.50 MB    0.00 B 100% /snap/core18/2074</span><br><span class="line">/dev/loop2            70.62 MB  70.62 MB    0.00 B 100% /snap/lxd/16922</span><br><span class="line">/dev/loop4            70.38 MB  70.38 MB    0.00 B 100% /snap/lxd/21029</span><br><span class="line">/dev/loop5            32.38 MB  32.38 MB    0.00 B 100% /snap/snapd/12704</span><br><span class="line">tmpfs                796.17 MB  980.00 K 795.21 MB   0% /run/snapd/ns</span><br><span class="line">tmpfs                796.17 MB    0.00 B 796.17 MB   0% /run/user/1000</span><br><span class="line">/dev/loop6            55.50 MB  55.50 MB    0.00 B 100% /snap/core18/2128</span><br><span class="line">/dev/loop0            32.38 MB  32.38 MB    0.00 B 100% /snap/snapd/12883</span><br></pre></td></tr></table></figure></li><li><code>原生df</code>执行效果：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs           797M  980K  796M   1% /run</span><br><span class="line">/dev/vda1        97G   41G   57G  42% /</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda15      105M  3.9M  101M   4% /boot/efi</span><br><span class="line">/dev/loop1       56M   56M     0 100% /snap/core18/2074</span><br><span class="line">/dev/loop2       71M   71M     0 100% /snap/lxd/16922</span><br><span class="line">/dev/loop4       71M   71M     0 100% /snap/lxd/21029</span><br><span class="line">/dev/loop5       33M   33M     0 100% /snap/snapd/12704</span><br><span class="line">tmpfs           797M     0  797M   0% /run/user/1000</span><br><span class="line">/dev/loop6       56M   56M     0 100% /snap/core18/2128</span><br><span class="line">/dev/loop0       33M   33M     0 100% /snap/snapd/12883</span><br></pre></td></tr></table></figure></li></ul><hr><p>欢迎关注我的微信公众号【MySQL数据库技术】。</p><img src="https://dbkernel-1306518848.cos.ap-beijing.myqcloud.com/wechat/my-wechat-official-account.png" width="400" height="400" alt="MySQL数据库技术" align="left"/><table><thead><tr><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://dbkernel.github.io/">https://dbkernel.github.io</a></td></tr><tr><td>知乎</td><td><a href="https://www.zhihu.com/people/dbkernel/posts">https://www.zhihu.com/people/dbkernel/posts</a></td></tr><tr><td>思否（SegmentFault）</td><td><a href="https://segmentfault.com/u/dbkernel">https://segmentfault.com/u/dbkernel</a></td></tr><tr><td>掘金</td><td><a href="https://juejin.im/user/5e9d3ed251882538083fed1f/posts">https://juejin.im/user/5e9d3ed251882538083fed1f/posts</a></td></tr><tr><td>开源中国（oschina）</td><td><a href="https://my.oschina.net/dbkernel">https://my.oschina.net/dbkernel</a></td></tr><tr><td>博客园（cnblogs）</td><td><a href="https://www.cnblogs.com/dbkernel">https://www.cnblogs.com/dbkernel</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="程序人生" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="APUE" scheme="http://dbkernel.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/APUE/"/>
    
    
    <category term="APUE" scheme="http://dbkernel.github.io/tags/APUE/"/>
    
    <category term="UNIX" scheme="http://dbkernel.github.io/tags/UNIX/"/>
    
    <category term="df" scheme="http://dbkernel.github.io/tags/df/"/>
    
  </entry>
  
</feed>
